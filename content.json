{"meta":{"title":"世界的侧面","subtitle":"以怎样的角度，才能看到这个世界的侧面？","description":"","author":"初心Yearth","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue 2.6 源码分析之旅【5】 —— 模板编译","slug":"2020-08-20","date":"2020-08-20T08:16:01.552Z","updated":"2020-08-20T08:16:01.552Z","comments":false,"path":"2020/08/20/2020-08-20/","link":"","permalink":"http://yoursite.com/2020/08/20/2020-08-20/","excerpt":"模板编译是 vue 作为一个前端 MVVM 框架最为核心的部分，我们今天的目标是粗浅的分析一下 vue 模板编译的主要流程，相信通过本次学习，我们将能够回答下面的问题： 什么是模板编译？ 模板编译主要做了什么，流程如何？ vue 指令中，v-for 和 v-if 的优先级如何？ 那么便开始吧(๑•̀ㅂ•́)و✧！","text":"模板编译是 vue 作为一个前端 MVVM 框架最为核心的部分，我们今天的目标是粗浅的分析一下 vue 模板编译的主要流程，相信通过本次学习，我们将能够回答下面的问题： 什么是模板编译？ 模板编译主要做了什么，流程如何？ vue 指令中，v-for 和 v-if 的优先级如何？ 那么便开始吧(๑•̀ㅂ•́)و✧！ 什么是模板编译？模板编译的主要目的是将模板（template）转化成渲染函数（render）。 即下图所示的流程： 为什么需要这么做呢？ 因为我们在使用框架中会用到各种各样的指令，变量，表达式，这些显然不是 html 的内容，js 需要对其解析，转化成能够理解的内容，经过处理之后输出结果。当然，手写右边的渲染函数也是可以的，但这显然不切实际，不但开发效率极其低下，还很容易出 bug。对于用户而言，能够直接书写 html 肯定是最友好的，所以才需要对模板编译。 vm.$options.render在之前的分析中我们知道，Vue.prototype._render 能够生成虚拟 dom，而其中以下代码非常关键： 12const &#123; render, _parentVnode &#125; = vm.$optionsvnode = render.call(vm._renderProxy, vm.$createElement) 说明生成虚拟 dom 的核心方法是 vm.$options.render，那么问题来了：这个 vm.$options.render，它是怎么来的？ 要回答这个问题，我们得回到程序的入口，那里有一个操作：扩展平台对应的 $mount： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Vue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`) return this &#125; const options = this.$options // resolve template/el and convert to render function if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn(`Template element not found or is empty: $&#123;options.template&#125;`, this) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments, &#125;, this ) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 这里的大致流程我们在初始化流程的时候已经分析过了，就不再赘述。 我们可以看到，这里调用了 compileToFunctions，其中一个参数是 template，另一个参数是配置项，并且返回值分别为 render 和 staticRenderFns。说明它的功能是通过模板和配置项生成渲染函数，那么进去看看： 123456789101112131415export const createCompiler = createCompilerCreator(function baseCompile( template: string, options: CompilerOptions): CompiledResult &#123; const ast = parse(template.trim(), options) if (options.optimize !== false) &#123; optimize(ast, options) &#125; const code = generate(ast, options) return &#123; ast, render: code.render, staticRenderFns: code.staticRenderFns, &#125;&#125;) 这里主要有三个步骤： 通过 parse 生成和模板对应的 ast 树 通过 optimize 完善 ast 树的额外信息 通过 generate 生成 render 函数 我们先来看看 parse 的流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304export function parse(template: string, options: CompilerOptions): ASTElement | void &#123; warn = options.warn || baseWarn platformIsPreTag = options.isPreTag || no platformMustUseProp = options.mustUseProp || no platformGetTagNamespace = options.getTagNamespace || no const isReservedTag = options.isReservedTag || no maybeComponent = (el: ASTElement) =&gt; !!el.component || !isReservedTag(el.tag) transforms = pluckModuleFunction(options.modules, &#x27;transformNode&#x27;) preTransforms = pluckModuleFunction(options.modules, &#x27;preTransformNode&#x27;) postTransforms = pluckModuleFunction(options.modules, &#x27;postTransformNode&#x27;) delimiters = options.delimiters const stack = [] const preserveWhitespace = options.preserveWhitespace !== false const whitespaceOption = options.whitespace let root let currentParent let inVPre = false let inPre = false let warned = false function warnOnce(msg, range) &#123; if (!warned) &#123; warned = true warn(msg, range) &#125; &#125; function closeElement(element) &#123; trimEndingWhitespace(element) if (!inVPre &amp;&amp; !element.processed) &#123; element = processElement(element, options) &#125; // tree management if (!stack.length &amp;&amp; element !== root) &#123; // allow root elements with v-if, v-else-if and v-else if (root.if &amp;&amp; (element.elseif || element.else)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkRootConstraints(element) &#125; addIfCondition(root, &#123; exp: element.elseif, block: element, &#125;) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warnOnce( `Component template should contain exactly one root element. ` + `If you are using v-if on multiple elements, ` + `use v-else-if to chain them instead.`, &#123; start: element.start &#125; ) &#125; &#125; if (currentParent &amp;&amp; !element.forbidden) &#123; if (element.elseif || element.else) &#123; processIfConditions(element, currentParent) &#125; else &#123; if (element.slotScope) &#123; // scoped slot // keep it in the children list so that v-else(-if) conditions can // find it as the prev node. const name = element.slotTarget || &#x27;&quot;default&quot;&#x27; ;(currentParent.scopedSlots || (currentParent.scopedSlots = &#123;&#125;))[name] = element &#125; currentParent.children.push(element) element.parent = currentParent &#125; &#125; // final children cleanup // filter out scoped slots element.children = element.children.filter((c) =&gt; !(c: any).slotScope) // remove trailing whitespace node again trimEndingWhitespace(element) // check pre state if (element.pre) &#123; inVPre = false &#125; if (platformIsPreTag(element.tag)) &#123; inPre = false &#125; // apply post-transforms for (let i = 0; i &lt; postTransforms.length; i++) &#123; postTransforms[i](element, options) &#125; &#125; function trimEndingWhitespace(el) &#123; // remove trailing whitespace node if (!inPre) &#123; let lastNode while ((lastNode = el.children[el.children.length - 1]) &amp;&amp; lastNode.type === 3 &amp;&amp; lastNode.text === &#x27; &#x27;) &#123; el.children.pop() &#125; &#125; &#125; function checkRootConstraints(el) &#123; if (el.tag === &#x27;slot&#x27; || el.tag === &#x27;template&#x27;) &#123; warnOnce(`Cannot use &lt;$&#123;el.tag&#125;&gt; as component root element because it may ` + &#x27;contain multiple nodes.&#x27;, &#123; start: el.start, &#125;) &#125; if (el.attrsMap.hasOwnProperty(&#x27;v-for&#x27;)) &#123; warnOnce( &#x27;Cannot use v-for on stateful component root element because &#x27; + &#x27;it renders multiple elements.&#x27;, el.rawAttrsMap[&#x27;v-for&#x27;] ) &#125; &#125; parseHTML(template, &#123; warn, expectHTML: options.expectHTML, isUnaryTag: options.isUnaryTag, canBeLeftOpenTag: options.canBeLeftOpenTag, shouldDecodeNewlines: options.shouldDecodeNewlines, shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref, shouldKeepComment: options.comments, outputSourceRange: options.outputSourceRange, start(tag, attrs, unary, start, end) &#123; // check namespace. // inherit parent ns if there is one const ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag) // handle IE svg bug /* istanbul ignore if */ if (isIE &amp;&amp; ns === &#x27;svg&#x27;) &#123; attrs = guardIESVGBug(attrs) &#125; let element: ASTElement = createASTElement(tag, attrs, currentParent) if (ns) &#123; element.ns = ns &#125; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (options.outputSourceRange) &#123; element.start = start element.end = end element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) =&gt; &#123; cumulated[attr.name] = attr return cumulated &#125;, &#123;&#125;) &#125; attrs.forEach((attr) =&gt; &#123; if (invalidAttributeRE.test(attr.name)) &#123; warn( `Invalid dynamic argument expression: attribute names cannot contain ` + `spaces, quotes, &lt;, &gt;, / or =.`, &#123; start: attr.start + attr.name.indexOf(`[`), end: attr.start + attr.name.length, &#125; ) &#125; &#125;) &#125; if (isForbiddenTag(element) &amp;&amp; !isServerRendering()) &#123; element.forbidden = true process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;Templates should only be responsible for mapping the state to the &#x27; + &#x27;UI. Avoid placing tags with side-effects in your templates, such as &#x27; + `&lt;$&#123;tag&#125;&gt;` + &#x27;, as they will not be parsed.&#x27;, &#123; start: element.start &#125; ) &#125; // apply pre-transforms for (let i = 0; i &lt; preTransforms.length; i++) &#123; element = preTransforms[i](element, options) || element &#125; if (!inVPre) &#123; processPre(element) if (element.pre) &#123; inVPre = true &#125; &#125; if (platformIsPreTag(element.tag)) &#123; inPre = true &#125; if (inVPre) &#123; processRawAttrs(element) &#125; else if (!element.processed) &#123; // structural directives processFor(element) processIf(element) processOnce(element) &#125; if (!root) &#123; root = element if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkRootConstraints(root) &#125; &#125; if (!unary) &#123; currentParent = element stack.push(element) &#125; else &#123; closeElement(element) &#125; &#125;, end(tag, start, end) &#123; const element = stack[stack.length - 1] // pop stack stack.length -= 1 currentParent = stack[stack.length - 1] if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; options.outputSourceRange) &#123; element.end = end &#125; closeElement(element) &#125;, chars(text: string, start: number, end: number) &#123; if (!currentParent) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (text === template) &#123; warnOnce(&#x27;Component template requires a root element, rather than just text.&#x27;, &#123; start &#125;) &#125; else if ((text = text.trim())) &#123; warnOnce(`text &quot;$&#123;text&#125;&quot; outside root element will be ignored.`, &#123; start &#125;) &#125; &#125; return &#125; // IE textarea placeholder bug /* istanbul ignore if */ if (isIE &amp;&amp; currentParent.tag === &#x27;textarea&#x27; &amp;&amp; currentParent.attrsMap.placeholder === text) &#123; return &#125; const children = currentParent.children if (inPre || text.trim()) &#123; text = isTextTag(currentParent) ? text : decodeHTMLCached(text) &#125; else if (!children.length) &#123; // remove the whitespace-only node right after an opening tag text = &#x27;&#x27; &#125; else if (whitespaceOption) &#123; if (whitespaceOption === &#x27;condense&#x27;) &#123; // in condense mode, remove the whitespace node if it contains // line break, otherwise condense to a single space text = lineBreakRE.test(text) ? &#x27;&#x27; : &#x27; &#x27; &#125; else &#123; text = &#x27; &#x27; &#125; &#125; else &#123; text = preserveWhitespace ? &#x27; &#x27; : &#x27;&#x27; &#125; if (text) &#123; if (!inPre &amp;&amp; whitespaceOption === &#x27;condense&#x27;) &#123; // condense consecutive whitespaces into single space text = text.replace(whitespaceRE, &#x27; &#x27;) &#125; let res let child: ?ASTNode if (!inVPre &amp;&amp; text !== &#x27; &#x27; &amp;&amp; (res = parseText(text, delimiters))) &#123; child = &#123; type: 2, expression: res.expression, tokens: res.tokens, text, &#125; &#125; else if (text !== &#x27; &#x27; || !children.length || children[children.length - 1].text !== &#x27; &#x27;) &#123; child = &#123; type: 3, text, &#125; &#125; if (child) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; options.outputSourceRange) &#123; child.start = start child.end = end &#125; children.push(child) &#125; &#125; &#125;, comment(text: string, start, end) &#123; // adding anyting as a sibling to the root node is forbidden // comments should still be allowed, but ignored if (currentParent) &#123; const child: ASTText = &#123; type: 3, text, isComment: true, &#125; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; options.outputSourceRange) &#123; child.start = start child.end = end &#125; currentParent.children.push(child) &#125; &#125;, &#125;) return root&#125; 可以看到，这个函数相当复杂，其中最为核心的方法是 parseHTML，顾名思义也知道这就是解析 html 模板的核心方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253export function parseHTML(html, options) &#123; const stack = [] const expectHTML = options.expectHTML const isUnaryTag = options.isUnaryTag || no const canBeLeftOpenTag = options.canBeLeftOpenTag || no let index = 0 let last, lastTag while (html) &#123; last = html // Make sure we&#x27;re not in a plaintext content element like script/style if (!lastTag || !isPlainTextElement(lastTag)) &#123; let textEnd = html.indexOf(&#x27;&lt;&#x27;) if (textEnd === 0) &#123; // Comment: if (comment.test(html)) &#123; const commentEnd = html.indexOf(&#x27;--&gt;&#x27;) if (commentEnd &gt;= 0) &#123; if (options.shouldKeepComment) &#123; options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3) &#125; advance(commentEnd + 3) continue &#125; &#125; // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment if (conditionalComment.test(html)) &#123; const conditionalEnd = html.indexOf(&#x27;]&gt;&#x27;) if (conditionalEnd &gt;= 0) &#123; advance(conditionalEnd + 2) continue &#125; &#125; // Doctype: const doctypeMatch = html.match(doctype) if (doctypeMatch) &#123; advance(doctypeMatch[0].length) continue &#125; // End tag: const endTagMatch = html.match(endTag) if (endTagMatch) &#123; const curIndex = index advance(endTagMatch[0].length) parseEndTag(endTagMatch[1], curIndex, index) continue &#125; // Start tag: const startTagMatch = parseStartTag() if (startTagMatch) &#123; handleStartTag(startTagMatch) if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) &#123; advance(1) &#125; continue &#125; &#125; let text, rest, next if (textEnd &gt;= 0) &#123; rest = html.slice(textEnd) while ( !endTag.test(rest) &amp;&amp; !startTagOpen.test(rest) &amp;&amp; !comment.test(rest) &amp;&amp; !conditionalComment.test(rest) ) &#123; // &lt; in plain text, be forgiving and treat it as text next = rest.indexOf(&#x27;&lt;&#x27;, 1) if (next &lt; 0) break textEnd += next rest = html.slice(textEnd) &#125; text = html.substring(0, textEnd) &#125; if (textEnd &lt; 0) &#123; text = html &#125; if (text) &#123; advance(text.length) &#125; if (options.chars &amp;&amp; text) &#123; options.chars(text, index - text.length, index) &#125; &#125; else &#123; let endTagLength = 0 const stackedTag = lastTag.toLowerCase() const reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp(&#x27;([\\\\s\\\\S]*?)(&lt;/&#x27; + stackedTag + &#x27;[^&gt;]*&gt;)&#x27;, &#x27;i&#x27;)) const rest = html.replace(reStackedTag, function (all, text, endTag) &#123; endTagLength = endTag.length if (!isPlainTextElement(stackedTag) &amp;&amp; stackedTag !== &#x27;noscript&#x27;) &#123; text = text .replace(/&lt;!\\--([\\s\\S]*?)--&gt;/g, &#x27;$1&#x27;) // #7298 .replace(/&lt;!\\[CDATA\\[([\\s\\S]*?)]]&gt;/g, &#x27;$1&#x27;) &#125; if (shouldIgnoreFirstNewline(stackedTag, text)) &#123; text = text.slice(1) &#125; if (options.chars) &#123; options.chars(text) &#125; return &#x27;&#x27; &#125;) index += html.length - rest.length html = rest parseEndTag(stackedTag, index - endTagLength, index) &#125; if (html === last) &#123; options.chars &amp;&amp; options.chars(html) if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !stack.length &amp;&amp; options.warn) &#123; options.warn(`Mal-formatted tag at end of template: &quot;$&#123;html&#125;&quot;`, &#123; start: index + html.length &#125;) &#125; break &#125; &#125; // Clean up any remaining tags parseEndTag() function advance(n) &#123; index += n html = html.substring(n) &#125; function parseStartTag() &#123; const start = html.match(startTagOpen) if (start) &#123; const match = &#123; tagName: start[1], attrs: [], start: index, &#125; advance(start[0].length) let end, attr while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(dynamicArgAttribute) || html.match(attribute))) &#123; attr.start = index advance(attr[0].length) attr.end = index match.attrs.push(attr) &#125; if (end) &#123; match.unarySlash = end[1] advance(end[0].length) match.end = index return match &#125; &#125; &#125; function handleStartTag(match) &#123; const tagName = match.tagName const unarySlash = match.unarySlash if (expectHTML) &#123; if (lastTag === &#x27;p&#x27; &amp;&amp; isNonPhrasingTag(tagName)) &#123; parseEndTag(lastTag) &#125; if (canBeLeftOpenTag(tagName) &amp;&amp; lastTag === tagName) &#123; parseEndTag(tagName) &#125; &#125; const unary = isUnaryTag(tagName) || !!unarySlash const l = match.attrs.length const attrs = new Array(l) for (let i = 0; i &lt; l; i++) &#123; const args = match.attrs[i] const value = args[3] || args[4] || args[5] || &#x27;&#x27; const shouldDecodeNewlines = tagName === &#x27;a&#x27; &amp;&amp; args[1] === &#x27;href&#x27; ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines attrs[i] = &#123; name: args[1], value: decodeAttr(value, shouldDecodeNewlines), &#125; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; options.outputSourceRange) &#123; attrs[i].start = args.start + args[0].match(/^\\s*/).length attrs[i].end = args.end &#125; &#125; if (!unary) &#123; stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end, &#125;) lastTag = tagName &#125; if (options.start) &#123; options.start(tagName, attrs, unary, match.start, match.end) &#125; &#125; function parseEndTag(tagName, start, end) &#123; let pos, lowerCasedTagName if (start == null) start = index if (end == null) end = index // Find the closest opened tag of the same type if (tagName) &#123; lowerCasedTagName = tagName.toLowerCase() for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123; if (stack[pos].lowerCasedTag === lowerCasedTagName) &#123; break &#125; &#125; &#125; else &#123; // If no tag name is provided, clean shop pos = 0 &#125; if (pos &gt;= 0) &#123; // Close all the open elements, up the stack for (let i = stack.length - 1; i &gt;= pos; i--) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; (i &gt; pos || !tagName) &amp;&amp; options.warn) &#123; options.warn(`tag &lt;$&#123;stack[i].tag&#125;&gt; has no matching end tag.`, &#123; start: stack[i].start, end: stack[i].end &#125;) &#125; if (options.end) &#123; options.end(stack[i].tag, start, end) &#125; &#125; // Remove the open elements from the stack stack.length = pos lastTag = pos &amp;&amp; stack[pos - 1].tag &#125; else if (lowerCasedTagName === &#x27;br&#x27;) &#123; if (options.start) &#123; options.start(tagName, [], true, start, end) &#125; &#125; else if (lowerCasedTagName === &#x27;p&#x27;) &#123; if (options.start) &#123; options.start(tagName, [], false, start, end) &#125; if (options.end) &#123; options.end(tagName, start, end) &#125; &#125; &#125;&#125; 上面大致是这样的流程： 碰到起始标签： 生成 ast 元素 判断是否是自闭和标签： 是：关闭元素，出栈 否：入栈 碰到结束标签： 关闭元素，出栈 至于更加细节的属性，映射等等，这里就不深入了，否则很可能陷入枯燥的代码海，花费很多时间还收效甚微。 总之，这里生成了一个和传入模板对应的 ast 树。 那么 optimize 又做了什么呢？ 123456789export function optimize(root: ?ASTElement, options: CompilerOptions) &#123; if (!root) return isStaticKey = genStaticKeysCached(options.staticKeys || &#x27;&#x27;) isPlatformReservedTag = options.isReservedTag || no // first pass: mark all non-static nodes. markStatic(root) // second pass: mark static roots. markStaticRoots(root, false)&#125; 这里主要是对静态节点做了标记，其主要目的是为了性能优化，比如以下模板： 1234&lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello Vue&lt;/h1&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 显然，&lt;h1&gt;Hello Vue&lt;/h1&gt; 是静态的，无论 msg 怎么改变，对它都没有任何影响，那么将其节点打上 static 标记，就可以在渲染的时候直接渲染，而不用其余操作。 最后来到 generate： 12345678export function generate(ast: ASTElement | void, options: CompilerOptions): CodegenResult &#123; const state = new CodegenState(options) const code = ast ? genElement(ast, state) : &#x27;_c(&quot;div&quot;)&#x27; return &#123; render: `with(this)&#123;return $&#123;code&#125;&#125;`, staticRenderFns: state.staticRenderFns, &#125;&#125; 这里一旦发现 ast 元素，则会通过 genElement 进行渲染函数的创建： 123456789101112131415161718192021222324252627282930313233343536373839404142export function genElement(el: ASTElement, state: CodegenState): string &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === &#x27;template&#x27; &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || &#x27;void 0&#x27; &#125; else if (el.tag === &#x27;slot&#x27;) &#123; return genSlot(el, state) &#125; else &#123; // component or element let code if (el.component) &#123; code = genComponent(el.component, el, state) &#125; else &#123; let data if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData(el, state) &#125; const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c(&#x27;$&#123;el.tag&#125;&#x27;$&#123; data ? `,$&#123;data&#125;` : &#x27;&#x27; // data &#125;$&#123; children ? `,$&#123;children&#125;` : &#x27;&#x27; // children &#125;)` &#125; // module transforms for (let i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code) &#125; return code &#125;&#125; 上面的代码告诉我们： 优先级：static &gt; once &gt; for &gt; if &gt; children &gt; slot 以及上述情况调用的生成函数 那么在 ast 数遍历结束之后，我们应该能得到一个形如下面的字符串： 1;`with(this) &#123;return _c(&#x27;div&#x27;, &#123;attrs: &#123;&quot;id&quot;: &quot;app&quot;&#125;&#125;, [_v(_s(msg))])&#125;` 那么这个字符串是怎么变成函数的呢？ 12345678function createFunction(code, errors) &#123; try &#123; return new Function(code) &#125; catch (err) &#123; errors.push(&#123; err: err, code: code &#125;) return noop &#125;&#125; 可以看到，直接通过 new Function 就能将字符串转化成一个对应的匿名函数了。 脑图如下： 模板方法在生成的 render 函数中，有各种如 _c, _v, _s 等方法，这些方法到底是什么，又有什么作用呢？ 对于这个问题，我们可以看看渲染的帮助方法： 12345678910111213141516171819export function installRenderHelpers(target: any) &#123; target._o = markOnce target._n = toNumber target._s = toString target._l = renderList target._t = renderSlot target._q = looseEqual target._i = looseIndexOf target._m = renderStatic target._f = resolveFilter target._k = checkKeyCodes target._b = bindObjectProps target._v = createTextVNode target._e = createEmptyVNode target._u = resolveScopedSlots target._g = bindObjectListeners target._d = bindDynamicKeys target._p = prependModifier&#125; 这里包含了大量的渲染帮助方法，但是还有一个最关键的没有找到：_c，它又在哪儿呢？ 既然和渲染相关，我们来到 initRender 看看： 1vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 而 createElement 则是用来创建虚拟 dom 的方法，那么 _c 的功能就很清楚了。 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 五：模板编译 那么今天的分析就到此为止啦，我们下期再见，咕咕咕~","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【4】 —— diff 算法","slug":"2020-08-19","date":"2020-08-19T09:43:45.099Z","updated":"2020-08-19T09:43:45.099Z","comments":false,"path":"2020/08/19/2020-08-19/","link":"","permalink":"http://yoursite.com/2020/08/19/2020-08-19/","excerpt":"上一章我们分析了 vue 2.6.x 的异步更新策略，弄清楚了以下几个问题： vue 是在什么阶段进行视图更新的 vue 是在什么位置进行视图更新的 实现 vue 异步更新的核心原理 而今天我们将分析 vue diff 算法，相信读完本文，将会对以下问题有初步的认知： vue diff 算法发生在什么位置 vue diff 算法的核心原理 为什么推荐 v-for 要加上 key 那么便开始吧(๑•̀ㅂ•́)و✧！","text":"上一章我们分析了 vue 2.6.x 的异步更新策略，弄清楚了以下几个问题： vue 是在什么阶段进行视图更新的 vue 是在什么位置进行视图更新的 实现 vue 异步更新的核心原理 而今天我们将分析 vue diff 算法，相信读完本文，将会对以下问题有初步的认知： vue diff 算法发生在什么位置 vue diff 算法的核心原理 为什么推荐 v-for 要加上 key 那么便开始吧(๑•̀ㅂ•́)و✧！ 生成虚拟 DOM这个名词相信大家已经非常熟悉了，这里就当简单复习一下了。 首先自然是概念： 所谓虚拟 DOM，其实就是 js 的对象，主要的目的是描述真实 dom 的结构和关系。 也就是说，虚拟 DOM 就是真实 DOM 的映射。 而这也是 vue 能做到跨平台的原因之一：完成虚拟 DOM 的操作之后，将其 patch 为真实 DOM 的过程中： 目标是浏览器，则 patch 成浏览器结构，那么就能适应浏览器 目标是小程序，则 patch 成小程序的结构，那么就能适应小程序 目标是 app，则 patch 成 app 的结构，那么就能适应移动端 … 那么我们来看看 vue 源码中，关于虚拟 DOM 的操作吧。 结合前面将到的，我们先定位 updateComponent 中的 _render： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* * file: src/core/instance/render.js */Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 上面的核心功能在这里： 1vnode = render.call(vm._renderProxy, vm.$createElement) 通过 render 生成虚拟 DOM，在最后将其返回出去。 虚拟 DOM 转真实 DOM这里我们来到 _update： 123456789101112131415161718192021222324252627282930313233/* * file: src/core/instance/lifecycle.js */Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; 上面的核心在于： 1234567if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)&#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode)&#125; 从注释可以看出，当初始化的时候，是没有 prevVnode 的，所以会走 if 分支，之后会走 else 更新分支。 其核心方法都是 __patch__： 在第一章的分析中，入口文件有一行代码： 1Vue.prototype.__patch__ = inBrowser ? patch : noop 这里安装了平台特有的 patch 方法，我们可以追踪一下： 1var patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;) 说明 createPatchFunction 方法将返回一个 patch 方法，那么我们来到它的返回值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* * file: src/core/vdom/patch.js */return function patch(oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldVnode) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; // **empty mount (likely as component), create new root element** isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; // patch existing root node patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; if (isRealElement) &#123; // mounting to a real element // check if this is server-rendered content and if we can perform // a successful hydration. if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldVnode &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn( &#x27;The client-side rendered virtual DOM tree is not matching &#x27; + &#x27;server-rendered content. This is likely caused by incorrect &#x27; + &#x27;HTML markup, for example nesting block-level elements inside &#x27; + &#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27; + &#x27;full client-side render.&#x27; ) &#125; &#125; // either not server-rendered, or hydration failed. // create an empty node and replace it oldVnode = emptyNodeAt(oldVnode) &#125; // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // update parent placeholder node element, recursively if (isDef(vnode.parent)) &#123; let ancestor = vnode.parent const patchable = isPatchable(vnode) while (ancestor) &#123; for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123; cbs.destroy[i](ancestor) &#125; ancestor.elm = vnode.elm if (patchable) &#123; for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, ancestor) &#125; // #6513 // invoke insert hooks that may have been merged by create hooks. // e.g. for directives that uses the &quot;inserted&quot; hook. const insert = ancestor.data.hook.insert if (insert.merged) &#123; // start at index 1 to avoid re-invoking component mounted hook for (let i = 1; i &lt; insert.fns.length; i++) &#123; insert.fns[i]() &#125; &#125; &#125; else &#123; registerRef(ancestor) &#125; ancestor = ancestor.parent &#125; &#125; // destroy old node if (isDef(parentElm)) &#123; removeVnodes([oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; invokeDestroyHook(oldVnode) &#125; &#125; &#125; invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; 初始化流程对于上面的代码，我们先看看初始化的执行流程： 首先我们可以从注释和判断知道：通常情况下并不会走 if (isUndef(oldVnode)) 这个分支，因为只有当 empty mount 的情况下，才会走这里 接着，初始化的时候，oldVnode === vm.$el，所以是真实节点，即 isRealElement 为真，那么就会走到 if (isRealElement) 分支中 紧接着就会通过 oldVnode = emptyNodeAt(oldVnode) 将生成 oldNode 对一个的虚拟 DOM 随后通过 createElm 创建新的 DOM 树，并且把它放在老节点的旁边 最后通过 removeVnodes 删除老节点 更新流程在更新流程中，传入的 oldVnode 是 prevVnode，即这个时候它已经是一个虚拟 DOM 了，那么如果新老节点是同样类型的节点，就会走到： 1patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) 而这就是大名鼎鼎的 diff 算法发生的地方。 在看 patchVnode 之前，我们先来看看 sameVnode，了解一下到底怎么样才算是相同节点： 1234567function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; ((a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b)) || (isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error))) )&#125; 可以看到，首先 key 一定要相同，然后节点类型相同，如果是 input，则 type 要相同，等等。 二者都没有 key 的时候，undefined === undefined 那么我们接着来到 patchVnode： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123; if (oldVnode === vnode) &#123; return &#125; if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123; // clone reused vnode vnode = ownerArray[index] = cloneVNode(vnode) &#125; const elm = (vnode.elm = oldVnode.elm) if (isTrue(oldVnode.isAsyncPlaceholder)) &#123; if (isDef(vnode.asyncFactory.resolved)) &#123; hydrate(oldVnode.elm, vnode, insertedVnodeQueue) &#125; else &#123; vnode.isAsyncPlaceholder = true &#125; return &#125; // reuse element for static trees. // note we only do this if the vnode is cloned - // if the new node is not cloned it means the render functions have been // reset by the hot-reload-api and we need to do a proper re-render. if ( isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) &#123; vnode.componentInstance = oldVnode.componentInstance return &#125; let i const data = vnode.data if (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update))) i(oldVnode, vnode) &#125; if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkDuplicateKeys(ch) &#125; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; removeVnodes(oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;) &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text) &#125; if (isDef(data)) &#123; if (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch))) i(oldVnode, vnode) &#125;&#125; 这里总的来说，包括了三种操作： 节点属性更新 文本更新 子节点更新 其中本文节点和子节点是互斥的，因为一个节点一旦是文本节点，那么它必然没有子节点，反之它一定不是文本节点。 具体的更新规则如下： 新老节点都有子节点，则调用 updateChildren 123if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)&#125; 新⽼节点都没有⼦节点，进行文本替换 123else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text)&#125; 新节点有⼦节点⽽⽼节点没有⼦节点，则先清空老节点的文本内容，然后为其新增子节点 1234567else if (isDef(ch)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkDuplicateKeys(ch) &#125; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#x27;&#x27;) addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)&#125; 新节点没有⼦节点⽽⽼节点有⼦节点，则移除老节点的所有⼦节点 12345else if (isDef(oldCh)) &#123; removeVnodes(oldCh, 0, oldCh.length - 1)&#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, &#x27;&#x27;)&#125; 那么我们来看看 updateChildren 做了什么： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, vnodeToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elements stay in correct relative positions // during leaving transitions const canMove = !removeOnly if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; checkDuplicateKeys(newCh) &#125; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) if (isUndef(idxInOld)) &#123; // New element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; vnodeToMove = oldCh[idxInOld] if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // same key but different element. treat as new element createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 这里的操作非常巧妙，我们一步步来看看： 首先创建了 4 个游标以及 4 个对应的节点，分别代表老节点和新节点的首尾 进行了一个循环操作，结束条件是老节点和新节点的游标重合，在循环中进行了如下操作： 调整节点引用，保证其有值 如果新老节点的首部相同，则对这两个节点进行 patch 操作，并且首部游标分别后移一位 12345else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx]&#125; 如果新老节点尾部相同，则对这两个节点进行 patch 操作，并且尾部游标分别前移一位 12345else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx]&#125; 如果老节点首部与新节点尾部相同，则对这两个节点进行 patch 操作，老节点首部游标加一，新节点尾部游标减一，并且还要做额外的移动操作，将老节点首部移动到尾部。这个操作其实并不难理解：因为满足这个条件的时候，很可能是进行了逆序的操作。 123456else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx]&#125; 如果老节点尾部与新节点首部相同，则对这两个节点进行 patch 操作，老节点尾部游标减一，新节点首部游标加一，并且还要做额外的移动操作，将老节点尾部移动到首部。 123456else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx]&#125; 如果上述条件都不满足，则只能进行效率较为低下的遍历操作：在老节点中找是否存在于新节点首部相同的节点，这里又存在两种情况： 没找到：说明这个节点是新增节点，直接创建一个新节点 找到了： 相同节点：进行 patch 操作，并且移动老节点 不同节点：创建新节点 当循环结束之后，如果两组节点如果数量不同，则进入下面的流程： 老节点先结束，说明有新增节点，进行批量创建 1234if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)&#125; 新节点先结束，说明有节点删除，进行批量删除 123else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(oldCh, oldStartIdx, oldEndIdx)&#125; 这里的逻辑不可谓不复杂了，我们将脑图整理出来再看看： 从上面我们可以总结出一些规律： 节点比较一定是在同层级之间进行：同层比较 如果存在子节点，一定会优先获取子节点：深度优先 一些有意思的东西关于 vue 的虚拟 DOM这个从 patch 文件的头部我们可以看到： 1Virtual DOM patching algorithm based on Snabbdom by 说明 vue 中的虚拟 DOM 是基于 Snabbdom 的。 视图更新中诡异的画面我们将断点断在新树生成，老树删除之间，可以看到这样的画面： vfor 中 key 的作用要说明这个问题，我们先来看看有 key 的情况下，diff 是如何进行的： 1234567891011121314&lt;div id=&quot;demo&quot;&gt; &lt;p v-for=&quot;item in arr&quot; :key=&quot;item&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; arr: [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;D&#x27;] &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.arr.splice(1, 0, &#x27;E&#x27;) &#125;, 1000); &#125; &#125;);&lt;/script&gt; 首先，我们很清楚，数组最后会变成 [&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 那么我们开始模拟 diff 流程： Step 1 老：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 新：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 比较二者头部，直接 patch 结果：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] Step 2 老：[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 新：[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 比较二者头部，不同节点 → 比较二者尾部，直接 patch 结果：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] Step 3 老：[&#39;B&#39;, &#39;C&#39;] 新：[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;] 比较二者头部，不同节点 → 比较二者尾部，直接 patch 结果：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] Step 4 老：[&#39;B&#39;] 新：[&#39;E&#39;, &#39;B&#39;] 比较二者头部，不同节点 → 比较二者尾部，直接 patch 结果：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] Step 5 老：[] 新：[&#39;E&#39;] 老节点遍历结束，新节点还有剩余，新增节点，位置在 oldStartIdx 后，更新一次 结果：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 综上，上面的算法总共更新了一次页面。 那么，如果没有 key，将会是什么样的情况呢？ Step 1 老：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 新：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 比较二者头部，直接 patch 结果：[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] Step 2 老：[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 新：[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 比较二者头部，直接 patch，更新一次 结果：[&#39;A&#39;, &#39;E&#39;, &#39;C&#39;, &#39;D&#39;] Step 3 老：[&#39;C&#39;, &#39;D&#39;] 新：[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 比较二者头部，直接 patch，更新两次 结果：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;D&#39;] Step 4 老：[&#39;D&#39;] 新：[&#39;C&#39;, &#39;D&#39;] 比较二者头部，直接 patch，更新三次 结果：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;] Step 5 老：[] 新：[&#39;D&#39;] 老节点遍历结束，新节点还有剩余，新增节点，位置在 oldStartIdx 后，更新四次 结果：[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 这里仅仅是这么简单的一个数组，没有 key 的情况下，就已经如此繁琐，其效率之低下已经不言而喻。 这也说明了为什么 vue 非常推荐在使用 v-for 指令的时候为遍历的子项添加上 key，因为这样的效率远远高于没有 key 的情况。 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 四：diff 算法 那么今天的分析就到此为止啦，我们下期再见，咕咕咕~","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【3】 —— 异步更新策略","slug":"2020-08-18","date":"2020-08-18T07:20:52.461Z","updated":"2020-08-18T07:20:52.461Z","comments":false,"path":"2020/08/18/2020-08-18/","link":"","permalink":"http://yoursite.com/2020/08/18/2020-08-18/","excerpt":"上一章我们分析了 vue 2.6.x 的数据响应式原理，弄清楚了以下几个问题： vue 数据响应式是在什么阶段实现的 vue 数据响应式是在什么位置实现的 实现 vue 数据响应式的核心原理 vue 是如何进行依赖收集的 dep 和 watcher 的关系，以及各自的作用 而今天我们将分析 vue 异步更新策略，相信读完本文，将会对以下问题有初步的认知： vue 是在什么阶段进行视图更新的 vue 是在什么位置进行视图更新的 实现 vue 异步更新的核心原理 那么便开始吧(๑•̀ㅂ•́)و✧！","text":"上一章我们分析了 vue 2.6.x 的数据响应式原理，弄清楚了以下几个问题： vue 数据响应式是在什么阶段实现的 vue 数据响应式是在什么位置实现的 实现 vue 数据响应式的核心原理 vue 是如何进行依赖收集的 dep 和 watcher 的关系，以及各自的作用 而今天我们将分析 vue 异步更新策略，相信读完本文，将会对以下问题有初步的认知： vue 是在什么阶段进行视图更新的 vue 是在什么位置进行视图更新的 实现 vue 异步更新的核心原理 那么便开始吧(๑•̀ㅂ•́)و✧！ 为什么需要异步更新？要回答这个问题，通过一个 demo 其实就能很好地说明： 12345678910111213141516&lt;div id=&quot;demo&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; msg: &#x27;1&#x27;, &#125;, created() &#123; this.msg = &#x27;2&#x27; this.msg = &#x27;3&#x27; this.msg = &#x27;4&#x27; &#125;, &#125;)&lt;/script&gt; 这里，显然 msg 更新是会导致视图重新渲染的，如果每次 msg 的值发生改变，视图都渲染一遍，那效率就太过地下了。所以理想的解决方案是：当值发生改变的时候，让这个操作入队，当队列里所有修改值得操作都完成之后，再刷新视图。 那么 vue 是如何实现这个异步更新的呢？ 这就不得不提及大名鼎鼎的事件循环了。 Even Loop总所周知，浏览器的 js 是单线程的，也就是说，在同一时刻，最多也只有一个代码段在执行，但如果仅能执行同步的代码，很多的工作是没法完成的。为了解决这个问题，引入了事件循环这个机制，那么什么是事件循环呢？ 简单来说就是当执行代码的途中，遇到需要异步执行的代码，就将其扔进队列中，等同步的代码完成之后，再去执行队列中的代码。 这里我们来看一张图： Task Queue（宏任务队列）：如 setTimeout, setInteval, xhr 等，代表⼀个个离散的、独⽴的⼯作单元。浏览器完成⼀个宏任务，在下⼀个宏任务执⾏开始前，会对⻚⾯进⾏重新渲染。 Microtask Queue（微任务队列）：如 Promise.then, mutation observe, DOM 变化 等，微小的任务，当前宏任务执行完成之后会立即清空微任务队列。如果存在微任务，浏览器会清空微任务之后再重新渲染。 这里再补上脑图： 关于事件循环，本文只要了解这么多久足够了。但事件循环本身也是一个值得深入研究的点，这里暂不深入，有兴趣的朋友建议看看下面这两篇文章： Tasks, microtasks, queues and schedules 面试一定会问到的-js 事件循环 综上，显然微任务用于异步更新是非常不错的选择：在微任务队列清空后，下一个宏任务开启之前，浏览器会渲染视图。 异步更新流程前置基础打得差不多了，那么我们开始来分析 vue 的异步更新流程。 入口很明显，当值发生改变的时候，那么自然应该找 Observer 的 set： 1234567891011121314151617181920set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify()&#125; 结合上一章的知识，能够判断出，这里是通过 dep.notify() 通知 watcher 进行视图的更新。进去看看呢： 12345678910111213notify() &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125;&#125; 这个 this.subs 显然是 dep 所管理的 watcher 队列，所以 subs[i].update() 自然是 watcher 中的 update，那么让我们再次跳转： 12345678910update() &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 这里做的事很简单： 如果不做更新，则开启 dirty 标志位。 如果设置为同步更新，则直接进行更新。（这里说明 run 就是最后执行更新的方法） 通常情况下是走最后一个条件，也就是 watcher 入队。（这里看函数名字也能看出来） 那么我们继续深入： 123456789101112131415161718192021222324252627export function queueWatcher(watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; waiting = true if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; nextTick(flushSchedulerQueue) &#125; &#125;&#125; 这里看起来比前面稍微复杂了一些，不过总的来说告诉我们以下几条信息： 如果 watcher 已经入队了，则不用再入队，防止多次渲染 如果在等待状态，则执行 nextTick(flushSchedulerQueue) 那么我们先看看 nextTick，顺带一提，这就是平时业务开发中用到的 this.$nextTick： 123456789101112131415161718192021222324export function nextTick(cb?: Function, ctx?: Object) &#123; let _resolve callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise((resolve) =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 首先将回调函数入队，而这个回调函数是 flushSchedulerQueue 执行一个时间函数：timerFunc() 那么我们先来看看这个时间函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) // In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#x27;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; else if ( !isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; (isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true, &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; // Fallback to setImmediate. // Technically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 这里看起来挺长的，不过实际上就做了几件事： 如果环境支持 Promise 则使用 Promise 否则使用 MutationObserver 再不然使用 setImmediate 实在不行才用 setTimeout 那么优先级如下： 1Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout 这里我们仅看 Promise，因为道理都是一样的，通过 p.then(flushCallbacks) 传递了 flushCallbacks，跳过去看看： 12345678function flushCallbacks() &#123; pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125; 这里的操作就是将 callbacks 遍历执行一遍，而 copies[i]() 则是前面入队的 cb，即 flushSchedulerQueue，我们去看看这又是什么东西： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function flushSchedulerQueue() &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&#x27;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&#x27;s watcher run, // its watchers can be skipped. queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( &#x27;You may have an infinite update loop &#x27; + (watcher.user ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;` : `in a component render function.`), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit(&#x27;flush&#x27;) &#125;&#125; 好像很复杂，但实际上我们只关心一行代码： 1watcher.run() 前面也提到了，run 就是实际更新视图的方法，我们进去看看： 1234567891011121314151617181920212223242526run() &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125; 按照常规思路的话，这里首先通过 get 获取最新值，然后通过 this.cb.call(this.vm, value, oldValue) 来更新视图。 但 vue 渲染阶段并不是这样的，我们先来看看这个 get 是什么吧！ 1234567891011121314151617181920212223get() &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`) &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value&#125; 显然，是通过 value = this.getter.call(vm, vm) 获取的最新值，那么继续追踪： 123if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn&#125; 那么 expOrFn 又是什么呢？ 1constructor(vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) 显然，它是 Watcher 构造函数的第二个参数，那么我们来到 lifecycle，创建 Watcher 实例的位置： 12345678910111213new Watcher( vm, updateComponent, noop, &#123; before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125;, &#125;, true /* isRenderWatcher */) 可以看到 expOrFn 就是 updateComponent，而它的实现如下： 123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 结合第一章的分析，我们知道： _render 用于渲染 _update 用于刷新视图 所以到这里，我们知道，实际上，在 run 的 get 执行之后，视图应该就已经更新了。 这里先梳理一下脑图： 调试验证其实这里的调试验证非常简单，我们将断点下在 run → this.get() 处： 紧接着单步执行： 可以看到，果然进行了视图更新，说明和我们的猜想没有问题。 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 三：异步更新策略 那么今天的分析就到此为止啦，我们下期再见，咕咕咕~","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【2】 —— 数据响应式","slug":"2020-08-17","date":"2020-08-17T09:25:47.087Z","updated":"2020-08-17T09:25:47.087Z","comments":false,"path":"2020/08/17/2020-08-17/","link":"","permalink":"http://yoursite.com/2020/08/17/2020-08-17/","excerpt":"上一章粗浅的分析了 vue 2.6.x 的初始化流程，搞清楚了以下几个问题： vue 的入口在哪里 vue 的初始化做了什么操作 在 vue 初始化过程中，哪些操作先执行，哪些操作后执行 而今天，我们将分析 vue 2.6.x 中是如何完成数据响应式操作的。 那么开始吧！","text":"上一章粗浅的分析了 vue 2.6.x 的初始化流程，搞清楚了以下几个问题： vue 的入口在哪里 vue 的初始化做了什么操作 在 vue 初始化过程中，哪些操作先执行，哪些操作后执行 而今天，我们将分析 vue 2.6.x 中是如何完成数据响应式操作的。 那么开始吧！ 处理对象相信大家都知道，vue 2.6.x 中实现数据响应式的核心方法是 Object.defineProperty，而这个方法并不能处理数组，所以 vue 对于数组和对象的处理方法是不同的，这里我们就先来分析它是如何处理对象的。 通过上一章的分析，我们知道，在初始化流程中，处理数据的方法是 initState： 123456789101112131415export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe((vm._data = &#123;&#125;), true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 上面的代码告诉我们两条信息： 优先级：props &gt; methods &gt; data &gt; computed &gt; watch 实现数据响应式的方法是 initData(vm) 12345678910111213141516171819202122232425262728293031323334function initData(vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn(`Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(`The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 从这里可以看到，最核心的方法是 observe。 那么跳过去看看： 文件位置：src/core/observer/index.js： 123456789101112131415161718192021export function observe(value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 而从这里的代码，我们能看到以下信息： 如果不是对象，则不会进行 new Observer() 操作 如果一个对象拥有 __ob__ 属性，那么它就是一个响应式的数据 实现响应式的核心操作在 new Observer() 中 所以现在跳转都 Observer 中看看： 文件位置：src/core/observer/index.js： 1234567891011121314151617constructor(value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 这里可以看到，每一个 ob 实例一定会有一个 dep 实例，而每一个数据对象会有一个 ob，所以每个对象将有一个 dep 实例，暂且我们叫它对象依赖管理器，至于它的用处，暂不深入讨论，后面再回过头来看。 前面已经提到过，数组和对象的响应式有区别，这里我们先看响应式是如何实现的： 123456walk(obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; 显然，defineReactive 就是实现数据响应式的核心方法了。 并且这个方法挂到了 Vue.util.defineReactive 上 那么我们深入到方法内部看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export function defineReactive(obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125;, &#125;)&#125; 乍一看挺复杂，实际上上面的代码总共做了三件事： 给每个 key 创建一个 dep（这个 dep 我们叫它数据依赖管理器） 如果传入的 val 是 object，则进行递归操作 通过 Object.defineProperty 实现数据响应式 那么具体是如何实现的呢？ 可以看到，在 get 的时候，进行了如下操作： 123456789if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125;&#125; 用比较专业说的说法，这一步叫做依赖收集，这里我们需要搞清楚几个问题： 什么是依赖收集？ Dep.target 是什么？ depend 做了什么？ dependArray 做了什么？ 这里一一回答： 我们都知道，vue 是一款 mvvm 的框架，实现了数据的响应式，让开发者不用再过分关注数据，视图的联系，只需要更新数据，视图会自动的更新。 假设现在有 a, b, c, d 四个变量，而视图中只用到了 a, c, d，那么 b 更改的时候，视图自然不应该刷新，要怎么判断 b 和视图有没有关系呢？这就是依赖收集需要做到的。 至于下面的问题，我们得先到 dep 中看看： 文件位置：src/core/observer/dep.js： 1234567891011121314151617181920212223242526272829303132333435363738export default class Dep &#123; static target: ?Watcher id: number subs: Array&lt;Watcher&gt; constructor() &#123; this.id = uid++ this.subs = [] &#125; addSub(sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub(sub: Watcher) &#123; remove(this.subs, sub) &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify() &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 通过类型可以看到，target 应该是一个 Wathcer，而 Wathcer，我们前面手写 vue 响应式的时候，已经介绍的很清楚了，如果有不清楚的童鞋可以看看这篇文章：手写简易 MVVM。 那么 depend 做了什么呢？ 我们来到 Watcher： 文件位置：src/core/observer/watcher.js： 12345678910addDep(dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 这里主要做了两个操作： 建立 watcher 和 dep 的关系 反向建立 dep 和 watcher 的关系 那么为什么要建立双向的关系呢？之前实现 mvvm 的时候，不是建立单向关系就可以了吗？ 这个问题我们稍后再说，现在先来看看上面的最后一个问题，dependArray 又做了什么？ 123456789function dependArray(value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125; 显然，这里是遍历数组，对其每一个元素建立和 dep 的关系。 这里为了理清思路，补上脑图： 从图中我们可以看到，这里的关键点是： Wathcer 是什么？ Dep 是什么？ 为什么要建立它们的关系？ 建立了它们的关系有什么用？ 前面已经多次提到 Dep 了，有 obj 中的 Dep，也有 key 中的 Dep，这里我们就先来看看 Dep： 1234567891011121314151617181920212223242526272829303132333435363738export default class Dep &#123; static target: ?Watcher id: number subs: Array&lt;Watcher&gt; constructor() &#123; this.id = uid++ this.subs = [] &#125; addSub(sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub(sub: Watcher) &#123; remove(this.subs, sub) &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify() &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 上面的代码告诉我们几条信息： dep 管理着一个有 Wathcer 组成的数组 在 notify 中会遍历这个数组，执行其中的 update 方法 而 update 的具体实现涉及到 vue 的异步更新，所以这里就仅把它当成是视图更新函数即可，暂不讨论其具体实现。 那么 Dep 和 Watcher 的关系是：Dep 管理 Watcher，Watcher 管理视图更新。 到这里，我们已经大致清楚 vue 的数据响应式流程了，不过还存有一些疑问： 为什么要建立 Dep 和 Watcher 的双向关系？ 对象依赖管理器（Observer 中的 Dep）是干嘛的？ 数据依赖管理器（defineReactive 中的 Dep）是干嘛的？ 现在我们可以来回答这些问题了： 为什么要建立 Dep 和 Watcher 的双向关系？总所周知，vue 是组件化的前端框架，那么自然就会存在下面这样的情况： 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Vue组件化机制&lt;/h1&gt; &lt;comp :msg=&quot;msg&quot;&gt;&lt;/comp&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;comp&#x27;, &#123; template: &#x27;&lt;div&gt;I am comp&lt;/div&gt;&#x27;, props: [&#x27;msg&#x27;], data: function() &#123; return &#123; compMsg: this.msg + &#x27;comp&#x27; &#125; &#125;, &#125;) const app = new Vue(&#123; el: &#x27;#demo&#x27;, data() &#123; return &#123; msg: &#x27;hello vue&#x27;, &#125; &#125;, &#125;) &lt;/script&gt; &lt;/body&gt; 在这样的情况下，仅有 Dep 到 Wathcer 的关系显然是不够的了，所以还需要建立 Wathcer 到 Dep 的关系。 对象依赖管理器（Observer 中的 Dep）是干嘛的？这个很好解释，当 data 中存在对象，甚至对象嵌套的时候，修改其中的值，同样需要出发视图的更新，这就是对象依赖管理器的作用。 数据依赖管理器（defineReactive 中的 Dep）是干嘛的？最直接通知 Wathcer 更新视图的地方。 补上脑图： 到这里，对象的响应式处理已经完成了，我们再来看看对于数组，是怎么操作的。 处理数组有前面的积累，可以很快定位到处理数组的方法： 12345678if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value)&#125; 我们先看看 observeArray，毕竟名字都这么直白了： 12345observeArray(items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 显然，这里就是遍历数组，对其每个元素进行响应式处理。 那么来到 protoAugment： 12345function protoAugment(target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 从调用可以看到，target 是一个数组实例，那么这里的操作就是覆盖其原型。 那么 src 是什么呢？ 1export const arrayMethods = Object.create(arrayProto) 光看这个好像并不能看出点什么，结合下面的代码再看看： 123456789101112131415161718192021222324252627const methodsToPatch = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;]/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator(...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 显然，这里通过装饰器方法对 methodsToPatch 中的七个数组方法进行了扩展。 大致分为以下几步： 先执行原来的数组方法（原有功能不变） 对于新插入的数据， 做响应式处理：if (inserted) ob.observeArray(inserted) 通知 watcher 更新视图：ob.dep.notify() 最终脑图如下： 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 二：数据响应式 那么本篇的粗浅分析到此为止，剩下的来日再议论吧！咕咕咕~ 🐥 🐥 🐥","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【1】 —— 初始化流程","slug":"2020-08-12_1","date":"2020-08-13T08:04:10.635Z","updated":"2020-08-13T08:04:10.635Z","comments":false,"path":"2020/08/13/2020-08-12_1/","link":"","permalink":"http://yoursite.com/2020/08/13/2020-08-12_1/","excerpt":"Vue 源码还是比较庞大的，如果分析源码没有条理，直接一头扎进去，很容易陷进代码海中，一通分析下来一头雾水，还打击信心。 那么应该怎么分析源码呢？ 以下是个人总结的几点经验，如有谬误之处，望指出： 首要任务是找到入口，如 Vue 则找到其构造函数 先理清主线，后分析实现，别被细枝末节的代码影响思路 那么接下来，我们就来尝试找找 Vue 的构造函数吧！","text":"Vue 源码还是比较庞大的，如果分析源码没有条理，直接一头扎进去，很容易陷进代码海中，一通分析下来一头雾水，还打击信心。 那么应该怎么分析源码呢？ 以下是个人总结的几点经验，如有谬误之处，望指出： 首要任务是找到入口，如 Vue 则找到其构造函数 先理清主线，后分析实现，别被细枝末节的代码影响思路 那么接下来，我们就来尝试找找 Vue 的构造函数吧！ 寻找构造函数对于这个问题，我们可以利用调试器，用最直接的办法定位到入口文件。 首先编写测试 demo，将断点定在 new Vue(&#123;&#125;) 处，通过 f11 进入构造函数，然后通过鼠标右键定位到目标文件： 123456function Vue(options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; 显然，这就是 Vue 的构造函数了，其文件路径为：src/core/instance/index.js 。 当然，上面的方法能够快速有效的定位到目标文件，这能提高我们的分析效率，但这里我们也可以尝试一下另一种类似解密的分析思路，从蛛丝马迹中找到答案： 首先我们来看看 pakage.json： 1&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; 从这里我们可以得到两个信息： 配置文件是 scripts/config.js 环境变量是 TARGET:web-full-dev 那么我们来到 scripts/config.js，定位到 web-full-dev： 12345678&#x27;web-full-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.js&#x27;), dest: resolve(&#x27;dist/vue.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;development&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, 从这里可以看到入口文件是 web/entry-runtime-with-compiler.js，但这个 web 是哪个目录呢？在 vscode 中利用 ctrl + 鼠标左键 可以来到 resolve 函数的定义处： 123456789const resolve = (p) =&gt; &#123; // web/... const base = p.split(&#x27;/&#x27;)[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, &#x27;../&#x27;, p) &#125;&#125; 这里 resolve 方法的返回是 aliases[base] + path，那么我们来看看 aliases 是什么： 12345678910module.exports = &#123; vue: resolve(&#x27;src/platforms/web/entry-runtime-with-compiler&#x27;), compiler: resolve(&#x27;src/compiler&#x27;), core: resolve(&#x27;src/core&#x27;), shared: resolve(&#x27;src/shared&#x27;), web: resolve(&#x27;src/platforms/web&#x27;), weex: resolve(&#x27;src/platforms/weex&#x27;), server: resolve(&#x27;src/server&#x27;), sfc: resolve(&#x27;src/sfc&#x27;),&#125; 到这里，结果就出来了，入口文件是：src/platforms/web/entry-runtime-with-compiler.js，来到让我们来到这个文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const mount = Vue.prototype.$mountVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`) return this &#125; const options = this.$options if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn(`Template element not found or is empty: $&#123;options.template&#125;`, this) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments, &#125;, this ) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 这个文件最主要的功能是扩展了 web 平台需要的 $mount，这也说明基本的 $mount 是不满足 web 平台的需求的。 在这个函数中，能看到以下比较重要的逻辑： 如果存在 render 函数，则不再关注 template 和 el 当不存在 render 函数，则优先关注 template 当同时不存在 render 和 template，则最终选择 el，并且通过 getOuterHTML 将其转化为 template 处理完上面的逻辑之后将 template 通过 compileToFunctions 编译成 render 函数 最后调用 mount 将内容挂载到 root 节点上 优先级：render &gt; template &gt; el 这里我们可以看到 Vue 是外部引入的，位置如下： 1import Vue from &#x27;./runtime/index&#x27; 随机来到目标文件 src/platforms/webs/runtime/index.js： 123456Vue.prototype.__patch__ = inBrowser ? patch : noopVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 可以看到这个文件主要做了一些对 vue 扩展的事情，最为关键的两点则是上面代码中的部分： 安装了平台特有的 __patch__ 函数，它的功能是将虚拟 dom 转化成真实 dom，而 diff 也将在这里发生 实现了 $mount，不过这里也只是对 mountComponent 的一层封装，并没有触及真正的功能代码 接下来我们继续顺着引入 Vue 的线索推进： 1import Vue from &#x27;core/index&#x27; 于是来到文件 src/core/index： 1initGlobalAPI(Vue) 文件的核心功能就是初始化全局的 API，于是离开这里，继续深入： 1import Vue from &#x27;./instance/index&#x27; 终于来到了 Vue 的构造函数，代码在最上面已经贴出，这里就不再贴了。 脑图如下： 初始化流程分析要分析 Vue 初始化流程，我们先来看看构造函数文件吧： 123456789101112131415161718192021import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue(options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到，在构造函数中执行了一个 this._init() 方法进行初始化，那么这个方法从何而来呢？ 我们往下，发现 initMixin(Vue) 这个方法，顾名思义，这应该是为 Vue 扩展 init 的方法，于是跳转进去看看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function initMixin(Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;) initInjections(vm) initState(vm) initProvide(vm) callHook(vm, &#x27;created&#x27;) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 果然，_init() 是在这里扩展的，它做了些什么呢？ 仔细阅读后可以知道，它的核心功能有两点： 进行各种初始化操作 如果设置了 el，则自动调用 $mount 进行挂载 继续深入，来看看具体执行了哪些初始化操作： 12345678initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, &#x27;beforeCreate&#x27;)initInjections(vm)initState(vm)initProvide(vm)callHook(vm, &#x27;created&#x27;) 我们逐一分析： initLifecycle(vm)文件位置：src/core/instance/lifecycle.js 12345678910111213141516171819202122232425export function initLifecycle(vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 这里主要初始化了以下关系： $root $parent $children $refs initEvents(vm)文件位置：src/core/instance/events.js 123456789export function initEvents(vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 这里初始化了事件的监听者。 initRender(vm)文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function initRender(vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = (vm.$vnode = options._parentVnode) // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive( vm, &#x27;$attrs&#x27;, (parentData &amp;&amp; parentData.attrs) || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true ) defineReactive( vm, &#x27;$listeners&#x27;, options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true ) &#125; else &#123; defineReactive(vm, &#x27;$attrs&#x27;, (parentData &amp;&amp; parentData.attrs) || emptyObject, null, true) defineReactive(vm, &#x27;$listeners&#x27;, options._parentListeners || emptyObject, null, true) &#125;&#125; 这里主要初始化了两个方法： $slots $createElement callHook(vm, ‘beforeCreate’)一直到这里，都处于 Vue 生命周期中的 beforeCreate，而上面的代码中完全没有对 data 的处理，所以在 beforeCreate 中显然是无法获取到 data 的。 initInjections(vm)文件位置：src/core/instance/inject.js 12345678910111213141516171819202122export function initInjections(vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach((key) =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: &quot;$&#123;key&#125;&quot;`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 这里注入了祖辈中的数据，以便在后面接收。 initState(vm)文件位置：src/core/instance/state.js 123456789101112131415export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe((vm._data = &#123;&#125;), true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到，这里初始化了我们熟知的对象： props methods data computed watch 从流程也可以看到，data 是晚于 props，先于 computed 的，这也能解决平时很多困扰我们的问题。 initProvide(vm)文件位置：src/core/instance/inject.js 123456export function initProvide(vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125; 这里对前面注入的数据进行了接收。 callHook(vm, ‘created’)这里调用生命钩子，说明到 created 阶段，组件已经成功创建，所以初始化工作已经完成。 下面贴上脑图，方便大家参考： 接下来我们回到构造函数，看看剩下的 Mixin 都做了些什么： 12345initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) initMixin() 上面刚分析完，同样的，我们一步一步来看看下面的 Mixin 都做了些什么吧！ stateMixin(Vue)文件位置：src/core/instance/state.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function stateMixin(Vue: Class&lt;Component&gt;) &#123; // flow somehow has problems with directly declared definition object // when using Object.defineProperty, so we have to procedurally build up // the object here. const dataDef = &#123;&#125; dataDef.get = function () &#123; return this._data &#125; const propsDef = &#123;&#125; propsDef.get = function () &#123; return this._props &#125; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; dataDef.set = function () &#123; warn(&#x27;Avoid replacing instance root $data. &#x27; + &#x27;Use nested data properties instead.&#x27;, this) &#125; propsDef.set = function () &#123; warn(`$props is readonly.`, this) &#125; &#125; Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef) Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef) Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function (expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value) &#125; catch (error) &#123; handleError(error, vm, `callback for immediate watcher &quot;$&#123;watcher.expression&#125;&quot;`) &#125; &#125; return function unwatchFn() &#123; watcher.teardown() &#125; &#125;&#125; 其实顾名思义，已经能大致猜到这里的功能了（ps：这也是一个好的命名规范带来的好处）。不过这里还是结合代码分析，这里扩展了以下功能： $data $props $set $delete $watch eventsMixin(Vue)文件位置：src/core/instance/events.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export function eventsMixin(Vue: Class&lt;Component&gt;) &#123; const hookRE = /^hook:/ Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; ;(vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm &#125; Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on() &#123; vm.$off(event, on) fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm &#125; Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // all if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // array of events if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$off(event[i], fn) &#125; return vm &#125; // specific event const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null return vm &#125; // specific handler let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; return vm &#125; Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event &quot;$&#123;lowerCaseEvent&#125;&quot; is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for &quot;$&#123;event&#125;&quot;. ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use &quot;$&#123;hyphenate(event)&#125;&quot; instead of &quot;$&#123;event&#125;&quot;.` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) const info = `event handler for &quot;$&#123;event&#125;&quot;` for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; invokeWithErrorHandling(cbs[i], vm, args, vm, info) &#125; &#125; return vm &#125;&#125; 这里是扩展事件相关的方法： $on $once - 这个方法在平时业务开发中非常少用 $off $emit lifecycleMixin(Vue)文件位置：src/core/instance/lifecycle.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182export function lifecycleMixin(Vue: Class&lt;Component&gt;) &#123; Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook. &#125; Vue.prototype.$forceUpdate = function () &#123; const vm: Component = this if (vm._watcher) &#123; vm._watcher.update() &#125; &#125; Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125; 这里扩展了生命周期相关的方法： _update：这是核心的更新函数 $forceUpdate $destroy renderMixin(Vue)文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export function renderMixin(Vue: Class&lt;Component&gt;) &#123; // install runtime convenience helpers installRenderHelpers(Vue.prototype) Vue.prototype.$nextTick = function (fn: Function) &#123; return nextTick(fn, this) &#125; Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode &#125;&#125; 这里是扩展了渲染相关的方法： $nextTick：这个方法非常有意思，后面将深入分析 _render 老规矩，上脑图： 如果写一个测试 demo 调试，会发现，当上面的流程都执行完成之后，页面中还没有渲染出对应的内容，这是因为还没有执行 vue 初始化最重要的一步：挂载。接下来就来看看 vue 中是如何进行挂载的。 相信大家对前面提到的流程熟悉的话，对 mount 应该有一定的印象：打包入口文件中最重要的功能就是扩展 mount。 挂载通过基本分析，我们可以找到实现 mount 的位置：src/platforms/web/runtime/index.js ： 1234Vue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 可以看到，是 mountComponent 这个方法实现了 mount 的核心功能，让我们追进去看看。 文件位置：core/instance/lifecycle.js ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export function mountComponent(vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ) &#125; else &#123; warn(&#x27;Failed to mount component: template or render function not defined.&#x27;, vm) &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;) let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher( vm, updateComponent, noop, &#123; before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125;, &#125;, true /* isRenderWatcher */ ) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;) &#125; return vm&#125; 上面的流程并不复杂： 首先调用了 beforeMount 钩子 随后调用了 updateComponent 进行组件的更新 然后创建了一个 Wathcer，并在其中调用了 beforeUpdate 钩子 最后调用 mounted 钩子 从流程可以看出，挂载的核心功能应该是在 updateComponent 进行的，而它的核心功能就是先执行 _render()，后执行 _update()。 而这两个方法，我们进入看看： _render()文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 这里经过一系列的处理，主要是为了得到虚拟 dom _update()文件位置：src/core/instance/lifecycle.js 123456789101112131415161718192021222324252627282930Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; 这里最核心的功能是 __patch__，即将虚拟 dom 转化为真实 dom。 脑图如下： 调试验证前面一通分析，挺有道理，但只是理论如此，不稳，这里我们通过调试器一步步执行，来验证一下我们的想法是否正确： Step 1 - 确定初始化函数测试 demo 就不贴出来了，随便一个 vue 样例都行，我们从 new Vue() 处进入即可： 显然，这里只会执行 _init，也即是说这就是初始化函数，也验证了上面的猜想。 Step 2 - 验证执行流程前面猜测执行 initState(Vue) 之前是无法访问到 data 数据的，这个也很好验证，我们先看看执行之前的 vm： 可以看到，这个时候 data 和 props 都还无法访问，接下来单步执行 initState(Vue)，再看看结果： 显然，这个时候 data 已经有值了，而 props 之所以还是 undefined，是因为这里本就没有父组件进行传值。 Step 3 - 验证挂载同样，我们现在将断点定在 updateComponent 即可，执行 _update 之前： 执行 _update 之后： 上面的结果与我们分析 vue 源码得来的结论无异，这能很好的提升士气和信心，为接下来的源码学习之旅打下不错的基础。 那么本篇的粗浅分析到此为止，剩下的来日再议论吧！ 咕咕咕~ 🐥 🐥 🐥 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 一：初始化流程","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【0】 —— 调试环境搭建","slug":"2020-08-12","date":"2020-08-12T08:49:54.841Z","updated":"2020-08-12T08:49:54.841Z","comments":false,"path":"2020/08/12/2020-08-12/","link":"","permalink":"http://yoursite.com/2020/08/12/2020-08-12/","excerpt":"以前很多 vue 原理相关的知识，比如响应式，比如虚拟 dom，比如 diff 算法……但都没有真正深入的看过源码，正因为此，这些知识宛如空中楼阁，空洞且并没有什么说服力。所以今天开始对 vue 进行粗浅的源码分析。 要分析源码，自然首先要搭建调试环境，这样才可以通过编写测试 demo 快速定位到我们想要分析的位置。 那么开始吧！","text":"以前很多 vue 原理相关的知识，比如响应式，比如虚拟 dom，比如 diff 算法……但都没有真正深入的看过源码，正因为此，这些知识宛如空中楼阁，空洞且并没有什么说服力。所以今天开始对 vue 进行粗浅的源码分析。 要分析源码，自然首先要搭建调试环境，这样才可以通过编写测试 demo 快速定位到我们想要分析的位置。 那么开始吧！ Step 1 - 克隆源码1git clone git@github.com:vuejs/vue.git Step 2 - 安装环境12npm install // 安装到 phantom 时就可以终止了npm install rollup -g Step 3 - 修改运行参数文件：root/pakage.json 12- &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;+ &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; Step 4 - 编译源码1npm run dev Step 5 - 测试调试流程到这里，如果在 root/dist 目录下新生成了一个 vue.js.map 文件，则说明应该已经成功建立了 map 映射关系，这里在 root/examples/test-demo 下建立一个测试文件： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; name: &#x27;vue&#x27; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开这个页面，在浏览器中进行调试，将断点定在创建实例的这一行： 成功断下来之后，按 f11 进入函数，然后在点击鼠标右键，选择：Reveal in sidebar，如果左侧侧边栏中出现 vue 的目录结构，则说明调试环境已经搭建成功： 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 零：调试环境搭建","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【3】 —— mvvm","slug":"2020-08-10","date":"2020-08-11T02:17:56.653Z","updated":"2020-08-11T02:17:56.653Z","comments":false,"path":"2020/08/11/2020-08-10/","link":"","permalink":"http://yoursite.com/2020/08/11/2020-08-10/","excerpt":"今天我们来研究一下 vue2 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》","text":"今天我们来研究一下 vue2 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》 思路整理首先来看看官网给出的示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这个例子很好的展示了 mvvm 的核心功能： 数据驱动视图更新 再结合代码看看，我们发现这里的定义并不复杂，仅仅是： el：指定跟节点 data：定义响应式数据 插值表达式：渲染变量 v-xxx：vue 指令 从上面我们能得到什么信息呢？ 显然，我们要对节点进行解析，解析其中的插值表达式和 v-xxx 指令，这个功能我们可以叫它 Compiler。然后我们还需要对 data 中的数据进行劫持，当其中的数据发生 get/set 的时候，能够进行自定义的操作，这个功能我们叫它 Observer。最后我们需要监听这些数据，当他们发生改变的时候，通知视图去进行更新操作，这个功能我们叫它 Watcher。 这里引用一下大佬的图： 可以看到，除了上面我们提到的三个模块以外，这里还多了 Updater 和 Dep，Updater 倒还好理解，但这 Dep 是干嘛的呢？ 我们知道，data 和 view 中的显示存在多对多的关系，如下： 123456789101112131415;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;1: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;2: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;3: &#123;&#123; data_2 &#125;&#125;&lt;/p&gt; &lt;p&gt;4: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt; &lt;p&gt;5: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; data_1: 1, data_2: 2, data_3: 3, &#125;,&#125;) 上面的代码中： 当 data_1 发生改变的时候，p1 和 p2 都要重新渲染 当 data_2 发生改变的时候，p3 要重新渲染 当 data_3 发生改变的时候，p4 和 p5 都要重新渲染 显然这需要被控制管理起来，否则视图的更新肯定是一团乱，而 Dep 就是用来做这个的，我们可以看看下面这张图： 从上图可以看到： view 中每一个需要被渲染的值对应一个 Watcher 每一个响应式变量对应一个 Dep 那么更新流程就应该是这样：当是数据更新的时候，Observer 通知对应的 Dep，然后 Dep 通知自己管理的 Watcher 调用 Updater 进行视图的更新。 当然，最后我们需要一个入口作为桥梁，将上面的各个模块给联系起来，组合成一个完整的 mvvm 框架。 大致的思路已经有了，那么开始吧，it’s show time！ 功能实现Entry首先再来看看官方示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这里 new 了一个 Vue，并且只传了一个 obj 进去，那么我们最终对外暴露的对象也应当如此。 总所周知，vue 是法语视图的意思，那么这里就用它的好朋友来作为命名语言吧 123456789export default Aus &#123; constructor(options = &#123;&#125;)&#123; this.$options = options; this.$el = options.el; this.$data = options.data; if (!this.$el) throw new Error(&quot;请指定挂载点&quot;); &#125;&#125; 接下来我们就来实现模板的解析。 Compiler我们来分析一下 Compiler 需要做什么： 通过 el 获取需要被编译的 root 节点 进行模板编译 将编译后的节点覆盖到 root 节点的位置 而模板编译应该怎么进行呢？ 首先我们可以将节点碎片化，在内存中处理 遍历当前的节点树，这里我们只关注两类节点： 元素节点：处理 a-xxx 指令 文本节点：处理插值表达式 将编译好的节点碎片 append 到 root 节点上 那么我们的问题就来到了如何处理文本和元素节点： 元素节点：node.attributes 文本节点：正则表达式 进过上面一通分析，整个结构已经比较清晰了，这里再补上脑图： 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;单层：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p a-text=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; import Aus from &#x27;./aus.js&#x27; const am = new Aus(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello Aussicht!&#x27;, &#125; &#125;)&lt;/script&gt; 效果如下： 可以看到，这里已经成功将 a-text 和插值表达式替换成了我们想要渲染的变量了。 接下来我们想要实现的效果是当数据发生改变的时候，视图也随之更新，那么首先应该实现的是 Observer。 Observer同样的，我们来分析一下 Observer 需要做什么。 事实上，仅仅考虑数据劫持这一层面的话，Observer 需要实现的功能非常简单，就是利用 Object.defineProperty 对 data 进行代理即可。 流程很简单： 获取 data 的所有 key，对其进行劫持 如果 data 的 key 为 obj，则递归 脑图如下： 本文主要是简单探讨一下 mvvm 实现原理，这里对于数组就不做处理了。 代码很简单，按照上面的思路进行实现即可： 12345678910111213141516171819202122232425262728293031323334353637import Dep from &#x27;./dep.js&#x27;class Observer &#123; constructor(data) &#123; this.data = data this.observe(this.data) &#125; observe(data) &#123; if (data &amp;&amp; typeof data === &#x27;object&#x27;) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]) &#125;) &#125; &#125; defineReactive(obj, key, value) &#123; this.observe(value) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get: (_) =&gt; &#123; return value &#125;, set: (newVal) =&gt; &#123; // 对新设置的值进行监听 this.observe(newVal) if (newVal !== value) &#123; value = newVal &#125; return true &#125;, &#125;) &#125;&#125;export default Observer 接下来就是最关键的，当数据发生改变的时候，通知视图进行更新渲染了。 Watcher &amp;&amp; Dep这里我们一步步分析一下： Watcher 一一对应模板中的变量（插值表达式 or a-text） Dep 对应具体变量 Observer 能发出通知 只有当变量发生改变的时候，模板中对应的地方需要发生重新渲染，所以流程应该是： Observer 通知 Dep，变量发生改变 Dep 管理了一个 Watcher 数组，执行 Watcher 的 update 方法，更新视图 那么现在的问题是，怎么建立 Dep 和 Watcher 的关系。 显然，模板中每有一个需要渲染的值，就应该有一个对应的 Watcher，而这个值在初始化的时候会进行 get 操作，那么自然是在 get 中进行操作最合适： 同样，在修改值得之后会进行 set 操作，那么在 set 的时候利用 dep 通知 Watcher 进行操作也最合适。 综上： Dep 至少需要管理一个 Watcher 数组，一个添加 Watcher 的方法，一个通知 Watcher 更新视图的方法 Watcher 在初始化的时候创建，管理 Update 方法 脑图如下： 那么这里，首先我们需要改造一下 Compiler，在渲染模板的时候创建 Watcher： 123456789101112131415161718192021222324const compileUtil = &#123; text(node, exp, am) &#123; const value = this.getValue(exp, am) const updaterFn = (node, value) =&gt; &#123; node.textContent = value &#125; updaterFn &amp;&amp; updaterFn(node, value) new Watcher() &#125;, getValue(exp, am) &#123; return exp.split(&#x27;.&#x27;).reduce((d, c) =&gt; d[c], am.$data) &#125;, setValue(exp, am, value) &#123; exp.split(&#x27;.&#x27;).forEach((k, i) =&gt; &#123; if (i &lt; exp.length - 1) &#123; am = am[k] &#125; else &#123; am[k] = value &#125; &#125;) &#125;,&#125; 因为我们后期不可能只处理 a-text 指令，所以这里可以对工具方法进行一些封装优化： 12345678910111213141516171819202122232425262728293031323334const compileUtil = &#123; text(node, exp, am) &#123; this.bind(node, exp, am, &#x27;text&#x27;) &#125;, bind(node, exp, am, dir) &#123; const value = this.getValue(exp, am) const updaterFn = updaterUtil[dir] updaterFn &amp;&amp; updaterFn(node, value) new Watcher() &#125;, getValue(exp, am) &#123; return exp.split(&#x27;.&#x27;).reduce((d, c) =&gt; d[c], am.$data) &#125;, setValue(exp, am, value) &#123; exp.split(&#x27;.&#x27;).forEach((k, i) =&gt; &#123; if (i &lt; exp.length - 1) &#123; am = am[k] &#125; else &#123; am[k] = value &#125; &#125;) &#125;,&#125;const updaterUtil = &#123; text(node, value) &#123; node.textContent = value &#125;,&#125;export default compileUtil 因为这里我们通过 getValue 获取了 data 中的值，所以必然会触发 get 操作，那么就来到了 Observer 中。 前面我们一直反复提到，一个变量对应一个 Dep，所以这里我们在 defineReactive 中创建 dep 实例，在 get 中调用 dep 的 addWatcher 方法： 123456789101112131415class Observer &#123; /*...*/ defineReactive(obj, key, value) &#123; /*...*/ const dep = new Dep() Object.defineProperty(obj, key, &#123; get: (_) =&gt; &#123; dep.addWatcher(Watcher) return value &#125;, /*...*/ &#125;) &#125;&#125; 同样的，在 set 中调用 dep 的 notify 方法： 12345678910111213141516171819class Observer &#123; /*...*/ defineReactive(obj, key, value) &#123; /*...*/ const dep = new Dep() Object.defineProperty(obj, key, &#123; /*...*/ set: (newVal) =&gt; &#123; // 对新设置的值进行监听 this.observe(newVal) if (newVal !== value) &#123; value = newVal dep.notify() &#125; &#125;, &#125;) &#125;&#125; 上面的代码中还存在一个问题，在 get 中有一行代码： 1dep.addWatcher(Watcher) 这个 Watcher 从哪里来呢？ 那么我们来到 Watcher。 Watcher 需要什么呢？这个我们知道它的功能就很清楚了： 它需要获取当前的 data 值，所以需要 am 实例，以及值对应的 key 它需要更新视图，所以需要 update 回调函数 那么构造函数如下： 12345678class Watcher &#123; constructor(am, exp, cb) &#123; this.am = am this.exp = exp this.cb = cb this.oldValue = this.getOldValue() &#125;&#125; 而在执行 getOldValue 的时候，我们可以做一些灵活的小操作： 因为 getOldValue 必定触发 get，所以我们可以在 get 之前将 Watcher 挂载到 Dep 上，在 get 之后清空即可，这样就可以在 get 中获取到 Watcher 了。 123456789class Watcher &#123; /*...*/ getOldVal() &#123; Dep.target = this const oldVal = compileUtil.getValue(this.exp, this.am) Dep.target = null return oldVal &#125;&#125; Watcher 的功能是在 value 变化的时候进行视图更新，自然还需要一个 updater 方法，而这个方法只需要在 oldValue ≠ newValue 的时候调用回调函数更新视图即可： 123456789class Watcher &#123; /*...*/ updater() &#123; const newValue = compileUtil.getValue(this.exp, this.am) if (this.oldValue !== newValue) &#123; this.cb(newVal) &#125; &#125;&#125; 那么创建 Watcher 的时候，参数也很好填了： 123456789101112const compileUtil = &#123; /*...*/ bind(node, exp, am, dir) &#123; /*...*/ const value = this.getValue(exp, am) const updaterFn = updaterUtil[dir] updaterFn &amp;&amp; updaterFn(node, value) new Watcher(am, exp, (value) =&gt; &#123; updaterFn &amp;&amp; updaterFn(node, value) &#125;) &#125;,&#125; Watcher 搞定了，那么管理 Watcher 的 Dep 就很简单了： 12345678910111213class Dep &#123; constructor() &#123; this.watchers = [] &#125; addWatcher(w) &#123; this.watchers.push(w) &#125; notify() &#123; this.watchers.forEach((w) =&gt; &#123; w.updater() &#125;) &#125;&#125; 再修改一下 Observer 中的 get，这样整个流程就都通了： 1234get: (_) =&gt; &#123; Dep.target &amp;&amp; dep.addWatcher(Dep.target) return value&#125; 效果如下所示： 结语更加阅读体验：手写简易 MVVM","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【2】 —— vuex","slug":"2020-08-07_3","date":"2020-08-10T08:14:02.776Z","updated":"2020-08-10T08:14:02.776Z","comments":false,"path":"2020/08/10/2020-08-07_3/","link":"","permalink":"http://yoursite.com/2020/08/10/2020-08-07_3/","excerpt":"今天我们来研究一下 vuex 的内部实现原理。我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程","text":"今天我们来研究一下 vuex 的内部实现原理。我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程 Step 1 - 需求分析首先用 vue-cli 4.x 创建一个空项目，选择使用 vuex，等项目创建好之后，在 src 目录下应该存在一个 store 文件，其内容大致如下： 12345678910111213141516171819202122import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;, actions: &#123; add(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&#x27;add&#x27;) &#125;, 1000) &#125;, &#125;,&#125;) 使用过状态管理库的同学应该很清楚 action 主要用于处理异步操作，那么这里我们暂时先不关心它，把同步操作处理完之后再来看它就会清晰很多了： 123456789101112131415import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;,&#125;) 从上述代码，我们可以分析出以下几点： 首先 vuex 是 vue 的插件，首先会 use，在这个时候调用其 install 方法 通过 new 新建实例的是 vuex 上的 store 对象而非 vuex 本身 导出的 store 会在 main 中传给 vue（这一部分在 main 中，而不在上述代码中） 那么我们的 vuex 应该如何设计呢？ 我认为应该结合 vuex 的使用来进行分析： 我们知道，在项目中使用 vuex 的时候，通常形如： 123this.$store.state.xxxthis.$store.commit(&#x27;xxx&#x27;)// this.$store.dispatch(&#x27;xxx&#x27;) 异步，暂不考虑 显然，首先我们需要把 store 挂载到 vue 实例上，其次，store 上还应该有 state 和 commit，它们两分别是一个 object 和一个 function。 此时的思维导图如下所示： Step 2 - 功能实现基础功能那么我们按照这样的方式构建 vuex： 123456789101112131415161718// export default Vuexexport default &#123; install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125;, &#125;) &#125;, Store: class Store &#123; constructor() &#123; this.state = &#123;&#125; &#125; commit() &#123;&#125; &#125;,&#125; 接下来我们再回到 store 中，可以看到在创建 store 实例的时候，我们传递了两个对象： state：用于存储状态 mutations：用于同步修改状态 也就是说，在构建实例的过程中，我们将 state 存储到 $store.state 中，将 mutations 存储起来，在 commit 的时取出调用，思维导图如下： 那么我们对应实现的代码应该是： 12345678910111213export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this.state = options.state &#125; commit(type, payload) &#123; const mutation = this._mutations[type] return mutation(this.state, payload) &#125; &#125;,&#125; 这个时候，已经能从 this.$store.state 中取出 counter 了： 并且 commit 也能成功调用了： 但这里还有问题，最关键的就是 counter 的改变并没有引起页面的重新渲染。显然我们应该将 state 改成响应式数据，在 手写简易 vue-router 中我们使用了 vue 官方提供的静态方法：Vue.util.defineReactive 那么这里我们就尝试使用另一个办法来实现响应式数据：创建 vue 实例，利用其中的 data 方法将 state 转化为响应式数据，实际代码如下： 123456789101112131415161718192021222324export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this._vm = new _Vue(&#123; data() &#123; return &#123; // 由于不希望数据被代理，所以这里加上 $ $$state: options.state, &#125; &#125;, &#125;) &#125; get state() &#123; return this._vm._data.$$state &#125; set state(value) &#123; // 不允许直接修改 state console.error(&#x27;please use replaceState to reset state&#x27;) &#125; /*...*/ &#125;,&#125; 现在我们再看看效果如何： 至此，一个最最基础的 store 已经基本实现了，接下来自然是异步操作的 action 了。 异步操作其实明白了 mutations，actions 也已经清楚了大半，唯一的区别就是 action 中我们需要调用 commit 来修改 state，那么这个 commit 从哪里来自然就很清楚了：this 导图如下： 实现代码如下： 1234567891011121314export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._actions = options.actions &#125; /*...*/ dispatch(type, payload) &#123; const action = this._actions[type] return action(this, payload) &#125; &#125;,&#125; nice，非常完美，我们来看看效果： 报错了？ 这是为什么呢？ 于是跟踪调试一番，发现如下情况： this 没了，再看看 action： 显然，这里因为是在 setTimeout 中调用 commit，丢失了 this，所以我们在构建实例的时候进行绑定就可以啦。 这下就没有问题了。 扩展 - gettter我们已经实现了基础的 vuex，而平时使用 vuex 的时候，大家知道 getter 也是经常被使用到的。 那么这个 getter 应当如何实现呢？ 我们假设在创建 vuex 的时候传入 getter，里面只有一个值，是 doubleCounter，返回值是 counter * 2，那么自然 doubleCounter 是被 counter 所影响，我们这里可以画出如下导图： 那么问题来了：怎么将 getter 和 state 关联起来呢？ 仔细想一想，显然这里是做代理，那么答案就呼之欲出了：Object.defineProperty。有了这个核心思想之后，我们继续分析，由于 getter 不止一个，那么我们肯定需要遍历传入的 getter obj，将其注册到 store 上。 我们可以先来实现这一步操作： 1234567891011121314151617181920212223export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._getters = options.getters this.= Object.create(null) this.forEachGetter(this, this._getters) &#125; /*...*/ forEachGetter(store, getters) &#123; Object.keys(getters).forEach((key) =&gt; &#123; const getter = getters[key] this.registerGetter(store, getter, key) &#125; &#125; registerGetter(store, getter, key)&#123; store._wrappedGetters[key] = function wrappedGetter(store)&#123; return getter(store.state) &#125; &#125; &#125;,&#125; 执行完这一步之后，我们可以调试看看： 可以看到，store 上的属性 _wrappedGetters 中现在包含两个属性： doubleCounter：这是一个函数，即 registerGetter 中返回的 wrappedGetter，当我们调用它的时候，会返回 getter(store.state) 执行的结果，及 state.counter * 2 state：这里是响应式数据（不过现在还不是响应式的） 现在已经建立好了 options.getter 和 store._wrappedGetters 的映射关系，我们可以开始通过 Object.defineProperty 来做代理了： 123456789101112131415161718192021222324252627282930export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this.resetStoreVm(this, options.state) &#125; /*...*/ resetStoreVm(store, state) &#123; store.getters = &#123;&#125; const computed = &#123;&#125; const wrappedGetters = store._wrappedGetters Object.keys(wrappedGetters).forEach((key) =&gt; &#123; computed[key] = this.partial(wrappedGetters[key], store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], &#125;) &#125;) this._vm = new _Vue(&#123; data() &#123; return &#123; $$state: state, &#125; &#125;, // ! 计算属性，用于实现 getter computed: computed, &#125;) &#125; partial = (fn, arg) =&gt; () =&gt; fn(arg)&#125; 上面的代码，比较有容易搞不清楚的就两个地方： wrappedGetters[key] 是什么 partial 返回值是什么 这个问题直接在调试器里看看就清楚了： 显然，这两位，一个是 getter 的包裹函数，一个是其本身。 到这里，getter 也算是基本实现了，具体效果如下： 结语更佳阅读体验：手写简易 vuex","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【1】 —— vue-router","slug":"2020-08-07_2","date":"2020-08-10T08:13:19.038Z","updated":"2020-08-10T08:13:19.038Z","comments":false,"path":"2020/08/10/2020-08-07_2/","link":"","permalink":"http://yoursite.com/2020/08/10/2020-08-07_2/","excerpt":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。","text":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。 Step 1 - 需求分析首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。 项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下： 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import VueRouter from &#x27;./yvue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;Vue.use(VueRouter)const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;), &#125;,]const router = new VueRouter(&#123; routes,&#125;)export default router 我们逐步来分析一下上面的代码： 首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 VueRouter 是 Vue 的插件，需要有自己的静态 install 方法 接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系 然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出 最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身 上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？ 首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？ 联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件： router-view：用于显示组件 router-link：用于路由跳转 显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。 接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。 以上，我们可以大致总结一下，如下图所示： Step 2 - 功能实现那么现在我们可以着手开始实现自己的 vue-router 了。 首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化： 1234567class VueRouter &#123; // 对应 Vue.use static install(Vue) &#123;&#125; // 对应 new constructor(options) &#123;&#125;&#125; 紧接着我们就可以在 install 中实现对两个全局组件的注册： 123456789101112131415161718192021222324252627282930313233343536373839404142class VueRouter &#123; // 对应 Vue.use static install(Vue)&#123; // step 1: 注册组件 router-link，用于路由跳转 // 回忆一下 router-link 的使用： // * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt; Vue.component(&#x27;router-link&#x27;, &#123; // 必要参数 to props: &#123; to: &#123; type: String, require: true, &#125;, &#125;, // 模板，可以使用 template，也可以使用 render。 // * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。 render() &#123; // 这里可以写 jsx，也可以使用 h 函数 // 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下 // * h 函数类似于 react 中的 createElement return &lt;a href=&#123;`#$&#123;this.to&#125;`&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125; // step 2: 注册组件 router-view，用于显示组件 // 回忆一下 router-link 的使用： // &lt;router-view /&gt; Vue.component(&#x27;router-view&#x27;, &#123; // 没有参数，直接 template render(h) &#123; // 这里使用 h // view-router 的功能是渲染组件，那么组件从哪里获取呢？ // 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取 // 而当前路由我们可以在构造函数中定义一个 current 来表示 // 所以可以通过以下代码找到当前 current 对应的组件 const &#123; routeMap, current &#125; = this.$router const component = routeMap[current] ? routeMap[current].component : null return h(component) &#125;, &#125;) &#125; /*...*/&#125; 到这里，至少我们的 已经是可用的了，而 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。 那么接下来自然是实现 constructor 12345678910111213141516171819202122class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const current = window.location.hash.slice(1) || &#x27;/&#x27; // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件： 那应该怎么办呢？ 接下来的问题是：怎么将 current 转成 vue 响应式数据？ 对于上述问题，这里有两个思路： 新建 vue 实例，通过 data 将 current 转成响应式数据 利用 vue 提供的静态方法 Vue.util.defineReactive 这里我们采取第二种方案： 1234567891011121314151617181920212223class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里又出现一个问题，这个 Vue 从哪里来呢？ 其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了： 12345678910111213141516171819202122232425let _Vueclass VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，基本的路由已经实现了： 还有一些可以扩展的地方： 比如优化一下 constructor，将 options 保存到本地： 123456789101112131415constructor(options)&#123; this.$options = options // 初始化路由表 this.routerMap = &#123;&#125; this.$options.routes.map((route)=&gt;&#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this))&#125; 这可以保证数据的单向流动。 比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。 不过这里有一个点值得注意，那就是时间： 因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过： 1Vue.prototype.$router = this.$options.router 进行挂载显然是不行的。 这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作： 1234567Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router &#125; &#125;,&#125;) 这样就没什么问题了。 结语更佳阅读体验：手写简易 vue-router","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【2】 —— 网站配置","slug":"2020-08-07_1","date":"2020-08-07T03:29:03.057Z","updated":"2020-08-07T03:10:32.504Z","comments":false,"path":"2020/08/07/2020-08-07_1/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_1/","excerpt":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。","text":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。 站点配置目标文件：root/ _config.yml 1234title: 世界的侧面subtitle: &#x27;&#x27;author: 初心Yearthfavicon: https://s1.ax1x.com/2020/08/06/agXE9K.png 主题配置目标文件：root/themes/volantis/_config.yml 封面配置12345cover: M title: &#x27;标题&#x27; M # subtitle: &#x27;&#x27; M search: 你想看点什么呢？ M # features: // 这个选项是搜索框下的导航按钮，这里选择注释掉 导航栏配置12345678910111213141516171819202122232425navbar: logo: img: icon: title: &#x27;标题&#x27; menu: M # - name: 博客 M # icon: fas fa-rss M # url: / - name: 分类 icon: fas fa-tags url: tags/ - name: 标签 icon: fas fa-tags url: tags/ M # - name: 归档 M # icon: fas fa-archive M # url: archives/ M # - name: 友链 M # icon: fas fa-link M # url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: 你想看点什么呢？ 布局配置123layout:on_page:M body: [article] 插件配置123456plugins:backstretch:M position: fixedaplayer:M id: 170672512M autoplay: true 最终效果","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【1】 —— 基础搭建","slug":"2020-08-06","date":"2020-08-07T03:10:56.541Z","updated":"2020-08-07T03:10:56.541Z","comments":false,"path":"2020/08/07/2020-08-06/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-06/","excerpt":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。","text":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。 Step 1 - Hexo 本地安装及运行测试首先全局安装 Hexo： 1sudo npm install hexo-cli -g 安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record： 1hexo init daily_record 接下来进入到博客目录下，安装依赖，运行即可查看初始状态了 123cd daily_recordnpm installhexo server 如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面： Step 2 - 更换 Volantis 主题想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美) 好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。 接下来进入到项目的根目录，开始安装主题： 1git clone https://github.com/xaoxuu/hexo-theme-volantis themes/volantis 下载好之后，修改根目录下的 _config.yml 文件： 12- theme: landscape+ theme: volantis 然后安装一些依赖： 1npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S 现在重新启动服务，你的网站应该变成了这样 Step 3 - 部署到 Gitub这个主题有很多配置，具体可以参考官方文档，这里就还不在赘述。 要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。 需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目 然后安装 Hexo 的部署插件： 1npm install hexo-deployer-git -S 安装好之后，修改根目录下的 _config.yml 文件： 1234deploy:+ type: &#x27;git&#x27;+ repo: https://github.com/yourname/yourname.github.io+ branch: master 最后通过以下命令即可一键部署： 1hexo g -d Step 4 - 访问个人主页接下来就可以在下面的地址访问你的个人主页了： 1https://yourname.github.io/","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}}],"categories":[],"tags":[]}