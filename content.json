{"meta":{"title":"世界的侧面","subtitle":"以怎样的角度，才能看到这个世界的侧面？","description":"","author":"初心Yearth","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"前端造轮子【3】 —— mvvm","slug":"2020-08-10","date":"2020-08-10T08:08:40.817Z","updated":"2020-08-10T08:08:40.817Z","comments":false,"path":"2020/08/10/2020-08-10/","link":"","permalink":"http://yoursite.com/2020/08/10/2020-08-10/","excerpt":"今天我们来研究一下 vue 2.x 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》","text":"今天我们来研究一下 vue 2.x 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》 思路整理我们首先来看看官网给出的示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这个例子很好的展示了 mvvm 的核心功能： 数据驱动视图更新 再结合代码看看，我们发现这里的定义并不复杂，仅仅是： el：指定跟节点 data：定义响应式数据 插值表达式：渲染变量 v-xxx：vue 指令 从上面我们能得到什么信息呢？ 显然，我们要对节点进行解析，解析其中的插值表达式和 v-xxx 指令，这个功能我们可以叫它 Compiler。然后我们还需要对 data 中的数据进行劫持，当其中的数据发生 get/set 的时候，能够进行自定义的操作，这个功能我们叫它 Observer。最后我们需要监听这些数据，当他们发生改变的时候，通知视图去进行更新操作，这个功能我们叫它 Watcher。 这里引用一下大佬的图： 可以看到，除了上面我们提到的三个模块以外，这里还多了 Updater 和 Dep，Updater 倒还好理解，但这 Dep 是干嘛的呢？ 我们知道，data 和 view 中的显示存在多对多的关系，如下： 123456789101112131415;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;1: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;2: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;3: &#123;&#123; data_2 &#125;&#125;&lt;/p&gt; &lt;p&gt;4: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt; &lt;p&gt;5: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; data_1: 1, data_2: 2, data_3: 3, &#125;,&#125;) 上面的代码中： 当 data_1 发生改变的时候，p1 和 p2 都要重新渲染 当 data_2 发生改变的时候，p3 要重新渲染 当 data_3 发生改变的时候，p4 和 p5 都要重新渲染 显然这需要被控制管理起来，否则视图的更新肯定是一团乱，而 Dep 就是用来做这个的，我们可以看看下面这张图： 从上图可以看到： view 中每一个需要被渲染的值对应一个 Watcher 每一个响应式变量对应一个 Dep 那么更新流程就应该是这样：当是数据更新的时候，Observer 通知对应的 Dep，然后 Dep 通知自己管理的 Watcher 调用 Updater 进行视图的更新。 当然，最后我们需要一个入口作为桥梁，将上面的各个模块给联系起来，组合成一个完整的 mvvm 框架。 大致的思路已经有了，那么开始吧，it’s show time！ 功能实现Entry首先再来看看官方示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这里 new 了一个 Vue，并且只传了一个 obj 进去，那么我们最终对外暴露的对象也应当如此。 总所周知，vue 是法语视图的意思，那么这里就用它的好朋友来作为命名语言吧 123456789export default Aus &#123; constructor(options = &#123;&#125;)&#123; this.$options = options; this.$el = options.el; this.$data = options.data; if (!this.$el) throw new Error(&quot;请指定挂载点&quot;); &#125;&#125; 接下来我们就来实现模板的解析。 Compiler我们来分析一下 Compiler 需要做什么： 通过 el 获取需要被编译的 root 节点 进行模板编译 将编译后的节点覆盖到 root 节点的位置 而模板编译应该怎么进行呢？ 首先我们可以将节点碎片化，在内存中处理 遍历当前的节点树，这里我们只关注两类节点： 元素节点：处理 a-xxx 指令 文本节点：处理插值表达式 将编译好的节点碎片 append 到 root 节点上 那么我们的问题就来到了如何处理文本和元素节点： 元素节点：node.attributes 文本节点：正则表达式 进过上面一通分析，整个结构已经比较清晰了，这里再补上脑图： 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;单层：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; import Aus from &#x27;./aus.js&#x27; const am = new Aus(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello Aussicht!&#x27;, &#125; &#125;)&lt;/script&gt; 效果如下： 可以看到，这里已经成功将 a-text 和插值表达式替换成了我们想要渲染的变量了。 接下来我们想要实现的效果是当数据发生改变的时候，视图也随之更新，那么首先应该实现的是 Observer。 Observer同样的，我们来分析一下 Observer 需要做什么。 事实上，仅仅考虑数据劫持这一层面的话，Observer 需要实现的功能非常简单，就是利用 Object.defineProperty 对 data 进行代理即可。 流程很简单： 获取 data 的所有 key，对其进行劫持 如果 data 的 key 为 obj，则递归 脑图如下： 本文主要是简单探讨一下 mvvm 实现原理，这里对于数组就不做处理了。 代码很简单，按照上面的思路进行实现即可： 12345678910111213141516171819202122232425262728293031323334353637import Dep from &#x27;./dep.js&#x27;class Observer &#123; constructor(data) &#123; this.data = data this.observe(this.data) &#125; observe(data) &#123; if (data &amp;&amp; typeof data === &#x27;object&#x27;) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]) &#125;) &#125; &#125; defineReactive(obj, key, value) &#123; this.observe(value) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get: (_) =&gt; &#123; return value &#125;, set: (newVal) =&gt; &#123; // 对新设置的值进行监听 this.observe(newVal) if (newVal !== value) &#123; value = newVal &#125; return true &#125;, &#125;) &#125;&#125;export default Observer 接下来就是最关键的，当数据发生改变的时候，通知视图进行更新渲染了。 Watcher &amp;&amp; Dep这里我们一步步分析一下： Watcher 一一对应模板中的变量（插值表达式 or a-text） Dep 对应具体变量 Observer 能发出通知 只有当变量发生改变的时候，模板中对应的地方需要发生重新渲染，所以流程应该是： Observer 通知 Dep，变量发生改变 Dep 管理了一个 Watcher 数组，执行 Watcher 的 update 方法，更新视图 那么现在的问题是，怎么建立 Dep 和 Watcher 的关系。 显然，模板中每有一个需要渲染的值，就应该有一个对应的 Watcher，而这个值在初始化的时候会进行 get 操作，那么自然是在 get 中进行操作最合适： 同样，在修改值得之后会进行 set 操作，那么在 set 的时候利用 dep 通知 Watcher 进行操作也最合适。 综上： Dep 至少需要管理一个 Watcher 数组，一个添加 Watcher 的方法，一个通知 Watcher 更新视图的方法 Watcher 在初始化的时候创建，管理 Update 方法 脑图如下： 12345678910111213class Dep &#123; constructor() &#123; this.watchers = [] &#125; addWatcher(w) &#123; this.watchers.push(w) &#125; notify() &#123; this.watchers.forEach((w) =&gt; &#123; w.updater() &#125;) &#125;&#125; 再修改一下 Observer 中的 get，这样整个流程就都通了： 1234get: (_) =&gt; &#123; Dep.target &amp;&amp; dep.addWatcher(Dep.target) return value&#125; 效果如下所示： 结语更加阅读体验：手写简易 MVVM","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【1】 —— vue-router","slug":"2020-08-07_2","date":"2020-08-07T07:07:22.163Z","updated":"2020-08-07T07:07:22.163Z","comments":false,"path":"2020/08/07/2020-08-07_2/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_2/","excerpt":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。","text":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。 Step 1 - 需求分析首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。 项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下： 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import VueRouter from &#x27;./yvue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;Vue.use(VueRouter)const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;), &#125;,]const router = new VueRouter(&#123; routes,&#125;)export default router 我们逐步来分析一下上面的代码： 首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 VueRouter 是 Vue 的插件，需要有自己的静态 install 方法 接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系 然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出 最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身 上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？ 首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？ 联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件： router-view：用于显示组件 router-link：用于路由跳转 显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。 接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。 以上，我们可以大致总结一下，如下图所示： Step 2 - 功能实现那么现在我们可以着手开始实现自己的 vue-router 了。 首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化： 1234567class VueRouter &#123; // 对应 Vue.use static install(Vue) &#123;&#125; // 对应 new constructor(options) &#123;&#125;&#125; 紧接着我们就可以在 install 中实现对两个全局组件的注册： 123456789101112131415161718192021222324252627282930313233343536373839404142class VueRouter &#123; // 对应 Vue.use static install(Vue)&#123; // step 1: 注册组件 router-link，用于路由跳转 // 回忆一下 router-link 的使用： // * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt; Vue.component(&#x27;router-link&#x27;, &#123; // 必要参数 to props: &#123; to: &#123; type: String, require: true, &#125;, &#125;, // 模板，可以使用 template，也可以使用 render。 // * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。 render() &#123; // 这里可以写 jsx，也可以使用 h 函数 // 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下 // * h 函数类似于 react 中的 createElement return &lt;a href=&#123;`#$&#123;this.to&#125;`&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125; // step 2: 注册组件 router-view，用于显示组件 // 回忆一下 router-link 的使用： // &lt;router-view /&gt; Vue.component(&#x27;router-view&#x27;, &#123; // 没有参数，直接 template render(h) &#123; // 这里使用 h // view-router 的功能是渲染组件，那么组件从哪里获取呢？ // 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取 // 而当前路由我们可以在构造函数中定义一个 current 来表示 // 所以可以通过以下代码找到当前 current 对应的组件 const &#123; routeMap, current &#125; = this.$router const component = routeMap[current] ? routeMap[current].component : null return h(component) &#125;, &#125;) &#125; /*...*/&#125; 到这里，至少我们的 已经是可用的了，而 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。 那么接下来自然是实现 constructor 12345678910111213141516171819202122class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const current = window.location.hash.slice(1) || &#x27;/&#x27; // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件： 那应该怎么办呢？ 接下来的问题是：怎么将 current 转成 vue 响应式数据？ 对于上述问题，这里有两个思路： 新建 vue 实例，通过 data 将 current 转成响应式数据 利用 vue 提供的静态方法 Vue.util.defineReactive 这里我们采取第二种方案： 1234567891011121314151617181920212223class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里又出现一个问题，这个 Vue 从哪里来呢？ 其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了： 12345678910111213141516171819202122232425let _Vueclass VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，基本的路由已经实现了： 还有一些可以扩展的地方： 比如优化一下 constructor，将 options 保存到本地： 123456789101112131415constructor(options)&#123; this.$options = options // 初始化路由表 this.routerMap = &#123;&#125; this.$options.routes.map((route)=&gt;&#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this))&#125; 这可以保证数据的单向流动。 比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。 不过这里有一个点值得注意，那就是时间： 因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过： 1Vue.prototype.$router = this.$options.router 进行挂载显然是不行的。 这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作： 1234567Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router &#125; &#125;,&#125;) 这样就没什么问题了。 结语更佳阅读体验：手写简易 vue-router","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【2】 —— vuex","slug":"2020-08-07_3","date":"2020-08-07T06:55:21.640Z","updated":"2020-08-07T06:55:21.640Z","comments":false,"path":"2020/08/07/2020-08-07_3/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_3/","excerpt":"今天我们来研究一下 vuex 的内部实现原理。同 vue-router，我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程","text":"今天我们来研究一下 vuex 的内部实现原理。同 vue-router，我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程 Step 1 - 需求分析首先用 vue-cli 4.x 创建一个空项目，选择使用 vuex，等项目创建好之后，在 src 目录下应该存在一个 store 文件，其内容大致如下： 12345678910111213141516171819202122import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;, actions: &#123; add(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&#x27;add&#x27;) &#125;, 1000) &#125;, &#125;,&#125;) 使用过状态管理库的同学应该很清楚 action 主要用于处理异步操作，那么这里我们暂时先不关心它，把同步操作处理完之后再来看它就会清晰很多了： 123456789101112131415import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;,&#125;) 从上述代码，我们可以分析出以下几点： 首先 vuex 是 vue 的插件，首先会 use，在这个时候调用其 install 方法 通过 new 新建实例的是 vuex 上的 store 对象而非 vuex 本身 导出的 store 会在 main 中传给 vue（这一部分在 main 中，而不在上述代码中） 那么我们的 vuex 应该如何设计呢？ 我认为应该结合 vuex 的使用来进行分析： 我们知道，在项目中使用 vuex 的时候，通常形如： 123this.$store.state.xxxthis.$store.commit(&#x27;xxx&#x27;)// this.$store.dispatch(&#x27;xxx&#x27;) 异步，暂不考虑 显然，首先我们需要把 store 挂载到 vue 实例上，其次，store 上还应该有 state 和 commit，它们两分别是一个 object 和一个 function。 此时的思维导图如下所示： Step 2 - 功能实现基础功能那么我们按照这样的方式构建 vuex： 123456789101112131415161718// export default Vuexexport default &#123; install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125;, &#125;) &#125;, Store: class Store &#123; constructor() &#123; this.state = &#123;&#125; &#125; commit() &#123;&#125; &#125;,&#125; 接下来我们再回到 store 中，可以看到在创建 store 实例的时候，我们传递了两个对象： state：用于存储状态 mutations：用于同步修改状态 也就是说，在构建实例的过程中，我们将 state 存储到 $store.state 中，将 mutations 存储起来，在 commit 的时取出调用，思维导图如下： 那么我们对应实现的代码应该是： 12345678910111213export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this.state = options.state &#125; commit(type, payload) &#123; const mutation = this._mutations[type] return mutation(this.state, payload) &#125; &#125;,&#125; 这个时候，已经能从 this.$store.state 中取出 counter 了： 并且 commit 也能成功调用了： 但这里还有问题，最关键的就是 counter 的改变并没有引起页面的重新渲染。显然我们应该将 state 改成响应式数据，在 手写简易 vue-router 中我们使用了 vue 官方提供的静态方法：Vue.util.defineReactive 那么这里我们就尝试使用另一个办法来实现响应式数据：创建 vue 实例，利用其中的 data 方法将 state 转化为响应式数据，实际代码如下： 123456789101112131415161718192021222324export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this._vm = new _Vue(&#123; data() &#123; return &#123; // 由于不希望数据被代理，所以这里加上 $ $$state: options.state, &#125; &#125;, &#125;) &#125; get state() &#123; return this._vm._data.$$state &#125; set state(value) &#123; // 不允许直接修改 state console.error(&#x27;please use replaceState to reset state&#x27;) &#125; /*...*/ &#125;,&#125; 现在我们再看看效果如何： 至此，一个最最基础的 store 已经基本实现了，接下来自然是异步操作的 action 了。 异步操作其实明白了 mutations，actions 也已经清楚了大半，唯一的区别就是 action 中我们需要调用 commit 来修改 state，那么这个 commit 从哪里来自然就很清楚了：this 导图如下： 实现代码如下： 1234567891011121314export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._actions = options.actions &#125; /*...*/ dispatch(type, payload) &#123; const action = this._actions[type] return action(this, payload) &#125; &#125;,&#125; nice，非常完美，我们来看看效果： 报错了？ 这是为什么呢？ 于是跟踪调试一番，发现如下情况： this 没了，再看看 action： 显然，这里因为是在 setTimeout 中调用 commit，丢失了 this，所以我们在构建实例的时候进行绑定就可以啦。 这下就没有问题了。 扩展 - gettter我们已经实现了基础的 vuex，而平时使用 vuex 的时候，大家知道 getter 也是经常被使用到的。 那么这个 getter 应当如何实现呢？ 我们假设在创建 vuex 的时候传入 getter，里面只有一个值，是 doubleCounter，返回值是 counter * 2，那么自然 doubleCounter 是被 counter 所影响，我们这里可以画出如下导图： 那么问题来了：怎么将 getter 和 state 关联起来呢？ 仔细想一想，显然这里是做代理，那么答案就呼之欲出了：Object.defineProperty。有了这个核心思想之后，我们继续分析，由于 getter 不止一个，那么我们肯定需要遍历传入的 getter obj，将其注册到 store 上。 我们可以先来实现这一步操作： 1234567891011121314151617181920212223export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._getters = options.getters this.= Object.create(null) this.forEachGetter(this, this._getters) &#125; /*...*/ forEachGetter(store, getters) &#123; Object.keys(getters).forEach((key) =&gt; &#123; const getter = getters[key] this.registerGetter(store, getter, key) &#125; &#125; registerGetter(store, getter, key)&#123; store._wrappedGetters[key] = function wrappedGetter(store)&#123; return getter(store.state) &#125; &#125; &#125;,&#125; 执行完这一步之后，我们可以调试看看： 可以看到，store 上的属性 _wrappedGetters 中现在包含两个属性： doubleCounter：这是一个函数，即 registerGetter 中返回的 wrappedGetter，当我们调用它的时候，会返回 getter(store.state) 执行的结果，及 state.counter * 2 state：这里是响应式数据（不过现在还不是响应式的） 现在已经建立好了 options.getter 和 store._wrappedGetters 的映射关系，我们可以开始通过 Object.defineProperty 来做代理了： 123456789101112131415161718192021222324252627282930export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this.resetStoreVm(this, options.state) &#125; /*...*/ resetStoreVm(store, state) &#123; store.getters = &#123;&#125; const computed = &#123;&#125; const wrappedGetters = store._wrappedGetters Object.keys(wrappedGetters).forEach((key) =&gt; &#123; computed[key] = this.partial(wrappedGetters[key], store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], &#125;) &#125;) this._vm = new _Vue(&#123; data() &#123; return &#123; $$state: state, &#125; &#125;, // ! 计算属性，用于实现 getter computed: computed, &#125;) &#125; partial = (fn, arg) =&gt; () =&gt; fn(arg)&#125; 上面的代码，比较有容易搞不清楚的就两个地方： wrappedGetters[key] 是什么 partial 返回值是什么 这个问题直接在调试器里看看就清楚了： 显然，这两位，一个是 getter 的包裹函数，一个是其本身。 到这里，getter 也算是基本实现了，具体效果如下： 结语更佳阅读体验：手写简易 vuex","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【2】 —— 网站配置","slug":"2020-08-07_1","date":"2020-08-07T03:29:03.057Z","updated":"2020-08-07T03:10:32.504Z","comments":false,"path":"2020/08/07/2020-08-07_1/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_1/","excerpt":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。","text":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。 站点配置目标文件：root/ _config.yml 1234title: 世界的侧面subtitle: &#x27;&#x27;author: 初心Yearthfavicon: https://s1.ax1x.com/2020/08/06/agXE9K.png 主题配置目标文件：root/themes/volantis/_config.yml 封面配置12345cover: M title: &#x27;标题&#x27; M # subtitle: &#x27;&#x27; M search: 你想看点什么呢？ M # features: // 这个选项是搜索框下的导航按钮，这里选择注释掉 导航栏配置12345678910111213141516171819202122232425navbar: logo: img: icon: title: &#x27;标题&#x27; menu: M # - name: 博客 M # icon: fas fa-rss M # url: / - name: 分类 icon: fas fa-tags url: tags/ - name: 标签 icon: fas fa-tags url: tags/ M # - name: 归档 M # icon: fas fa-archive M # url: archives/ M # - name: 友链 M # icon: fas fa-link M # url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: 你想看点什么呢？ 布局配置123layout:on_page:M body: [article] 插件配置123456plugins:backstretch:M position: fixedaplayer:M id: 170672512M autoplay: true 最终效果","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【1】 —— 基础搭建","slug":"2020-08-06","date":"2020-08-07T03:10:56.541Z","updated":"2020-08-07T03:10:56.541Z","comments":false,"path":"2020/08/07/2020-08-06/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-06/","excerpt":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。","text":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。 Step 1 - Hexo 本地安装及运行测试首先全局安装 Hexo： 1sudo npm install hexo-cli -g 安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record： 1hexo init daily_record 接下来进入到博客目录下，安装依赖，运行即可查看初始状态了 123cd daily_recordnpm installhexo server 如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面： Step 2 - 更换 Volantis 主题想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美) 好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。 接下来进入到项目的根目录，开始安装主题： 1git clone https://github.com/xaoxuu/hexo-theme-volantis themes/volantis 下载好之后，修改根目录下的 _config.yml 文件： 12- theme: landscape+ theme: volantis 然后安装一些依赖： 1npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S 现在重新启动服务，你的网站应该变成了这样 Step 3 - 部署到 Gitub这个主题有很多配置，具体可以参考官方文档，这里就还不在赘述。 要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。 需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目 然后安装 Hexo 的部署插件： 1npm install hexo-deployer-git -S 安装好之后，修改根目录下的 _config.yml 文件： 1234deploy:+ type: &#x27;git&#x27;+ repo: https://github.com/yourname/yourname.github.io+ branch: master 最后通过以下命令即可一键部署： 1hexo g -d Step 4 - 访问个人主页接下来就可以在下面的地址访问你的个人主页了： 1https://yourname.github.io/","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}}],"categories":[],"tags":[]}