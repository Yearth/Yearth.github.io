{"meta":{"title":"世界的侧面","subtitle":"以怎样的角度，才能看到这个世界的侧面？","description":"","author":"初心Yearth","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"前端造轮子【1】 —— vue-router","slug":"2020-08-07_2","date":"2020-08-07T03:36:31.879Z","updated":"2020-08-07T03:36:31.879Z","comments":false,"path":"2020/08/07/2020-08-07_2/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_2/","excerpt":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。","text":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。 Step 1 - 需求分析首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。 项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下： 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import VueRouter from &#x27;./yvue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;Vue.use(VueRouter)const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;), &#125;,]const router = new VueRouter(&#123; routes,&#125;)export default router 我们逐步来分析一下上面的代码： 首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 VueRouter 是 Vue 的插件，需要有自己的静态 install 方法 接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系 然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出 最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身 上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？ 首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？ 联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件： router-view：用于显示组件 router-link：用于路由跳转 显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。 接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。 以上，我们可以大致总结一下，如下图所示： Step 2 - 功能实现那么现在我们可以着手开始实现自己的 vue-router 了。 首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化： 1234567class VueRouter &#123; // 对应 Vue.use static install(Vue) &#123;&#125; // 对应 new constructor(options) &#123;&#125;&#125; 紧接着我们就可以在 install 中实现对两个全局组件的注册： 123456789101112131415161718192021222324252627282930313233343536373839404142class VueRouter &#123; // 对应 Vue.use static install(Vue)&#123; // step 1: 注册组件 router-link，用于路由跳转 // 回忆一下 router-link 的使用： // * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt; Vue.component(&#x27;router-link&#x27;, &#123; // 必要参数 to props: &#123; to: &#123; type: String, require: true, &#125;, &#125;, // 模板，可以使用 template，也可以使用 render。 // * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。 render() &#123; // 这里可以写 jsx，也可以使用 h 函数 // 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下 // * h 函数类似于 react 中的 createElement return &lt;a href=&#123;`#$&#123;this.to&#125;`&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125; // step 2: 注册组件 router-view，用于显示组件 // 回忆一下 router-link 的使用： // &lt;router-view /&gt; Vue.component(&#x27;router-view&#x27;, &#123; // 没有参数，直接 template render(h) &#123; // 这里使用 h // view-router 的功能是渲染组件，那么组件从哪里获取呢？ // 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取 // 而当前路由我们可以在构造函数中定义一个 current 来表示 // 所以可以通过以下代码找到当前 current 对应的组件 const &#123; routeMap, current &#125; = this.$router const component = routeMap[current] ? routeMap[current].component : null return h(component) &#125;, &#125;) &#125; /*...*/&#125; 到这里，至少我们的 已经是可用的了，而 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。 那么接下来自然是实现 constructor 12345678910111213141516171819202122class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const current = window.location.hash.slice(1) || &#x27;/&#x27; // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件： 那应该怎么办呢？ 接下来的问题是：怎么将 current 转成 vue 响应式数据？ 对于上述问题，这里有两个思路： 新建 vue 实例，通过 data 将 current 转成响应式数据 利用 vue 提供的静态方法 Vue.util.defineReactive 这里我们采取第二种方案： 1234567891011121314151617181920212223class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里又出现一个问题，这个 Vue 从哪里来呢？ 其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了： 12345678910111213141516171819202122232425let _Vueclass VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，基本的路由已经实现了： 还有一些可以扩展的地方： 比如优化一下 constructor，将 options 保存到本地： 123456789101112131415constructor(options)&#123; this.$options = options // 初始化路由表 this.routerMap = &#123;&#125; this.$options.routes.map((route)=&gt;&#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this))&#125; 这可以保证数据的单向流动。 比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。 不过这里有一个点值得注意，那就是时间： 因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过： 1Vue.prototype.$router = this.$options.router 进行挂载显然是不行的。 这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作： 1234567Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router &#125; &#125;,&#125;) 这样就没什么问题了。","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【2】 —— 网站配置","slug":"2020-08-07_1","date":"2020-08-07T03:29:03.057Z","updated":"2020-08-07T03:10:32.504Z","comments":false,"path":"2020/08/07/2020-08-07_1/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_1/","excerpt":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。","text":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。 站点配置目标文件：root/ _config.yml 1234title: 世界的侧面subtitle: &#x27;&#x27;author: 初心Yearthfavicon: https://s1.ax1x.com/2020/08/06/agXE9K.png 主题配置目标文件：root/themes/volantis/_config.yml 封面配置12345cover: M title: &#x27;标题&#x27; M # subtitle: &#x27;&#x27; M search: 你想看点什么呢？ M # features: // 这个选项是搜索框下的导航按钮，这里选择注释掉 导航栏配置12345678910111213141516171819202122232425navbar: logo: img: icon: title: &#x27;标题&#x27; menu: M # - name: 博客 M # icon: fas fa-rss M # url: / - name: 分类 icon: fas fa-tags url: tags/ - name: 标签 icon: fas fa-tags url: tags/ M # - name: 归档 M # icon: fas fa-archive M # url: archives/ M # - name: 友链 M # icon: fas fa-link M # url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: 你想看点什么呢？ 布局配置123layout:on_page:M body: [article] 插件配置123456plugins:backstretch:M position: fixedaplayer:M id: 170672512M autoplay: true 最终效果","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【1】 —— 基础搭建","slug":"2020-08-06","date":"2020-08-07T03:10:56.541Z","updated":"2020-08-07T03:10:56.541Z","comments":false,"path":"2020/08/07/2020-08-06/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-06/","excerpt":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。","text":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。 Step 1 - Hexo 本地安装及运行测试首先全局安装 Hexo： 1sudo npm install hexo-cli -g 安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record： 1hexo init daily_record 接下来进入到博客目录下，安装依赖，运行即可查看初始状态了 123cd daily_recordnpm installhexo server 如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面： Step 2 - 更换 Volantis 主题想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美) 好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。 接下来进入到项目的根目录，开始安装主题： 1git clone https://github.com/xaoxuu/hexo-theme-volantis themes/volantis 下载好之后，修改根目录下的 _config.yml 文件： 12- theme: landscape+ theme: volantis 然后安装一些依赖： 1npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S 现在重新启动服务，你的网站应该变成了这样 Step 3 - 部署到 Gitub这个主题有很多配置，具体可以参考官方文档，这里就还不在赘述。 要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。 需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目 然后安装 Hexo 的部署插件： 1npm install hexo-deployer-git -S 安装好之后，修改根目录下的 _config.yml 文件： 1234deploy:+ type: &#x27;git&#x27;+ repo: https://github.com/yourname/yourname.github.io+ branch: master 最后通过以下命令即可一键部署： 1hexo g -d Step 4 - 访问个人主页接下来就可以在下面的地址访问你的个人主页了： 1https://yourname.github.io/","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}}],"categories":[],"tags":[]}