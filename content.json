{"meta":{"title":"世界的侧面","subtitle":"以怎样的角度，才能看到这个世界的侧面？","description":"","author":"初心Yearth","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Vue 2.6 源码分析之旅【2】 —— 数据响应式","slug":"2020-08-17","date":"2020-08-17T08:08:21.658Z","updated":"2020-08-17T08:08:21.658Z","comments":false,"path":"2020/08/17/2020-08-17/","link":"","permalink":"http://yoursite.com/2020/08/17/2020-08-17/","excerpt":"","text":"上一章粗浅的分析了 vue 2.6.x 的初始化流程，搞清楚了以下几个问题： vue 的入口在哪里 vue 的初始化做了什么操作 在 vue 初始化过程中，哪些操作先执行，哪些操作后执行 而今天，我们将分析 vue 2.6.x 中是如何完成数据响应式操作的。 那么开始吧！ 处理对象相信大家都知道，vue 2.6.x 中实现数据响应式的核心方法是 Object.defineProperty，而这个方法并不能处理数组，所以 vue 对于数组和对象的处理方法是不同的，这里我们就先来分析它是如何处理对象的。 通过上一章的分析，我们知道，在初始化流程中，处理数据的方法是 initState： 123456789101112131415export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe((vm._data = &#123;&#125;), true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 上面的代码告诉我们两条信息： 优先级：props &gt; methods &gt; data &gt; computed &gt; watch 实现数据响应式的方法是 initData(vm) 12345678910111213141516171819202122232425262728293031323334function initData(vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn(`Method &quot;$&#123;key&#125;&quot; has already been defined as a data property.`, vm) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(`The data property &quot;$&#123;key&#125;&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; 从这里可以看到，最核心的方法是 observe。 那么跳过去看看： 文件位置：src/core/observer/index.js： 123456789101112131415161718192021export function observe(value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; 而从这里的代码，我们能看到以下信息： 如果不是对象，则不会进行 new Observer() 操作 如果一个对象拥有 __ob__ 属性，那么它就是一个响应式的数据 实现响应式的核心操作在 new Observer() 中 所以现在跳转都 Observer 中看看： 文件位置：src/core/observer/index.js： 1234567891011121314151617constructor(value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; 这里可以看到，每一个 ob 实例一定会有一个 dep 实例，而每一个数据对象会有一个 ob，所以每个对象将有一个 dep 实例，暂且我们叫它对象依赖管理器，至于它的用处，暂不深入讨论，后面再回过头来看。 前面已经提到过，数组和对象的响应式有区别，这里我们先看响应式是如何实现的： 123456walk(obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125;&#125; 显然，defineReactive 就是实现数据响应式的核心方法了。 并且这个方法挂到了 Vue.util.defineReactive 上 那么我们深入到方法内部看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354export function defineReactive(obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125;, &#125;)&#125; 乍一看挺复杂，实际上上面的代码总共做了三件事： 给每个 key 创建一个 dep（这个 dep 我们叫它数据依赖管理器） 如果传入的 val 是 object，则进行递归操作 通过 Object.defineProperty 实现数据响应式 那么具体是如何实现的呢？ 可以看到，在 get 的时候，进行了如下操作： 123456789if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125;&#125; 用比较专业说的说法，这一步叫做依赖收集，这里我们需要搞清楚几个问题： 什么是依赖收集？ Dep.target 是什么？ depend 做了什么？ dependArray 做了什么？ 这里一一回答： 我们都知道，vue 是一款 mvvm 的框架，实现了数据的响应式，让开发者不用再过分关注数据，视图的联系，只需要更新数据，视图会自动的更新。 假设现在有 a, b, c, d 四个变量，而视图中只用到了 a, c, d，那么 b 更改的时候，视图自然不应该刷新，要怎么判断 b 和视图有没有关系呢？这就是依赖收集需要做到的。 至于下面的问题，我们得先到 dep 中看看： 文件位置：src/core/observer/dep.js： 1234567891011121314151617181920212223242526272829303132333435363738export default class Dep &#123; static target: ?Watcher id: number subs: Array&lt;Watcher&gt; constructor() &#123; this.id = uid++ this.subs = [] &#125; addSub(sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub(sub: Watcher) &#123; remove(this.subs, sub) &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify() &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 通过类型可以看到，target 应该是一个 Wathcer，而 Wathcer，我们前面手写 vue 响应式的时候，已经介绍的很清楚了，如果有不清楚的童鞋可以看看这篇文章：手写简易 MVVM。 那么 depend 做了什么呢？ 我们来到 Watcher： 文件位置：src/core/observer/watcher.js： 12345678910addDep(dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 这里主要做了两个操作： 建立 watcher 和 dep 的关系 反向建立 dep 和 watcher 的关系 那么为什么要建立双向的关系呢？之前实现 mvvm 的时候，不是建立单向关系就可以了吗？ 这个问题我们稍后再说，现在先来看看上面的最后一个问题，dependArray 又做了什么？ 123456789function dependArray(value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125; 显然，这里是遍历数组，对其每一个元素建立和 dep 的关系。 这里为了理清思路，补上脑图： 从图中我们可以看到，这里的关键点是： Wathcer 是什么？ Dep 是什么？ 为什么要建立它们的关系？ 建立了它们的关系有什么用？ 前面已经多次提到 Dep 了，有 obj 中的 Dep，也有 key 中的 Dep，这里我们就先来看看 Dep： 1234567891011121314151617181920212223242526272829303132333435363738export default class Dep &#123; static target: ?Watcher id: number subs: Array&lt;Watcher&gt; constructor() &#123; this.id = uid++ this.subs = [] &#125; addSub(sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub(sub: Watcher) &#123; remove(this.subs, sub) &#125; depend() &#123; if (Dep.target) &#123; Dep.target.addDep(this) &#125; &#125; notify() &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !config.async) &#123; // subs aren&#x27;t sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 上面的代码告诉我们几条信息： dep 管理着一个有 Wathcer 组成的数组 在 notify 中会遍历这个数组，执行其中的 update 方法 而 update 的具体实现涉及到 vue 的异步更新，所以这里就仅把它当成是视图更新函数即可，暂不讨论其具体实现。 那么 Dep 和 Watcher 的关系是：Dep 管理 Watcher，Watcher 管理视图更新。 到这里，我们已经大致清楚 vue 的数据响应式流程了，不过还存有一些疑问： 为什么要建立 Dep 和 Watcher 的双向关系？ 对象依赖管理器（Observer 中的 Dep）是干嘛的？ 数据依赖管理器（defineReactive 中的 Dep）是干嘛的？ 现在我们可以来回答这些问题了： 为什么要建立 Dep 和 Watcher 的双向关系？总所周知，vue 是组件化的前端框架，那么自然就会存在下面这样的情况： 12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Vue组件化机制&lt;/h1&gt; &lt;comp :msg=&quot;msg&quot;&gt;&lt;/comp&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&#x27;comp&#x27;, &#123; template: &#x27;&lt;div&gt;I am comp&lt;/div&gt;&#x27;, props: [&#x27;msg&#x27;], data: function() &#123; return &#123; compMsg: this.msg + &#x27;comp&#x27; &#125; &#125;, &#125;) const app = new Vue(&#123; el: &#x27;#demo&#x27;, data() &#123; return &#123; msg: &#x27;hello vue&#x27;, &#125; &#125;, &#125;) &lt;/script&gt; &lt;/body&gt; 在这样的情况下，仅有 Dep 到 Wathcer 的关系显然是不够的了，所以还需要建立 Wathcer 到 Dep 的关系。 对象依赖管理器（Observer 中的 Dep）是干嘛的？这个很好解释，当 data 中存在对象，甚至对象嵌套的时候，修改其中的值，同样需要出发视图的更新，这就是对象依赖管理器的作用。 数据依赖管理器（defineReactive 中的 Dep）是干嘛的？最直接通知 Wathcer 更新视图的地方。 补上脑图： 到这里，对象的响应式处理已经完成了，我们再来看看对于数组，是怎么操作的。 处理数组有前面的积累，可以很快定位到处理数组的方法： 12345678if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value)&#125; 我们先看看 observeArray，毕竟名字都这么直白了： 12345observeArray(items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125;&#125; 显然，这里就是遍历数组，对其每个元素进行响应式处理。 那么来到 protoAugment： 12345function protoAugment(target, src: Object) &#123; /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */&#125; 从调用可以看到，target 是一个数组实例，那么这里的操作就是覆盖其原型。 那么 src 是什么呢？ 1export const arrayMethods = Object.create(arrayProto) 光看这个好像并不能看出点什么，结合下面的代码再看看： 123456789101112131415161718192021222324252627const methodsToPatch = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;]/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method] def(arrayMethods, method, function mutator(...args) &#123; const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args break case &#x27;splice&#x27;: inserted = args.slice(2) break &#125; if (inserted) ob.observeArray(inserted) // notify change ob.dep.notify() return result &#125;)&#125;) 显然，这里通过装饰器方法对 methodsToPatch 中的七个数组方法进行了扩展。 大致分为以下几步： 先执行原来的数组方法（原有功能不变） 对于新插入的数据， 做响应式处理：if (inserted) ob.observeArray(inserted) 通知 watcher 更新视图：ob.dep.notify() 最终脑图如下： 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 二：数据响应式 那么本篇的粗浅分析到此为止，剩下的来日再议论吧！咕咕咕~ 🐥 🐥 🐥","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【1】 —— 初始化流程","slug":"2020-08-12_1","date":"2020-08-13T08:04:10.635Z","updated":"2020-08-13T08:04:10.635Z","comments":false,"path":"2020/08/13/2020-08-12_1/","link":"","permalink":"http://yoursite.com/2020/08/13/2020-08-12_1/","excerpt":"Vue 源码还是比较庞大的，如果分析源码没有条理，直接一头扎进去，很容易陷进代码海中，一通分析下来一头雾水，还打击信心。 那么应该怎么分析源码呢？ 以下是个人总结的几点经验，如有谬误之处，望指出： 首要任务是找到入口，如 Vue 则找到其构造函数 先理清主线，后分析实现，别被细枝末节的代码影响思路 那么接下来，我们就来尝试找找 Vue 的构造函数吧！","text":"Vue 源码还是比较庞大的，如果分析源码没有条理，直接一头扎进去，很容易陷进代码海中，一通分析下来一头雾水，还打击信心。 那么应该怎么分析源码呢？ 以下是个人总结的几点经验，如有谬误之处，望指出： 首要任务是找到入口，如 Vue 则找到其构造函数 先理清主线，后分析实现，别被细枝末节的代码影响思路 那么接下来，我们就来尝试找找 Vue 的构造函数吧！ 寻找构造函数对于这个问题，我们可以利用调试器，用最直接的办法定位到入口文件。 首先编写测试 demo，将断点定在 new Vue(&#123;&#125;) 处，通过 f11 进入构造函数，然后通过鼠标右键定位到目标文件： 123456function Vue(options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125; 显然，这就是 Vue 的构造函数了，其文件路径为：src/core/instance/index.js 。 当然，上面的方法能够快速有效的定位到目标文件，这能提高我们的分析效率，但这里我们也可以尝试一下另一种类似解密的分析思路，从蛛丝马迹中找到答案： 首先我们来看看 pakage.json： 1&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; 从这里我们可以得到两个信息： 配置文件是 scripts/config.js 环境变量是 TARGET:web-full-dev 那么我们来到 scripts/config.js，定位到 web-full-dev： 12345678&#x27;web-full-dev&#x27;: &#123; entry: resolve(&#x27;web/entry-runtime-with-compiler.js&#x27;), dest: resolve(&#x27;dist/vue.js&#x27;), format: &#x27;umd&#x27;, env: &#x27;development&#x27;, alias: &#123; he: &#x27;./entity-decoder&#x27; &#125;, banner &#125;, 从这里可以看到入口文件是 web/entry-runtime-with-compiler.js，但这个 web 是哪个目录呢？在 vscode 中利用 ctrl + 鼠标左键 可以来到 resolve 函数的定义处： 123456789const resolve = (p) =&gt; &#123; // web/... const base = p.split(&#x27;/&#x27;)[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, &#x27;../&#x27;, p) &#125;&#125; 这里 resolve 方法的返回是 aliases[base] + path，那么我们来看看 aliases 是什么： 12345678910module.exports = &#123; vue: resolve(&#x27;src/platforms/web/entry-runtime-with-compiler&#x27;), compiler: resolve(&#x27;src/compiler&#x27;), core: resolve(&#x27;src/core&#x27;), shared: resolve(&#x27;src/shared&#x27;), web: resolve(&#x27;src/platforms/web&#x27;), weex: resolve(&#x27;src/platforms/weex&#x27;), server: resolve(&#x27;src/server&#x27;), sfc: resolve(&#x27;src/sfc&#x27;),&#125; 到这里，结果就出来了，入口文件是：src/platforms/web/entry-runtime-with-compiler.js，来到让我们来到这个文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const mount = Vue.prototype.$mountVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; warn(`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`) return this &#125; const options = this.$options if (!options.render) &#123; let template = options.template if (template) &#123; if (typeof template === &#x27;string&#x27;) &#123; if (template.charAt(0) === &#x27;#&#x27;) &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !template) &#123; warn(`Template element not found or is empty: $&#123;options.template&#125;`, this) &#125; &#125; &#125; else if (template.nodeType) &#123; template = template.innerHTML &#125; else &#123; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(&#x27;invalid template option:&#x27; + template, this) &#125; return this &#125; &#125; else if (el) &#123; template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile&#x27;) &#125; const &#123; render, staticRenderFns &#125; = compileToFunctions( template, &#123; outputSourceRange: process.env.NODE_ENV !== &#x27;production&#x27;, shouldDecodeNewlines, shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments, &#125;, this ) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; mark(&#x27;compile end&#x27;) measure(`vue $&#123;this._name&#125; compile`, &#x27;compile&#x27;, &#x27;compile end&#x27;) &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125; 这个文件最主要的功能是扩展了 web 平台需要的 $mount，这也说明基本的 $mount 是不满足 web 平台的需求的。 在这个函数中，能看到以下比较重要的逻辑： 如果存在 render 函数，则不再关注 template 和 el 当不存在 render 函数，则优先关注 template 当同时不存在 render 和 template，则最终选择 el，并且通过 getOuterHTML 将其转化为 template 处理完上面的逻辑之后将 template 通过 compileToFunctions 编译成 render 函数 最后调用 mount 将内容挂载到 root 节点上 优先级：render &gt; template &gt; el 这里我们可以看到 Vue 是外部引入的，位置如下： 1import Vue from &#x27;./runtime/index&#x27; 随机来到目标文件 src/platforms/webs/runtime/index.js： 123456Vue.prototype.__patch__ = inBrowser ? patch : noopVue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 可以看到这个文件主要做了一些对 vue 扩展的事情，最为关键的两点则是上面代码中的部分： 安装了平台特有的 __patch__ 函数，它的功能是将虚拟 dom 转化成真实 dom，而 diff 也将在这里发生 实现了 $mount，不过这里也只是对 mountComponent 的一层封装，并没有触及真正的功能代码 接下来我们继续顺着引入 Vue 的线索推进： 1import Vue from &#x27;core/index&#x27; 于是来到文件 src/core/index： 1initGlobalAPI(Vue) 文件的核心功能就是初始化全局的 API，于是离开这里，继续深入： 1import Vue from &#x27;./instance/index&#x27; 终于来到了 Vue 的构造函数，代码在最上面已经贴出，这里就不再贴了。 脑图如下： 初始化流程分析要分析 Vue 初始化流程，我们先来看看构造函数文件吧： 123456789101112131415161718192021import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue(options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue)) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue)export default Vue 可以看到，在构造函数中执行了一个 this._init() 方法进行初始化，那么这个方法从何而来呢？ 我们往下，发现 initMixin(Vue) 这个方法，顾名思义，这应该是为 Vue 扩展 init 的方法，于是跳转进去看看： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function initMixin(Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this vm._uid = uid++ let startTag, endTag /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag) &#125; // a flag to avoid this being observed vm._isVue = true if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;) initInjections(vm) initState(vm) initProvide(vm) callHook(vm, &#x27;created&#x27;) /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false) mark(endTag) measure(`vue $&#123;vm._name&#125; init`, startTag, endTag) &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 果然，_init() 是在这里扩展的，它做了些什么呢？ 仔细阅读后可以知道，它的核心功能有两点： 进行各种初始化操作 如果设置了 el，则自动调用 $mount 进行挂载 继续深入，来看看具体执行了哪些初始化操作： 12345678initLifecycle(vm)initEvents(vm)initRender(vm)callHook(vm, &#x27;beforeCreate&#x27;)initInjections(vm)initState(vm)initProvide(vm)callHook(vm, &#x27;created&#x27;) 我们逐一分析： initLifecycle(vm)文件位置：src/core/instance/lifecycle.js 12345678910111213141516171819202122232425export function initLifecycle(vm: Component) &#123; const options = vm.$options // locate first non-abstract parent let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; while (parent.$options.abstract &amp;&amp; parent.$parent) &#123; parent = parent.$parent &#125; parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm vm.$children = [] vm.$refs = &#123;&#125; vm._watcher = null vm._inactive = null vm._directInactive = false vm._isMounted = false vm._isDestroyed = false vm._isBeingDestroyed = false&#125; 这里主要初始化了以下关系： $root $parent $children $refs initEvents(vm)文件位置：src/core/instance/events.js 123456789export function initEvents(vm: Component) &#123; vm._events = Object.create(null) vm._hasHookEvent = false // init parent attached events const listeners = vm.$options._parentListeners if (listeners) &#123; updateComponentListeners(vm, listeners) &#125;&#125; 这里初始化了事件的监听者。 initRender(vm)文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function initRender(vm: Component) &#123; vm._vnode = null // the root of the child tree vm._staticTrees = null // v-once cached trees const options = vm.$options const parentVnode = (vm.$vnode = options._parentVnode) // the placeholder node in parent tree const renderContext = parentVnode &amp;&amp; parentVnode.context vm.$slots = resolveSlots(options._renderChildren, renderContext) vm.$scopedSlots = emptyObject // bind the createElement fn to this instance // so that we get proper render context inside it. // args order: tag, data, children, normalizationType, alwaysNormalize // internal version is used by render functions compiled from templates vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) // normalization is always applied for the public version, used in // user-written render functions. vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) // $attrs &amp; $listeners are exposed for easier HOC creation. // they need to be reactive so that HOCs using them are always updated const parentData = parentVnode &amp;&amp; parentVnode.data /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive( vm, &#x27;$attrs&#x27;, (parentData &amp;&amp; parentData.attrs) || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$attrs is readonly.`, vm) &#125;, true ) defineReactive( vm, &#x27;$listeners&#x27;, options._parentListeners || emptyObject, () =&gt; &#123; !isUpdatingChildComponent &amp;&amp; warn(`$listeners is readonly.`, vm) &#125;, true ) &#125; else &#123; defineReactive(vm, &#x27;$attrs&#x27;, (parentData &amp;&amp; parentData.attrs) || emptyObject, null, true) defineReactive(vm, &#x27;$listeners&#x27;, options._parentListeners || emptyObject, null, true) &#125;&#125; 这里主要初始化了两个方法： $slots $createElement callHook(vm, ‘beforeCreate’)一直到这里，都处于 Vue 生命周期中的 beforeCreate，而上面的代码中完全没有对 data 的处理，所以在 beforeCreate 中显然是无法获取到 data 的。 initInjections(vm)文件位置：src/core/instance/inject.js 12345678910111213141516171819202122export function initInjections(vm: Component) &#123; const result = resolveInject(vm.$options.inject, vm) if (result) &#123; toggleObserving(false) Object.keys(result).forEach((key) =&gt; &#123; /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; defineReactive(vm, key, result[key], () =&gt; &#123; warn( `Avoid mutating an injected value directly since the changes will be ` + `overwritten whenever the provided component re-renders. ` + `injection being mutated: &quot;$&#123;key&#125;&quot;`, vm ) &#125;) &#125; else &#123; defineReactive(vm, key, result[key]) &#125; &#125;) toggleObserving(true) &#125;&#125; 这里注入了祖辈中的数据，以便在后面接收。 initState(vm)文件位置：src/core/instance/state.js 123456789101112131415export function initState(vm: Component) &#123; vm._watchers = [] const opts = vm.$options if (opts.props) initProps(vm, opts.props) if (opts.methods) initMethods(vm, opts.methods) if (opts.data) &#123; initData(vm) &#125; else &#123; observe((vm._data = &#123;&#125;), true /* asRootData */) &#125; if (opts.computed) initComputed(vm, opts.computed) if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch) &#125;&#125; 可以看到，这里初始化了我们熟知的对象： props methods data computed watch 从流程也可以看到，data 是晚于 props，先于 computed 的，这也能解决平时很多困扰我们的问题。 initProvide(vm)文件位置：src/core/instance/inject.js 123456export function initProvide(vm: Component) &#123; const provide = vm.$options.provide if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide &#125;&#125; 这里对前面注入的数据进行了接收。 callHook(vm, ‘created’)这里调用生命钩子，说明到 created 阶段，组件已经成功创建，所以初始化工作已经完成。 下面贴上脑图，方便大家参考： 接下来我们回到构造函数，看看剩下的 Mixin 都做了些什么： 12345initMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)renderMixin(Vue) initMixin() 上面刚分析完，同样的，我们一步一步来看看下面的 Mixin 都做了些什么吧！ stateMixin(Vue)文件位置：src/core/instance/state.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546export function stateMixin(Vue: Class&lt;Component&gt;) &#123; // flow somehow has problems with directly declared definition object // when using Object.defineProperty, so we have to procedurally build up // the object here. const dataDef = &#123;&#125; dataDef.get = function () &#123; return this._data &#125; const propsDef = &#123;&#125; propsDef.get = function () &#123; return this._props &#125; if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; dataDef.set = function () &#123; warn(&#x27;Avoid replacing instance root $data. &#x27; + &#x27;Use nested data properties instead.&#x27;, this) &#125; propsDef.set = function () &#123; warn(`$props is readonly.`, this) &#125; &#125; Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef) Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef) Vue.prototype.$set = set Vue.prototype.$delete = del Vue.prototype.$watch = function (expOrFn: string | Function, cb: any, options?: Object): Function &#123; const vm: Component = this if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125; options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value) &#125; catch (error) &#123; handleError(error, vm, `callback for immediate watcher &quot;$&#123;watcher.expression&#125;&quot;`) &#125; &#125; return function unwatchFn() &#123; watcher.teardown() &#125; &#125;&#125; 其实顾名思义，已经能大致猜到这里的功能了（ps：这也是一个好的命名规范带来的好处）。不过这里还是结合代码分析，这里扩展了以下功能： $data $props $set $delete $watch eventsMixin(Vue)文件位置：src/core/instance/events.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export function eventsMixin(Vue: Class&lt;Component&gt;) &#123; const hookRE = /^hook:/ Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; ;(vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm &#125; Vue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on() &#123; vm.$off(event, on) fn.apply(vm, arguments) &#125; on.fn = fn vm.$on(event, on) return vm &#125; Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // all if (!arguments.length) &#123; vm._events = Object.create(null) return vm &#125; // array of events if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$off(event[i], fn) &#125; return vm &#125; // specific event const cbs = vm._events[event] if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null return vm &#125; // specific handler let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; return vm &#125; Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event &quot;$&#123;lowerCaseEvent&#125;&quot; is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for &quot;$&#123;event&#125;&quot;. ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use &quot;$&#123;hyphenate(event)&#125;&quot; instead of &quot;$&#123;event&#125;&quot;.` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) const info = `event handler for &quot;$&#123;event&#125;&quot;` for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; invokeWithErrorHandling(cbs[i], vm, args, vm, info) &#125; &#125; return vm &#125;&#125; 这里是扩展事件相关的方法： $on $once - 这个方法在平时业务开发中非常少用 $off $emit lifecycleMixin(Vue)文件位置：src/core/instance/lifecycle.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182export function lifecycleMixin(Vue: Class&lt;Component&gt;) &#123; Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook. &#125; Vue.prototype.$forceUpdate = function () &#123; const vm: Component = this if (vm._watcher) &#123; vm._watcher.update() &#125; &#125; Vue.prototype.$destroy = function () &#123; const vm: Component = this if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;) vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm) &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown() &#125; let i = vm._watchers.length while (i--) &#123; vm._watchers[i].teardown() &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount-- &#125; // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;) // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null &#125; &#125;&#125; 这里扩展了生命周期相关的方法： _update：这是核心的更新函数 $forceUpdate $destroy renderMixin(Vue)文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364export function renderMixin(Vue: Class&lt;Component&gt;) &#123; // install runtime convenience helpers installRenderHelpers(Vue.prototype) Vue.prototype.$nextTick = function (fn: Function) &#123; return nextTick(fn, this) &#125; Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode &#125;&#125; 这里是扩展了渲染相关的方法： $nextTick：这个方法非常有意思，后面将深入分析 _render 老规矩，上脑图： 如果写一个测试 demo 调试，会发现，当上面的流程都执行完成之后，页面中还没有渲染出对应的内容，这是因为还没有执行 vue 初始化最重要的一步：挂载。接下来就来看看 vue 中是如何进行挂载的。 相信大家对前面提到的流程熟悉的话，对 mount 应该有一定的印象：打包入口文件中最重要的功能就是扩展 mount。 挂载通过基本分析，我们可以找到实现 mount 的位置：src/platforms/web/runtime/index.js ： 1234Vue.prototype.$mount = function (el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 可以看到，是 mountComponent 这个方法实现了 mount 的核心功能，让我们追进去看看。 文件位置：core/instance/lifecycle.js ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071export function mountComponent(vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ) &#125; else &#123; warn(&#x27;Failed to mount component: template or render function not defined.&#x27;, vm) &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;) let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher( vm, updateComponent, noop, &#123; before() &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125;, &#125;, true /* isRenderWatcher */ ) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, &#x27;mounted&#x27;) &#125; return vm&#125; 上面的流程并不复杂： 首先调用了 beforeMount 钩子 随后调用了 updateComponent 进行组件的更新 然后创建了一个 Wathcer，并在其中调用了 beforeUpdate 钩子 最后调用 mounted 钩子 从流程可以看出，挂载的核心功能应该是在 updateComponent 进行的，而它的核心功能就是先执行 _render()，后执行 _update()。 而这两个方法，我们进入看看： _render()文件位置：src/core/instance/render.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots) &#125; // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode try &#123; // There&#x27;s no need to maintain a stack because all render fns are called // separately from one another. Nested component&#x27;s render fns are called // when parent component is patched. currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // return error render result, // or previous vnode to prevent render error causing blank component /* istanbul ignore else */ if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; finally &#123; currentRenderingInstance = null &#125; // if the returned array contains only a single node, allow it if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123; vnode = vnode[0] &#125; // return empty vnode in case the render function errored out if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; Array.isArray(vnode)) &#123; warn( &#x27;Multiple root nodes returned from render function. Render function &#x27; + &#x27;should return a single root node.&#x27;, vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 这里经过一系列的处理，主要是为了得到虚拟 dom _update()文件位置：src/core/instance/lifecycle.js 123456789101112131415161718192021222324252627282930Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; restoreActiveInstance() // update __vue__ reference if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; 这里最核心的功能是 __patch__，即将虚拟 dom 转化为真实 dom。 脑图如下： 调试验证前面一通分析，挺有道理，但只是理论如此，不稳，这里我们通过调试器一步步执行，来验证一下我们的想法是否正确： Step 1 - 确定初始化函数测试 demo 就不贴出来了，随便一个 vue 样例都行，我们从 new Vue() 处进入即可： 显然，这里只会执行 _init，也即是说这就是初始化函数，也验证了上面的猜想。 Step 2 - 验证执行流程前面猜测执行 initState(Vue) 之前是无法访问到 data 数据的，这个也很好验证，我们先看看执行之前的 vm： 可以看到，这个时候 data 和 props 都还无法访问，接下来单步执行 initState(Vue)，再看看结果： 显然，这个时候 data 已经有值了，而 props 之所以还是 undefined，是因为这里本就没有父组件进行传值。 Step 3 - 验证挂载同样，我们现在将断点定在 updateComponent 即可，执行 _update 之前： 执行 _update 之后： 上面的结果与我们分析 vue 源码得来的结论无异，这能很好的提升士气和信心，为接下来的源码学习之旅打下不错的基础。 那么本篇的粗浅分析到此为止，剩下的来日再议论吧！ 咕咕咕~ 🐥 🐥 🐥 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 一：初始化流程","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Vue 2.6 源码分析之旅【0】 —— 调试环境搭建","slug":"2020-08-12","date":"2020-08-12T08:49:54.841Z","updated":"2020-08-12T08:49:54.841Z","comments":false,"path":"2020/08/12/2020-08-12/","link":"","permalink":"http://yoursite.com/2020/08/12/2020-08-12/","excerpt":"以前很多 vue 原理相关的知识，比如响应式，比如虚拟 dom，比如 diff 算法……但都没有真正深入的看过源码，正因为此，这些知识宛如空中楼阁，空洞且并没有什么说服力。所以今天开始对 vue 进行粗浅的源码分析。 要分析源码，自然首先要搭建调试环境，这样才可以通过编写测试 demo 快速定位到我们想要分析的位置。 那么开始吧！","text":"以前很多 vue 原理相关的知识，比如响应式，比如虚拟 dom，比如 diff 算法……但都没有真正深入的看过源码，正因为此，这些知识宛如空中楼阁，空洞且并没有什么说服力。所以今天开始对 vue 进行粗浅的源码分析。 要分析源码，自然首先要搭建调试环境，这样才可以通过编写测试 demo 快速定位到我们想要分析的位置。 那么开始吧！ Step 1 - 克隆源码1git clone git@github.com:vuejs/vue.git Step 2 - 安装环境12npm install // 安装到 phantom 时就可以终止了npm install rollup -g Step 3 - 修改运行参数文件：root/pakage.json 12- &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;+ &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot; Step 4 - 编译源码1npm run dev Step 5 - 测试调试流程到这里，如果在 root/dist 目录下新生成了一个 vue.js.map 文件，则说明应该已经成功建立了 map 映射关系，这里在 root/examples/test-demo 下建立一个测试文件： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=&quot;../../dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;demo&quot;&gt; &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; const app = new Vue(&#123; el: &#x27;#demo&#x27;, data: &#123; name: &#x27;vue&#x27; &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开这个页面，在浏览器中进行调试，将断点定在创建实例的这一行： 成功断下来之后，按 f11 进入函数，然后在点击鼠标右键，选择：Reveal in sidebar，如果左侧侧边栏中出现 vue 的目录结构，则说明调试环境已经搭建成功： 结语更佳阅读体验：Vue 2.6 源码分析之旅 - 零：调试环境搭建","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【3】 —— mvvm","slug":"2020-08-10","date":"2020-08-11T02:17:56.653Z","updated":"2020-08-11T02:17:56.653Z","comments":false,"path":"2020/08/11/2020-08-10/","link":"","permalink":"http://yoursite.com/2020/08/11/2020-08-10/","excerpt":"今天我们来研究一下 vue2 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》","text":"今天我们来研究一下 vue2 的响应式实现原理。 这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》 思路整理首先来看看官网给出的示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这个例子很好的展示了 mvvm 的核心功能： 数据驱动视图更新 再结合代码看看，我们发现这里的定义并不复杂，仅仅是： el：指定跟节点 data：定义响应式数据 插值表达式：渲染变量 v-xxx：vue 指令 从上面我们能得到什么信息呢？ 显然，我们要对节点进行解析，解析其中的插值表达式和 v-xxx 指令，这个功能我们可以叫它 Compiler。然后我们还需要对 data 中的数据进行劫持，当其中的数据发生 get/set 的时候，能够进行自定义的操作，这个功能我们叫它 Observer。最后我们需要监听这些数据，当他们发生改变的时候，通知视图去进行更新操作，这个功能我们叫它 Watcher。 这里引用一下大佬的图： 可以看到，除了上面我们提到的三个模块以外，这里还多了 Updater 和 Dep，Updater 倒还好理解，但这 Dep 是干嘛的呢？ 我们知道，data 和 view 中的显示存在多对多的关系，如下： 123456789101112131415;&lt;div id=&quot;app&quot;&gt; &lt;p&gt;1: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;2: &#123;&#123; data_1 &#125;&#125;&lt;/p&gt; &lt;p&gt;3: &#123;&#123; data_2 &#125;&#125;&lt;/p&gt; &lt;p&gt;4: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt; &lt;p&gt;5: &#123;&#123; data_3 &#125;&#125;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; data_1: 1, data_2: 2, data_3: 3, &#125;,&#125;) 上面的代码中： 当 data_1 发生改变的时候，p1 和 p2 都要重新渲染 当 data_2 发生改变的时候，p3 要重新渲染 当 data_3 发生改变的时候，p4 和 p5 都要重新渲染 显然这需要被控制管理起来，否则视图的更新肯定是一团乱，而 Dep 就是用来做这个的，我们可以看看下面这张图： 从上图可以看到： view 中每一个需要被渲染的值对应一个 Watcher 每一个响应式变量对应一个 Dep 那么更新流程就应该是这样：当是数据更新的时候，Observer 通知对应的 Dep，然后 Dep 通知自己管理的 Watcher 调用 Updater 进行视图的更新。 当然，最后我们需要一个入口作为桥梁，将上面的各个模块给联系起来，组合成一个完整的 mvvm 框架。 大致的思路已经有了，那么开始吧，it’s show time！ 功能实现Entry首先再来看看官方示例： 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;) 这里 new 了一个 Vue，并且只传了一个 obj 进去，那么我们最终对外暴露的对象也应当如此。 总所周知，vue 是法语视图的意思，那么这里就用它的好朋友来作为命名语言吧 123456789export default Aus &#123; constructor(options = &#123;&#125;)&#123; this.$options = options; this.$el = options.el; this.$data = options.data; if (!this.$el) throw new Error(&quot;请指定挂载点&quot;); &#125;&#125; 接下来我们就来实现模板的解析。 Compiler我们来分析一下 Compiler 需要做什么： 通过 el 获取需要被编译的 root 节点 进行模板编译 将编译后的节点覆盖到 root 节点的位置 而模板编译应该怎么进行呢？ 首先我们可以将节点碎片化，在内存中处理 遍历当前的节点树，这里我们只关注两类节点： 元素节点：处理 a-xxx 指令 文本节点：处理插值表达式 将编译好的节点碎片 append 到 root 节点上 那么我们的问题就来到了如何处理文本和元素节点： 元素节点：node.attributes 文本节点：正则表达式 进过上面一通分析，整个结构已经比较清晰了，这里再补上脑图： 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;p&gt;单层：&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;p a-text=&quot;msg&quot;&gt;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt; import Aus from &#x27;./aus.js&#x27; const am = new Aus(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello Aussicht!&#x27;, &#125; &#125;)&lt;/script&gt; 效果如下： 可以看到，这里已经成功将 a-text 和插值表达式替换成了我们想要渲染的变量了。 接下来我们想要实现的效果是当数据发生改变的时候，视图也随之更新，那么首先应该实现的是 Observer。 Observer同样的，我们来分析一下 Observer 需要做什么。 事实上，仅仅考虑数据劫持这一层面的话，Observer 需要实现的功能非常简单，就是利用 Object.defineProperty 对 data 进行代理即可。 流程很简单： 获取 data 的所有 key，对其进行劫持 如果 data 的 key 为 obj，则递归 脑图如下： 本文主要是简单探讨一下 mvvm 实现原理，这里对于数组就不做处理了。 代码很简单，按照上面的思路进行实现即可： 12345678910111213141516171819202122232425262728293031323334353637import Dep from &#x27;./dep.js&#x27;class Observer &#123; constructor(data) &#123; this.data = data this.observe(this.data) &#125; observe(data) &#123; if (data &amp;&amp; typeof data === &#x27;object&#x27;) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]) &#125;) &#125; &#125; defineReactive(obj, key, value) &#123; this.observe(value) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: false, get: (_) =&gt; &#123; return value &#125;, set: (newVal) =&gt; &#123; // 对新设置的值进行监听 this.observe(newVal) if (newVal !== value) &#123; value = newVal &#125; return true &#125;, &#125;) &#125;&#125;export default Observer 接下来就是最关键的，当数据发生改变的时候，通知视图进行更新渲染了。 Watcher &amp;&amp; Dep这里我们一步步分析一下： Watcher 一一对应模板中的变量（插值表达式 or a-text） Dep 对应具体变量 Observer 能发出通知 只有当变量发生改变的时候，模板中对应的地方需要发生重新渲染，所以流程应该是： Observer 通知 Dep，变量发生改变 Dep 管理了一个 Watcher 数组，执行 Watcher 的 update 方法，更新视图 那么现在的问题是，怎么建立 Dep 和 Watcher 的关系。 显然，模板中每有一个需要渲染的值，就应该有一个对应的 Watcher，而这个值在初始化的时候会进行 get 操作，那么自然是在 get 中进行操作最合适： 同样，在修改值得之后会进行 set 操作，那么在 set 的时候利用 dep 通知 Watcher 进行操作也最合适。 综上： Dep 至少需要管理一个 Watcher 数组，一个添加 Watcher 的方法，一个通知 Watcher 更新视图的方法 Watcher 在初始化的时候创建，管理 Update 方法 脑图如下： 那么这里，首先我们需要改造一下 Compiler，在渲染模板的时候创建 Watcher： 123456789101112131415161718192021222324const compileUtil = &#123; text(node, exp, am) &#123; const value = this.getValue(exp, am) const updaterFn = (node, value) =&gt; &#123; node.textContent = value &#125; updaterFn &amp;&amp; updaterFn(node, value) new Watcher() &#125;, getValue(exp, am) &#123; return exp.split(&#x27;.&#x27;).reduce((d, c) =&gt; d[c], am.$data) &#125;, setValue(exp, am, value) &#123; exp.split(&#x27;.&#x27;).forEach((k, i) =&gt; &#123; if (i &lt; exp.length - 1) &#123; am = am[k] &#125; else &#123; am[k] = value &#125; &#125;) &#125;,&#125; 因为我们后期不可能只处理 a-text 指令，所以这里可以对工具方法进行一些封装优化： 12345678910111213141516171819202122232425262728293031323334const compileUtil = &#123; text(node, exp, am) &#123; this.bind(node, exp, am, &#x27;text&#x27;) &#125;, bind(node, exp, am, dir) &#123; const value = this.getValue(exp, am) const updaterFn = updaterUtil[dir] updaterFn &amp;&amp; updaterFn(node, value) new Watcher() &#125;, getValue(exp, am) &#123; return exp.split(&#x27;.&#x27;).reduce((d, c) =&gt; d[c], am.$data) &#125;, setValue(exp, am, value) &#123; exp.split(&#x27;.&#x27;).forEach((k, i) =&gt; &#123; if (i &lt; exp.length - 1) &#123; am = am[k] &#125; else &#123; am[k] = value &#125; &#125;) &#125;,&#125;const updaterUtil = &#123; text(node, value) &#123; node.textContent = value &#125;,&#125;export default compileUtil 因为这里我们通过 getValue 获取了 data 中的值，所以必然会触发 get 操作，那么就来到了 Observer 中。 前面我们一直反复提到，一个变量对应一个 Dep，所以这里我们在 defineReactive 中创建 dep 实例，在 get 中调用 dep 的 addWatcher 方法： 123456789101112131415class Observer &#123; /*...*/ defineReactive(obj, key, value) &#123; /*...*/ const dep = new Dep() Object.defineProperty(obj, key, &#123; get: (_) =&gt; &#123; dep.addWatcher(Watcher) return value &#125;, /*...*/ &#125;) &#125;&#125; 同样的，在 set 中调用 dep 的 notify 方法： 12345678910111213141516171819class Observer &#123; /*...*/ defineReactive(obj, key, value) &#123; /*...*/ const dep = new Dep() Object.defineProperty(obj, key, &#123; /*...*/ set: (newVal) =&gt; &#123; // 对新设置的值进行监听 this.observe(newVal) if (newVal !== value) &#123; value = newVal dep.notify() &#125; &#125;, &#125;) &#125;&#125; 上面的代码中还存在一个问题，在 get 中有一行代码： 1dep.addWatcher(Watcher) 这个 Watcher 从哪里来呢？ 那么我们来到 Watcher。 Watcher 需要什么呢？这个我们知道它的功能就很清楚了： 它需要获取当前的 data 值，所以需要 am 实例，以及值对应的 key 它需要更新视图，所以需要 update 回调函数 那么构造函数如下： 12345678class Watcher &#123; constructor(am, exp, cb) &#123; this.am = am this.exp = exp this.cb = cb this.oldValue = this.getOldValue() &#125;&#125; 而在执行 getOldValue 的时候，我们可以做一些灵活的小操作： 因为 getOldValue 必定触发 get，所以我们可以在 get 之前将 Watcher 挂载到 Dep 上，在 get 之后清空即可，这样就可以在 get 中获取到 Watcher 了。 123456789class Watcher &#123; /*...*/ getOldVal() &#123; Dep.target = this const oldVal = compileUtil.getValue(this.exp, this.am) Dep.target = null return oldVal &#125;&#125; Watcher 的功能是在 value 变化的时候进行视图更新，自然还需要一个 updater 方法，而这个方法只需要在 oldValue ≠ newValue 的时候调用回调函数更新视图即可： 123456789class Watcher &#123; /*...*/ updater() &#123; const newValue = compileUtil.getValue(this.exp, this.am) if (this.oldValue !== newValue) &#123; this.cb(newVal) &#125; &#125;&#125; 那么创建 Watcher 的时候，参数也很好填了： 123456789101112const compileUtil = &#123; /*...*/ bind(node, exp, am, dir) &#123; /*...*/ const value = this.getValue(exp, am) const updaterFn = updaterUtil[dir] updaterFn &amp;&amp; updaterFn(node, value) new Watcher(am, exp, (value) =&gt; &#123; updaterFn &amp;&amp; updaterFn(node, value) &#125;) &#125;,&#125; Watcher 搞定了，那么管理 Watcher 的 Dep 就很简单了： 12345678910111213class Dep &#123; constructor() &#123; this.watchers = [] &#125; addWatcher(w) &#123; this.watchers.push(w) &#125; notify() &#123; this.watchers.forEach((w) =&gt; &#123; w.updater() &#125;) &#125;&#125; 再修改一下 Observer 中的 get，这样整个流程就都通了： 1234get: (_) =&gt; &#123; Dep.target &amp;&amp; dep.addWatcher(Dep.target) return value&#125; 效果如下所示： 结语更加阅读体验：手写简易 MVVM","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【2】 —— vuex","slug":"2020-08-07_3","date":"2020-08-10T08:14:02.776Z","updated":"2020-08-10T08:14:02.776Z","comments":false,"path":"2020/08/10/2020-08-07_3/","link":"","permalink":"http://yoursite.com/2020/08/10/2020-08-07_3/","excerpt":"今天我们来研究一下 vuex 的内部实现原理。我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程","text":"今天我们来研究一下 vuex 的内部实现原理。我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：Flux 架构入门教程 Step 1 - 需求分析首先用 vue-cli 4.x 创建一个空项目，选择使用 vuex，等项目创建好之后，在 src 目录下应该存在一个 store 文件，其内容大致如下： 12345678910111213141516171819202122import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;, actions: &#123; add(&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit(&#x27;add&#x27;) &#125;, 1000) &#125;, &#125;,&#125;) 使用过状态管理库的同学应该很清楚 action 主要用于处理异步操作，那么这里我们暂时先不关心它，把同步操作处理完之后再来看它就会清晰很多了： 123456789101112131415import Vue from &#x27;vue&#x27;import Vuex from &#x27;./yvuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; counter: 0, &#125;, mutations: &#123; add(state, num = 1) &#123; state.counter += num &#125;, &#125;,&#125;) 从上述代码，我们可以分析出以下几点： 首先 vuex 是 vue 的插件，首先会 use，在这个时候调用其 install 方法 通过 new 新建实例的是 vuex 上的 store 对象而非 vuex 本身 导出的 store 会在 main 中传给 vue（这一部分在 main 中，而不在上述代码中） 那么我们的 vuex 应该如何设计呢？ 我认为应该结合 vuex 的使用来进行分析： 我们知道，在项目中使用 vuex 的时候，通常形如： 123this.$store.state.xxxthis.$store.commit(&#x27;xxx&#x27;)// this.$store.dispatch(&#x27;xxx&#x27;) 异步，暂不考虑 显然，首先我们需要把 store 挂载到 vue 实例上，其次，store 上还应该有 state 和 commit，它们两分别是一个 object 和一个 function。 此时的思维导图如下所示： Step 2 - 功能实现基础功能那么我们按照这样的方式构建 vuex： 123456789101112131415161718// export default Vuexexport default &#123; install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.store) &#123; Vue.prototype.$store = this.$options.store &#125; &#125;, &#125;) &#125;, Store: class Store &#123; constructor() &#123; this.state = &#123;&#125; &#125; commit() &#123;&#125; &#125;,&#125; 接下来我们再回到 store 中，可以看到在创建 store 实例的时候，我们传递了两个对象： state：用于存储状态 mutations：用于同步修改状态 也就是说，在构建实例的过程中，我们将 state 存储到 $store.state 中，将 mutations 存储起来，在 commit 的时取出调用，思维导图如下： 那么我们对应实现的代码应该是： 12345678910111213export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this.state = options.state &#125; commit(type, payload) &#123; const mutation = this._mutations[type] return mutation(this.state, payload) &#125; &#125;,&#125; 这个时候，已经能从 this.$store.state 中取出 counter 了： 并且 commit 也能成功调用了： 但这里还有问题，最关键的就是 counter 的改变并没有引起页面的重新渲染。显然我们应该将 state 改成响应式数据，在 手写简易 vue-router 中我们使用了 vue 官方提供的静态方法：Vue.util.defineReactive 那么这里我们就尝试使用另一个办法来实现响应式数据：创建 vue 实例，利用其中的 data 方法将 state 转化为响应式数据，实际代码如下： 123456789101112131415161718192021222324export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; this._mutations = options.mutations this._vm = new _Vue(&#123; data() &#123; return &#123; // 由于不希望数据被代理，所以这里加上 $ $$state: options.state, &#125; &#125;, &#125;) &#125; get state() &#123; return this._vm._data.$$state &#125; set state(value) &#123; // 不允许直接修改 state console.error(&#x27;please use replaceState to reset state&#x27;) &#125; /*...*/ &#125;,&#125; 现在我们再看看效果如何： 至此，一个最最基础的 store 已经基本实现了，接下来自然是异步操作的 action 了。 异步操作其实明白了 mutations，actions 也已经清楚了大半，唯一的区别就是 action 中我们需要调用 commit 来修改 state，那么这个 commit 从哪里来自然就很清楚了：this 导图如下： 实现代码如下： 1234567891011121314export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._actions = options.actions &#125; /*...*/ dispatch(type, payload) &#123; const action = this._actions[type] return action(this, payload) &#125; &#125;,&#125; nice，非常完美，我们来看看效果： 报错了？ 这是为什么呢？ 于是跟踪调试一番，发现如下情况： this 没了，再看看 action： 显然，这里因为是在 setTimeout 中调用 commit，丢失了 this，所以我们在构建实例的时候进行绑定就可以啦。 这下就没有问题了。 扩展 - gettter我们已经实现了基础的 vuex，而平时使用 vuex 的时候，大家知道 getter 也是经常被使用到的。 那么这个 getter 应当如何实现呢？ 我们假设在创建 vuex 的时候传入 getter，里面只有一个值，是 doubleCounter，返回值是 counter * 2，那么自然 doubleCounter 是被 counter 所影响，我们这里可以画出如下导图： 那么问题来了：怎么将 getter 和 state 关联起来呢？ 仔细想一想，显然这里是做代理，那么答案就呼之欲出了：Object.defineProperty。有了这个核心思想之后，我们继续分析，由于 getter 不止一个，那么我们肯定需要遍历传入的 getter obj，将其注册到 store 上。 我们可以先来实现这一步操作： 1234567891011121314151617181920212223export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this._getters = options.getters this.= Object.create(null) this.forEachGetter(this, this._getters) &#125; /*...*/ forEachGetter(store, getters) &#123; Object.keys(getters).forEach((key) =&gt; &#123; const getter = getters[key] this.registerGetter(store, getter, key) &#125; &#125; registerGetter(store, getter, key)&#123; store._wrappedGetters[key] = function wrappedGetter(store)&#123; return getter(store.state) &#125; &#125; &#125;,&#125; 执行完这一步之后，我们可以调试看看： 可以看到，store 上的属性 _wrappedGetters 中现在包含两个属性： doubleCounter：这是一个函数，即 registerGetter 中返回的 wrappedGetter，当我们调用它的时候，会返回 getter(store.state) 执行的结果，及 state.counter * 2 state：这里是响应式数据（不过现在还不是响应式的） 现在已经建立好了 options.getter 和 store._wrappedGetters 的映射关系，我们可以开始通过 Object.defineProperty 来做代理了： 123456789101112131415161718192021222324252627282930export default &#123; /*...*/ Store: class Store &#123; constructor(options) &#123; /*...*/ this.resetStoreVm(this, options.state) &#125; /*...*/ resetStoreVm(store, state) &#123; store.getters = &#123;&#125; const computed = &#123;&#125; const wrappedGetters = store._wrappedGetters Object.keys(wrappedGetters).forEach((key) =&gt; &#123; computed[key] = this.partial(wrappedGetters[key], store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], &#125;) &#125;) this._vm = new _Vue(&#123; data() &#123; return &#123; $$state: state, &#125; &#125;, // ! 计算属性，用于实现 getter computed: computed, &#125;) &#125; partial = (fn, arg) =&gt; () =&gt; fn(arg)&#125; 上面的代码，比较有容易搞不清楚的就两个地方： wrappedGetters[key] 是什么 partial 返回值是什么 这个问题直接在调试器里看看就清楚了： 显然，这两位，一个是 getter 的包裹函数，一个是其本身。 到这里，getter 也算是基本实现了，具体效果如下： 结语更佳阅读体验：手写简易 vuex","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"前端造轮子【1】 —— vue-router","slug":"2020-08-07_2","date":"2020-08-10T08:13:19.038Z","updated":"2020-08-10T08:13:19.038Z","comments":false,"path":"2020/08/10/2020-08-07_2/","link":"","permalink":"http://yoursite.com/2020/08/10/2020-08-07_2/","excerpt":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。","text":"今天我们来研究一下 vue-router 的内部实现原理。 我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？ 通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案： hash（就是页面上的 #） history（h5） 今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。 Step 1 - 需求分析首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。 项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下： 123456789101112131415161718192021222324import Vue from &#x27;vue&#x27;import VueRouter from &#x27;./yvue-router&#x27;import Home from &#x27;../views/Home.vue&#x27;Vue.use(VueRouter)const routes = [ &#123; path: &#x27;/&#x27;, name: &#x27;Home&#x27;, component: Home, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;About&#x27;, component: () =&gt; import(&#x27;../views/About.vue&#x27;), &#125;,]const router = new VueRouter(&#123; routes,&#125;)export default router 我们逐步来分析一下上面的代码： 首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 VueRouter 是 Vue 的插件，需要有自己的静态 install 方法 接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系 然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出 最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身 上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？ 首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？ 联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件： router-view：用于显示组件 router-link：用于路由跳转 显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。 接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。 以上，我们可以大致总结一下，如下图所示： Step 2 - 功能实现那么现在我们可以着手开始实现自己的 vue-router 了。 首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化： 1234567class VueRouter &#123; // 对应 Vue.use static install(Vue) &#123;&#125; // 对应 new constructor(options) &#123;&#125;&#125; 紧接着我们就可以在 install 中实现对两个全局组件的注册： 123456789101112131415161718192021222324252627282930313233343536373839404142class VueRouter &#123; // 对应 Vue.use static install(Vue)&#123; // step 1: 注册组件 router-link，用于路由跳转 // 回忆一下 router-link 的使用： // * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt; Vue.component(&#x27;router-link&#x27;, &#123; // 必要参数 to props: &#123; to: &#123; type: String, require: true, &#125;, &#125;, // 模板，可以使用 template，也可以使用 render。 // * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。 render() &#123; // 这里可以写 jsx，也可以使用 h 函数 // 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下 // * h 函数类似于 react 中的 createElement return &lt;a href=&#123;`#$&#123;this.to&#125;`&#125;&gt;&#123;this.$slots.default&#125;&lt;/a&gt; &#125; // step 2: 注册组件 router-view，用于显示组件 // 回忆一下 router-link 的使用： // &lt;router-view /&gt; Vue.component(&#x27;router-view&#x27;, &#123; // 没有参数，直接 template render(h) &#123; // 这里使用 h // view-router 的功能是渲染组件，那么组件从哪里获取呢？ // 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取 // 而当前路由我们可以在构造函数中定义一个 current 来表示 // 所以可以通过以下代码找到当前 current 对应的组件 const &#123; routeMap, current &#125; = this.$router const component = routeMap[current] ? routeMap[current].component : null return h(component) &#125;, &#125;) &#125; /*...*/&#125; 到这里，至少我们的 已经是可用的了，而 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。 那么接下来自然是实现 constructor 12345678910111213141516171819202122class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const current = window.location.hash.slice(1) || &#x27;/&#x27; // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件： 那应该怎么办呢？ 接下来的问题是：怎么将 current 转成 vue 响应式数据？ 对于上述问题，这里有两个思路： 新建 vue 实例，通过 data 将 current 转成响应式数据 利用 vue 提供的静态方法 Vue.util.defineReactive 这里我们采取第二种方案： 1234567891011121314151617181920212223class VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里又出现一个问题，这个 Vue 从哪里来呢？ 其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了： 12345678910111213141516171819202122232425let _Vueclass VueRouter &#123; /*...*/ // 对应 new constructor(options) &#123; // 初始化路由表 this.routerMap = &#123;&#125; options.routes.map((route) =&gt; &#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this)) &#125; onHashChange() &#123; this.current = window.location.hash.slice(1) &#125;&#125; 到这里，基本的路由已经实现了： 还有一些可以扩展的地方： 比如优化一下 constructor，将 options 保存到本地： 123456789101112131415constructor(options)&#123; this.$options = options // 初始化路由表 this.routerMap = &#123;&#125; this.$options.routes.map((route)=&gt;&#123; this.routerMap[route.path] = route &#125;) // 定义 current const initial = window.location.hash.slice(1) || &#x27;/&#x27; _Vue.util.defineReactive(this, &#x27;current&#x27;, initial) // 监听 hashchange window.addEventListener(&#x27;hashchange&#x27;, this.onHashChange.bind(this))&#125; 这可以保证数据的单向流动。 比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。 不过这里有一个点值得注意，那就是时间： 因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过： 1Vue.prototype.$router = this.$options.router 进行挂载显然是不行的。 这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作： 1234567Vue.mixin(&#123; beforeCreate() &#123; if (this.$options.router) &#123; Vue.prototype.$router = this.$options.router &#125; &#125;,&#125;) 这样就没什么问题了。 结语更佳阅读体验：手写简易 vue-router","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【2】 —— 网站配置","slug":"2020-08-07_1","date":"2020-08-07T03:29:03.057Z","updated":"2020-08-07T03:10:32.504Z","comments":false,"path":"2020/08/07/2020-08-07_1/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-07_1/","excerpt":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。","text":"前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。 站点配置目标文件：root/ _config.yml 1234title: 世界的侧面subtitle: &#x27;&#x27;author: 初心Yearthfavicon: https://s1.ax1x.com/2020/08/06/agXE9K.png 主题配置目标文件：root/themes/volantis/_config.yml 封面配置12345cover: M title: &#x27;标题&#x27; M # subtitle: &#x27;&#x27; M search: 你想看点什么呢？ M # features: // 这个选项是搜索框下的导航按钮，这里选择注释掉 导航栏配置12345678910111213141516171819202122232425navbar: logo: img: icon: title: &#x27;标题&#x27; menu: M # - name: 博客 M # icon: fas fa-rss M # url: / - name: 分类 icon: fas fa-tags url: tags/ - name: 标签 icon: fas fa-tags url: tags/ M # - name: 归档 M # icon: fas fa-archive M # url: archives/ M # - name: 友链 M # icon: fas fa-link M # url: friends/ - name: 关于 icon: fas fa-info-circle url: about/ search: 你想看点什么呢？ 布局配置123layout:on_page:M body: [article] 插件配置123456plugins:backstretch:M position: fixedaplayer:M id: 170672512M autoplay: true 最终效果","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}},{"title":"Github + Hexo 爬坑之旅【1】 —— 基础搭建","slug":"2020-08-06","date":"2020-08-07T03:10:56.541Z","updated":"2020-08-07T03:10:56.541Z","comments":false,"path":"2020/08/07/2020-08-06/","link":"","permalink":"http://yoursite.com/2020/08/07/2020-08-06/","excerpt":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。","text":"没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。 Step 1 - Hexo 本地安装及运行测试首先全局安装 Hexo： 1sudo npm install hexo-cli -g 安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record： 1hexo init daily_record 接下来进入到博客目录下，安装依赖，运行即可查看初始状态了 123cd daily_recordnpm installhexo server 如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面： Step 2 - 更换 Volantis 主题想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美) 好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。 接下来进入到项目的根目录，开始安装主题： 1git clone https://github.com/xaoxuu/hexo-theme-volantis themes/volantis 下载好之后，修改根目录下的 _config.yml 文件： 12- theme: landscape+ theme: volantis 然后安装一些依赖： 1npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S 现在重新启动服务，你的网站应该变成了这样 Step 3 - 部署到 Gitub这个主题有很多配置，具体可以参考官方文档，这里就还不在赘述。 要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。 需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目 然后安装 Hexo 的部署插件： 1npm install hexo-deployer-git -S 安装好之后，修改根目录下的 _config.yml 文件： 1234deploy:+ type: &#x27;git&#x27;+ repo: https://github.com/yourname/yourname.github.io+ branch: master 最后通过以下命令即可一键部署： 1hexo g -d Step 4 - 访问个人主页接下来就可以在下面的地址访问你的个人主页了： 1https://yourname.github.io/","categories":[],"tags":[],"author":{"name":"初心Yearth","url":"https://space.bilibili.com/11282054"}}],"categories":[],"tags":[]}