<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端造轮子【3】 —— mvvm</title>
      <link href="/2020/08/10/2020-08-10/"/>
      <url>/2020/08/10/2020-08-10/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vue2 的响应式实现原理。</p><p>这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：<a href="https://github.com/DMQ/mvvm">《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》</a></p><a id="more"></a><h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>我们首先来看看官网给出的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8cdd58cf-e3f9-47cf-94df-dea71154bfbc%2FGIF_2020-8-7_15-41-20.gif?table=block&id=40f4e036-bdb2-4208-a76e-919db64017da&name=GIF_2020-8-7_15-41-20.gif&cache=v2"></p><p>这个例子很好的展示了 mvvm 的核心功能：</p><ul><li>数据驱动视图更新</li></ul><p>再结合代码看看，我们发现这里的定义并不复杂，仅仅是：</p><ul><li>el：指定跟节点</li><li>data：定义响应式数据</li><li>插值表达式：渲染变量</li><li>v-xxx：vue 指令</li></ul><p>从上面我们能得到什么信息呢？</p><p>显然，我们要对节点进行解析，解析其中的插值表达式和 v-xxx 指令，这个功能我们可以叫它 <strong>Compiler</strong>。然后我们还需要对 data 中的数据进行劫持，当其中的数据发生 <code>get/set</code> 的时候，能够进行自定义的操作，这个功能我们叫它 <strong>Observer</strong>。最后我们需要监听这些数据，当他们发生改变的时候，通知视图去进行更新操作，这个功能我们叫它 <strong>Watcher</strong>。</p><p>这里引用一下大佬的图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4219c573-3b0c-42fe-a9d8-56201571c7d0%2FUntitled.png?table=block&id=86609f8d-52e7-40a0-9bfa-5923ebe2472b&name=Untitled.png&cache=v2"></p><p>可以看到，除了上面我们提到的三个模块以外，这里还多了 Updater 和 Dep，Updater 倒还好理解，但这 Dep 是干嘛的呢？</p><p>我们知道，data 和 view 中的显示存在多对多的关系，如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>1: &#123;&#123; data_1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>2: &#123;&#123; data_1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>3: &#123;&#123; data_2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>4: &#123;&#123; data_3 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>5: &#123;&#123; data_3 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    data_1: <span class="number">1</span>,</span><br><span class="line">    data_2: <span class="number">2</span>,</span><br><span class="line">    data_3: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码中：</p><ul><li>当 data_1 发生改变的时候，p1 和 p2 都要重新渲染</li><li>当 data_2 发生改变的时候，p3 要重新渲染</li><li>当 data_3 发生改变的时候，p4 和 p5 都要重新渲染</li></ul><p>显然这需要被控制管理起来，否则视图的更新肯定是一团乱，而 Dep 就是用来做这个的，我们可以看看下面这张图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F33318536-5b7b-4979-841e-610e8d074724%2FUntitled.png?table=block&id=84472cd8-70f1-4138-aab5-9fe74e7b0fe8&name=Untitled.png&cache=v2"></p><p>从上图可以看到：</p><ul><li>view 中每一个需要被渲染的值对应一个 Watcher</li><li>每一个响应式变量对应一个 Dep</li></ul><p>那么更新流程就应该是这样：当是数据更新的时候，Observer 通知对应的 Dep，然后 Dep 通知自己管理的 Watcher 调用 Updater 进行视图的更新。</p><p>当然，最后我们需要一个入口作为桥梁，将上面的各个模块给联系起来，组合成一个完整的 mvvm 框架。</p><p>大致的思路已经有了，那么开始吧，it’s show time！</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>首先再来看看官方示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 <code>new</code> 了一个 Vue，并且只传了一个 obj 进去，那么我们最终对外暴露的对象也应当如此。</p><blockquote><p>总所周知，vue 是法语视图的意思，那么这里就用它的好朋友来作为命名语言吧</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Aus &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">    <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.$el) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;请指定挂载点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就来实现模板的解析。</p><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>我们来分析一下 Compiler 需要做什么：</p><ul><li>通过 el 获取需要被编译的 root 节点</li><li>进行模板编译</li><li>将编译后的节点覆盖到 root 节点的位置</li></ul><p>而模板编译应该怎么进行呢？</p><ul><li>首先我们可以将节点碎片化，在内存中处理</li><li>遍历当前的节点树，这里我们只关注两类节点：<ul><li>元素节点：处理 <code>a-xxx</code> 指令</li><li>文本节点：处理插值表达式</li></ul></li><li>将编译好的节点碎片 append 到 root 节点上</li></ul><p>那么我们的问题就来到了如何处理文本和元素节点：</p><ul><li>元素节点：<code>node.attributes</code></li><li>文本节点：正则表达式</li></ul><p>进过上面一通分析，整个结构已经比较清晰了，这里再补上脑图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa077d9b8-3dff-4a7b-8f00-21a5eaf948ae%2FUntitled.png?table=block&id=244ae090-c483-48b7-9f43-9e0930a566d8&name=Untitled.png&cache=v2"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;单层：&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line"> &lt;p v-text=<span class="string">&quot;msg&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Aus <span class="keyword">from</span> <span class="string">&#x27;./aus.js&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> am = <span class="keyword">new</span> Aus(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Hello Aussicht!&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F69ef04bd-e24c-4320-962f-ec21ea636903%2FUntitled.png?table=block&id=c72dfd75-06a9-4871-8046-daf996caca05&name=Untitled.png&cache=v2"></p><p>可以看到，这里已经成功将 <code>a-text</code> 和插值表达式替换成了我们想要渲染的变量了。</p><p>接下来我们想要实现的效果是当数据发生改变的时候，视图也随之更新，那么首先应该实现的是 Observer。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>同样的，我们来分析一下 Observer 需要做什么。</p><p>事实上，仅仅考虑数据劫持这一层面的话，Observer 需要实现的功能非常简单，就是利用 <code>Object.defineProperty</code> 对 data 进行代理即可。</p><p>流程很简单：</p><ul><li>获取 data 的所有 key，对其进行劫持</li><li>如果 data 的 key 为 obj，则递归</li></ul><p>脑图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8f14c21f-c5c5-4898-b208-0d7aa9085626%2FUntitled.png?table=block&id=43a1c4ac-355e-4668-93eb-caf0af0170c9&name=Untitled.png&cache=v2"></p><blockquote><p>本文主要是简单探讨一下 mvvm 实现原理，这里对于数组就不做处理了。</p></blockquote><p>代码很简单，按照上面的思路进行实现即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">&#x27;./dep.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.observe(<span class="built_in">this</span>.data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observe(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defineReactive(obj, key, value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observe(value)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      get: <span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对新设置的值进行监听</span></span><br><span class="line">        <span class="built_in">this</span>.observe(newVal)</span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer</span><br></pre></td></tr></table></figure><p>接下来就是最关键的，当数据发生改变的时候，通知视图进行更新渲染了。</p><h3 id="Watcher-amp-amp-Dep"><a href="#Watcher-amp-amp-Dep" class="headerlink" title="Watcher &amp;&amp; Dep"></a>Watcher &amp;&amp; Dep</h3><p>这里我们一步步分析一下：</p><ul><li>Watcher 一一对应模板中的变量（插值表达式 or <code>a-text</code>）</li><li>Dep 对应具体变量</li><li>Observer 能发出通知</li></ul><p>只有当变量发生改变的时候，模板中对应的地方需要发生重新渲染，所以流程应该是：</p><ul><li>Observer 通知 Dep，变量发生改变</li><li>Dep 管理了一个 Watcher 数组，执行 Watcher 的 update 方法，更新视图</li></ul><p>那么现在的问题是，怎么建立 Dep 和 Watcher 的关系。</p><p>显然，模板中每有一个需要渲染的值，就应该有一个对应的 Watcher，而这个值在初始化的时候会进行 <code>get</code> 操作，那么自然是在 <code>get</code> 中进行操作最合适：</p><p>同样，在修改值得之后会进行 <code>set</code> 操作，那么在 <code>set</code> 的时候利用 dep 通知 Watcher 进行操作也最合适。</p><p>综上：</p><ul><li>Dep 至少需要管理一个 Watcher 数组，一个添加 Watcher 的方法，一个通知 Watcher 更新视图的方法</li><li>Watcher 在初始化的时候创建，管理 Update 方法</li></ul><p>脑图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15307dfb-6688-4efe-9b28-fc372da2d52e%2FUntitled.png?table=block&id=58b7763d-4d68-4d68-9419-b0e1d98583ea&name=Untitled.png&cache=v2"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers = []</span><br><span class="line">  &#125;</span><br><span class="line">  addWatcher(w) &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers.push(w)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers.forEach(<span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">      w.updater()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改一下 Observer 中的 get，这样整个流程就都通了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get: <span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">  Dep.target &amp;&amp; dep.addWatcher(Dep.target)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下所示：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/aa45502c-4811-4177-b733-f64f998664c3/1111.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200810/us-west-2/s3/aws4_request&X-Amz-Date=20200810T080716Z&X-Amz-Expires=86400&X-Amz-Signature=5a24f8999af887fe940e8fb75118215976db8ce0b7262c83950f0a3b4ab790f3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%221111.gif%22"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更加阅读体验：<a href="https://www.notion.so/01-MVVM-24ae2e3c17a9403689c01a73879939de">手写简易 MVVM</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端造轮子【2】 —— vuex</title>
      <link href="/2020/08/10/2020-08-07_3/"/>
      <url>/2020/08/10/2020-08-07_3/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vuex 的内部实现原理。<br>我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a></p><a id="more"></a><h2 id="Step-1-需求分析"><a href="#Step-1-需求分析" class="headerlink" title="Step 1 - 需求分析"></a>Step 1 - 需求分析</h2><p>首先用 vue-cli 4.x 创建一个空项目，选择使用 vuex，等项目创建好之后，在 src 目录下应该存在一个 store 文件，其内容大致如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;./yvuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num = <span class="number">1</span>) &#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    add(&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用过状态管理库的同学应该很清楚 action 主要用于处理异步操作，那么这里我们暂时先不关心它，把同步操作处理完之后再来看它就会清晰很多了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;./yvuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num = <span class="number">1</span>) &#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上述代码，我们可以分析出以下几点：</p><ul><li>首先 vuex 是 vue 的插件，首先会 use，在这个时候调用其 install 方法</li><li>通过 new 新建实例的是 vuex 上的 store 对象而非 vuex 本身</li><li>导出的 store 会在 main 中传给 vue（这一部分在 main 中，而不在上述代码中）</li></ul><p>那么我们的 vuex 应该如何设计呢？</p><p>我认为应该结合 vuex 的使用来进行分析：</p><p>我们知道，在项目中使用 vuex 的时候，通常形如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.xxx</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="comment">// this.$store.dispatch(&#x27;xxx&#x27;) 异步，暂不考虑</span></span><br></pre></td></tr></table></figure><p>显然，首先我们需要把 store 挂载到 vue 实例上，其次，store 上还应该有 state 和 commit，它们两分别是一个 object 和一个 function。</p><p>此时的思维导图如下所示：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37d63332-0523-4378-a750-fefa7ba0b199%2FUntitled.png?table=block&id=67b0c40c-de87-419a-9554-5380607058a4&name=Untitled.png&cache=v2"></p><h2 id="Step-2-功能实现"><a href="#Step-2-功能实现" class="headerlink" title="Step 2 - 功能实现"></a>Step 2 - 功能实现</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>那么我们按照这样的方式构建 vuex：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export default Vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) &#123;</span><br><span class="line">          Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commit() &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再回到 store 中，可以看到在创建 store 实例的时候，我们传递了两个对象：</p><ul><li>state：用于存储状态</li><li>mutations：用于同步修改状态</li></ul><p>也就是说，在构建实例的过程中，我们将 state 存储到 <code>$store.state</code> 中，将 mutations 存储起来，在 commit 的时取出调用，思维导图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff257c80b-36e4-4465-9736-1711a4042102%2FUntitled.png?table=block&id=9adb43b6-90c0-41b5-8631-f5e88ef244b3&name=Untitled.png&cache=v2"></p><p>那么我们对应实现的代码应该是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="built_in">this</span>._mutations = options.mutations</span><br><span class="line">      <span class="built_in">this</span>.state = options.state</span><br><span class="line">    &#125;</span><br><span class="line">    commit(type, payload) &#123;</span><br><span class="line">      <span class="keyword">const</span> mutation = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">      <span class="keyword">return</span> mutation(<span class="built_in">this</span>.state, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，已经能从 <code>this.$store.state</code> 中取出 counter 了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F03a44026-f9c7-44f5-a54d-8fa0f1cf9c7b%2FUntitled.png?table=block&id=81afa976-f2da-488e-9953-58ffe5e0c03b&name=Untitled.png&cache=v2"></p><p>并且 commit 也能成功调用了：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/02c95c62-273b-466a-a386-7c1699c128b9/20200804_151559.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064340Z&X-Amz-Expires=86400&X-Amz-Signature=b3e701454c05012c56b755b52245c41cd300f0fc5cbb1cec2ebb91228ee47804&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_151559.gif%22"></p><p>但这里还有问题，最关键的就是 counter 的改变并没有引起页面的重新渲染。显然我们应该将 state 改成响应式数据，在 <strong><a href="https://www.notion.so/vue-router-5e3643ff7f344645bf6fa0b0a4229115">手写简易 vue-router</a></strong> 中我们使用了 vue 官方提供的静态方法：Vue.util.defineReactive</p><p>那么这里我们就尝试使用另一个办法来实现响应式数据：创建 vue 实例，利用其中的 data 方法将 state 转化为响应式数据，实际代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="built_in">this</span>._mutations = options.mutations</span><br><span class="line">      <span class="built_in">this</span>._vm = <span class="keyword">new</span> _Vue(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 由于不希望数据被代理，所以这里加上 $</span></span><br><span class="line">            $$state: options.state,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._vm._data.$$state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">state</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 不允许直接修改 state</span></span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;please use replaceState to reset state&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再看看效果如何：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/225b951d-b4e3-4269-96d8-9098cde9a564/20200804_152810.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064401Z&X-Amz-Expires=86400&X-Amz-Signature=43a805fe1b46aa3cda736db7c3f941429f106732f3b8169e4a622de1e38e5039&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_152810.gif%22"></p><p>至此，一个最最基础的 store 已经基本实现了，接下来自然是异步操作的 action 了。</p><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>其实明白了 mutations，actions 也已经清楚了大半，唯一的区别就是 action 中我们需要调用 commit 来修改 state，那么这个 commit 从哪里来自然就很清楚了：this</p><p>导图如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3b4df158-3376-4f94-ad02-735b70506667/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064423Z&X-Amz-Expires=86400&X-Amz-Signature=bb52c64a51045faa72e617d8d4f61ab910fc7d8c92232a15ecdcbff67038a8a3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>实现代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">      <span class="built_in">this</span>._actions = options.actions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    dispatch(type, payload) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="built_in">this</span>._actions[type]</span><br><span class="line">      <span class="keyword">return</span> action(<span class="built_in">this</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nice，非常完美，我们来看看效果：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/49d08351-1ebc-43a0-9917-c20846ab96ab/20200804_153954.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064443Z&X-Amz-Expires=86400&X-Amz-Signature=ec0951f3c6f659ec8bb0a0326beb307e77e4e2c36198e19b1d46dfceca5d4ee1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_153954.gif%22"></p><p>报错了？</p><p>这是为什么呢？</p><p>于是跟踪调试一番，发现如下情况：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8970833f-9608-43c0-8b82-b92548ce3f49%2FUntitled.png?table=block&id=bb92d403-bc95-460a-97c0-bd665a631e8a&name=Untitled.png&cache=v2"></p><p>this 没了，再看看 action：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c74a5640-5aa5-404b-ada9-9e8c9e3011a4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064521Z&X-Amz-Expires=86400&X-Amz-Signature=e7b93ab43c7d3c33c892427e904d04496b5bd369dcdc0a8a27388e29bc5291ba&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>显然，这里因为是在 setTimeout 中调用 commit，丢失了 this，所以我们在构建实例的时候进行绑定就可以啦。</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F82dd6b79-7b33-493b-a83d-bcbac4b88da5%2F20200804_154412.gif?table=block&id=f5abeab6-61cf-483c-b764-04d1ac511828&name=20200804_154412.gif&cache=v2"></p><p>这下就没有问题了。</p><h3 id="扩展-gettter"><a href="#扩展-gettter" class="headerlink" title="扩展 - gettter"></a>扩展 - gettter</h3><p>我们已经实现了基础的 vuex，而平时使用 vuex 的时候，大家知道 getter 也是经常被使用到的。</p><p>那么这个 getter 应当如何实现呢？</p><p>我们假设在创建 vuex 的时候传入 getter，里面只有一个值，是 doubleCounter，返回值是 <code>counter * 2</code>，那么自然 doubleCounter 是被 counter 所影响，我们这里可以画出如下导图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/41c819ba-442f-4d86-9117-ea179de3b578/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064551Z&X-Amz-Expires=86400&X-Amz-Signature=39275881153c0f3a9c81bbba027eb751ed7cacdc804dca27c1ec70bc14804ea2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>那么问题来了：<strong>怎么将 getter 和 state 关联起来呢？</strong></p><p>仔细想一想，显然这里是做代理，那么答案就呼之欲出了：<strong>Object.defineProperty</strong>。有了这个核心思想之后，我们继续分析，由于 getter 不止一个，那么我们肯定需要遍历传入的 getter obj，将其注册到 store 上。</p><p>我们可以先来实现这一步操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">            <span class="built_in">this</span>._getters = options.getters</span><br><span class="line">            <span class="built_in">this</span>.= <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.forEachGetter(<span class="built_in">this</span>, <span class="built_in">this</span>._getters)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">        forEachGetter(store, getters) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> getter = getters[key]</span><br><span class="line">                <span class="built_in">this</span>.registerGetter(store, getter, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        registerGetter(store, getter, key)&#123;</span><br><span class="line">            store._wrappedGetters[key] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getter(store.state)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这一步之后，我们可以调试看看：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbe8eb18e-99b1-4bf1-8af0-62b24d98b158%2FUntitled.png?table=block&id=62cbf2ad-e793-45f6-9bb7-6f8d872f2388&name=Untitled.png&cache=v2"></p><p>可以看到，store 上的属性 _wrappedGetters 中现在包含两个属性：</p><ul><li>doubleCounter：这是一个函数，即 registerGetter 中返回的 wrappedGetter，当我们调用它的时候，会返回 getter(store.state) 执行的结果，及 state.counter * 2</li><li>state：这里是响应式数据（不过现在还不是响应式的）</li></ul><p>现在已经建立好了 options.getter 和 store._wrappedGetters 的映射关系，我们可以开始通过 Object.defineProperty 来做代理了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">            <span class="built_in">this</span>.resetStoreVm(<span class="built_in">this</span>, options.state)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">        resetStoreVm(store, state) &#123;</span><br><span class="line">      store.getters = &#123;&#125;</span><br><span class="line">      <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">      <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">      <span class="built_in">Object</span>.keys(wrappedGetters).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        computed[key] = <span class="built_in">this</span>.partial(wrappedGetters[key], store)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">          get: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>._vm = <span class="keyword">new</span> _Vue(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            $$state: state,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ! 计算属性，用于实现 getter</span></span><br><span class="line">        computed: computed,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    partial = <span class="function">(<span class="params">fn, arg</span>) =&gt;</span> <span class="function">() =&gt;</span> fn(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，比较有容易搞不清楚的就两个地方：</p><ul><li>wrappedGetters[key] 是什么</li><li>partial 返回值是什么</li></ul><p>这个问题直接在调试器里看看就清楚了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff9c75190-5fb6-4c76-9f57-a374603567d0%2FUntitled.png?table=block&id=fd4c96ec-a1ad-407b-b418-81840bfcd806&name=Untitled.png&cache=v2"></p><p>显然，这两位，一个是 getter 的包裹函数，一个是其本身。</p><p>到这里，getter 也算是基本实现了，具体效果如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6fe02525-46b9-4694-a9d4-2828abe7f7a1/20200805_115001.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064717Z&X-Amz-Expires=86400&X-Amz-Signature=e6300f43deaa27b07f792b533a81d83cfd193865261d72e8d5b61895f695d16a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200805_115001.gif%22"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/vuex-632700a6aa904f64943b83265571a638">手写简易 vuex</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端造轮子【1】 —— vue-router</title>
      <link href="/2020/08/10/2020-08-07_2/"/>
      <url>/2020/08/10/2020-08-07_2/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vue-router 的内部实现原理。</p><p>我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？</p><p>通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案：</p><ul><li>hash（就是页面上的 #）</li><li>history（h5）</li></ul><p>今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。</p><a id="more"></a><h2 id="Step-1-需求分析"><a href="#Step-1-需求分析" class="headerlink" title="Step 1 - 需求分析"></a>Step 1 - 需求分析</h2><p>首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。</p><p>项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;./yvue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/About.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>我们逐步来分析一下上面的代码：</p><ul><li>首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 <strong>VueRouter 是 Vue 的插件</strong>，需要有自己的<strong>静态 install 方法</strong></li><li>接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系</li><li>然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出</li><li>最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身</li></ul><p>上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？</p><p>首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？</p><p>联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件：</p><ul><li>router-view：用于显示组件</li><li>router-link：用于路由跳转</li></ul><p>显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。</p><p>接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。</p><p>以上，我们可以大致总结一下，如下图所示：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F60eca3e4-2504-42d5-80dc-5b1a29c6d716%2FUntitled.png?table=block&id=69e2386c-541d-4404-958d-0fc65353f69a&name=Untitled.png&cache=v2"></p><h2 id="Step-2-功能实现"><a href="#Step-2-功能实现" class="headerlink" title="Step 2 - 功能实现"></a>Step 2 - 功能实现</h2><p>那么现在我们可以着手开始实现自己的 vue-router 了。</p><p>首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对应 Vue.use</span></span><br><span class="line">  <span class="keyword">static</span> install(Vue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着我们就可以在 install 中实现对两个全局组件的注册：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应 Vue.use</span></span><br><span class="line">    <span class="keyword">static</span> install(Vue)&#123;</span><br><span class="line">        <span class="comment">// step 1: 注册组件 router-link，用于路由跳转</span></span><br><span class="line">        <span class="comment">// 回忆一下 router-link 的使用：</span></span><br><span class="line">        <span class="comment">// * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt;</span></span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 必要参数 to</span></span><br><span class="line">      props: &#123;</span><br><span class="line">        to: &#123;</span><br><span class="line">          type: <span class="built_in">String</span>,</span><br><span class="line">          <span class="built_in">require</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 模板，可以使用 template，也可以使用 render。</span></span><br><span class="line">      <span class="comment">// * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。</span></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="comment">// 这里可以写 jsx，也可以使用 h 函数</span></span><br><span class="line">        <span class="comment">// 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下</span></span><br><span class="line">        <span class="comment">// * h 函数类似于 react 中的 createElement</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`#$&#123;<span class="attr">this.to</span>&#125;`&#125;&gt;</span>&#123;this.$slots.default&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step 2: 注册组件 router-view，用于显示组件</span></span><br><span class="line">            <span class="comment">// 回忆一下 router-link 的使用：</span></span><br><span class="line">            <span class="comment">// &lt;router-view /&gt;</span></span><br><span class="line">            Vue.component(<span class="string">&#x27;router-view&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 没有参数，直接 template</span></span><br><span class="line">      render(h) &#123;</span><br><span class="line">        <span class="comment">// 这里使用 h</span></span><br><span class="line">        <span class="comment">// view-router 的功能是渲染组件，那么组件从哪里获取呢？</span></span><br><span class="line">        <span class="comment">// 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取</span></span><br><span class="line">        <span class="comment">// 而当前路由我们可以在构造函数中定义一个 current 来表示</span></span><br><span class="line">        <span class="comment">// 所以可以通过以下代码找到当前 current 对应的组件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; routeMap, current &#125; = <span class="built_in">this</span>.$router</span><br><span class="line">        <span class="keyword">const</span> component = routeMap[current] ? routeMap[current].component : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> h(component)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，至少我们的 <router-link> 已经是可用的了，而 <router-view> 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。</p><p>那么接下来自然是实现 constructor</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2d5f78cf-5c37-4aa4-a9cd-701e0fc59193%2F20200804_114704.gif?table=block&id=dcb77b60-e4b2-4e30-8f20-9a6cc6cecbd9&name=20200804_114704.gif&cache=v2"></p><p>那应该怎么办呢？</p><p>接下来的问题是：<strong>怎么将 current 转成 vue 响应式数据？</strong></p><p>对于上述问题，这里有两个思路：</p><ul><li>新建 vue 实例，通过 data 将 current 转成响应式数据</li><li>利用 vue 提供的静态方法 <strong>Vue.util.defineReactive</strong></li></ul><p>这里我们采取第二种方案：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里又出现一个问题，这个 Vue 从哪里来呢？</p><p>其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    _Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，基本的路由已经实现了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fef5b0447-bf3f-4b40-a525-347d5cefb018%2F20200804_134007.gif?table=block&id=0716b1fc-78ea-4d35-b7cb-0c9f4f16818e&name=20200804_134007.gif&cache=v2"></p><p>还有一些可以扩展的地方：</p><p>比如优化一下 constructor，将 options 保存到本地：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.$options.routes.map(<span class="function">(<span class="params">route</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  _Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以保证数据的单向流动。</p><p>比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。</p><p>不过这里有一个点值得注意，那就是时间：</p><p>因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br></pre></td></tr></table></figure><p>进行挂载显然是不行的。</p><p>这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">      Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就没什么问题了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/vue-router-5e3643ff7f344645bf6fa0b0a4229115">手写简易 vue-router</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 爬坑之旅【2】 —— 网站配置</title>
      <link href="/2020/08/07/2020-08-07_1/"/>
      <url>/2020/08/07/2020-08-07_1/</url>
      
        <content type="html"><![CDATA[<p>前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。</p><a id="more"></a><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><p>目标文件：root/ _config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">世界的侧面</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">初心Yearth</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">https://s1.ax1x.com/2020/08/06/agXE9K.png</span></span><br></pre></td></tr></table></figure><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>目标文件：root/themes/volantis/_config.yml</p><h3 id="封面配置"><a href="#封面配置" class="headerlink" title="封面配置"></a>封面配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">    <span class="attr">M title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># subtitle: &#x27;&#x27;</span></span><br><span class="line">    <span class="attr">M search:</span> <span class="string">你想看点什么呢？</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># features: // 这个选项是搜索框下的导航按钮，这里选择注释掉</span></span><br></pre></td></tr></table></figure><h2 id="导航栏配置"><a href="#导航栏配置" class="headerlink" title="导航栏配置"></a>导航栏配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">logo:</span></span><br><span class="line">        <span class="attr">img:</span></span><br><span class="line">        <span class="attr">icon:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    <span class="attr">menu:</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 博客</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># icon: fas fa-rss</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># url: /</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 归档</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># icon: fas fa-archive</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># url: archives/</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 友链</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># icon: fas fa-link</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># url: friends/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">        <span class="attr">search:</span> <span class="string">你想看点什么呢？</span></span><br></pre></td></tr></table></figure><h2 id="布局配置"><a href="#布局配置" class="headerlink" title="布局配置"></a>布局配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span></span><br><span class="line"><span class="attr">on_page:</span></span><br><span class="line"><span class="attr">M body:</span> [<span class="string">article</span>]</span><br></pre></td></tr></table></figure><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="attr">backstretch:</span></span><br><span class="line"><span class="attr">M position:</span> <span class="string">fixed</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">M id:</span> <span class="number">170672512</span></span><br><span class="line"><span class="attr">M autoplay:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F030e52f5-b2d0-4a4f-b55c-0a3b58e04239%2FUntitled.png?table=block&id=b9f55037-fcbd-4e24-842a-695381f423db&name=Untitled.png&cache=v2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 爬坑之旅【1】 —— 基础搭建</title>
      <link href="/2020/08/07/2020-08-06/"/>
      <url>/2020/08/07/2020-08-06/</url>
      
        <content type="html"><![CDATA[<p>没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。</p><a id="more"></a><h2 id="Step-1-Hexo-本地安装及运行测试"><a href="#Step-1-Hexo-本地安装及运行测试" class="headerlink" title="Step 1 - Hexo 本地安装及运行测试"></a>Step 1 - Hexo 本地安装及运行测试</h2><p>首先全局安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init daily_record</span><br></pre></td></tr></table></figure><p>接下来进入到博客目录下，安装依赖，运行即可查看初始状态了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> daily_record</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F35c84369-6339-46b8-a300-10693b7e875e%2FUntitled.png?table=block&id=f2429731-a74f-4f44-a6fc-f0ef9abb2c60&name=Untitled.png&cache=v2"></p><h2 id="Step-2-更换-Volantis-主题"><a href="#Step-2-更换-Volantis-主题" class="headerlink" title="Step 2 - 更换 Volantis 主题"></a>Step 2 - 更换 Volantis 主题</h2><p>想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美)</p><p>好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。</p><p>接下来进入到项目的根目录，开始安装主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xaoxuu/hexo-theme-volantis themes/volantis</span><br></pre></td></tr></table></figure><p>下载好之后，修改根目录下的 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"><span class="string">+</span> <span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure><p>然后安装一些依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S</span><br></pre></td></tr></table></figure><p>现在重新启动服务，你的网站应该变成了这样</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f9d35ec4-0bdc-4e1e-9280-3cba80f5a71b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200806/us-west-2/s3/aws4_request&X-Amz-Date=20200806T092415Z&X-Amz-Expires=86400&X-Amz-Signature=e700ffe5b7313d847e6e4c4cbe29bc33a20307aa9ce3ddf0e1606bead705d98e&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><h2 id="Step-3-部署到-Gitub"><a href="#Step-3-部署到-Gitub" class="headerlink" title="Step 3 - 部署到 Gitub"></a>Step 3 - 部署到 Gitub</h2><p>这个主题有很多配置，具体可以参考<a href="https://volantis.js.org/v2/getting-started/">官方文档</a>，这里就还不在赘述。</p><p>要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。</p><p>需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目</p><p>然后安装 Hexo 的部署插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -S</span><br></pre></td></tr></table></figure><p>安装好之后，修改根目录下的 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>最后通过以下命令即可一键部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h2 id="Step-4-访问个人主页"><a href="#Step-4-访问个人主页" class="headerlink" title="Step 4 - 访问个人主页"></a>Step 4 - 访问个人主页</h2><p>接下来就可以在下面的地址访问你的个人主页了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://yourname.github.io/</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0c0da1b1-57a7-4899-b0ef-f345e46af4a4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200806/us-west-2/s3/aws4_request&X-Amz-Date=20200806T092430Z&X-Amz-Expires=86400&X-Amz-Signature=ff4f20c6532b8aca669d0b867b9a2ad3945e685fbecde46bf7f2546da0b5f47a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
