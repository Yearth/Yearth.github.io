<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 2.6 源码分析之旅【4】 —— diff 算法</title>
      <link href="/2020/08/19/2020-08-19/"/>
      <url>/2020/08/19/2020-08-19/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.notion.so/a4f8ae7852b146aabab526625917aaa0">上一章</a>我们分析了 vue 2.6.x 的异步更新策略，弄清楚了以下几个问题：</p><ul><li>vue 是在什么阶段进行视图更新的</li><li>vue 是在什么位置进行视图更新的</li><li>实现 vue 异步更新的核心原理</li></ul><p>而今天我们将分析 vue diff 算法，相信读完本文，将会对以下问题有初步的认知：</p><ul><li>vue diff 算法发生在什么位置</li><li>vue diff 算法的核心原理</li><li>为什么推荐 v-for 要加上 key</li></ul><p>那么便开始吧(๑•̀ㅂ•́)و✧！</p><hr><a id="more"></a><h2 id="生成虚拟-DOM"><a href="#生成虚拟-DOM" class="headerlink" title="生成虚拟 DOM"></a>生成虚拟 DOM</h2><p>这个名词相信大家已经非常熟悉了，这里就当简单复习一下了。</p><p>首先自然是概念：</p><p>所谓虚拟 DOM，其实就是 js 的对象，主要的目的是描述真实 dom 的结构和关系。</p><p>也就是说，虚拟 DOM 就是真实 DOM 的映射。</p><p>而这也是 vue 能做到跨平台的原因之一：完成虚拟 DOM 的操作之后，将其 patch 为真实 DOM 的过程中：</p><ul><li>目标是浏览器，则 patch 成浏览器结构，那么就能适应浏览器</li><li>目标是小程序，则 patch 成小程序的结构，那么就能适应小程序</li><li>目标是 app，则 patch 成 app 的结构，那么就能适应移动端</li><li>…</li></ul><p>那么我们来看看 vue 源码中，关于虚拟 DOM 的操作吧。</p><p>结合前面将到的，我们先定位 <code>updateComponent</code> 中的 <code>_render</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: src/core/instance/render.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">    <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">    <span class="comment">// when parent component is patched.</span></span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="comment">// return error render result,</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">    vnode = vnode[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> + <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vnode = createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的核心功能在这里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure><p>通过 <code>render</code> 生成虚拟 DOM，在最后将其返回出去。</p><h2 id="虚拟-DOM-转真实-DOM"><a href="#虚拟-DOM-转真实-DOM" class="headerlink" title="虚拟 DOM 转真实 DOM"></a>虚拟 DOM 转真实 DOM</h2><p>这里我们来到 <code>_update</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的核心在于：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">  <span class="comment">// initial render</span></span><br><span class="line">  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// updates</span></span><br><span class="line">  vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以看出，当初始化的时候，是没有 prevVnode 的，所以会走 if 分支，之后会走 else 更新分支。</p><p>其核心方法都是 <code>__patch__</code>：</p><p>在第一章的分析中，入口文件有一行代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure><p>这里安装了平台特有的 patch 方法，我们可以追踪一下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patch = createPatchFunction(&#123; <span class="attr">nodeOps</span>: nodeOps, <span class="attr">modules</span>: modules &#125;)</span><br></pre></td></tr></table></figure><p>说明 createPatchFunction 方法将返回一个 patch 方法，那么我们来到它的返回值：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * file: src/core/vdom/patch.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// **empty mount (likely as component), create new root element**</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      <span class="comment">// patch existing root node</span></span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// mounting to a real element</span></span><br><span class="line">        <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">        <span class="comment">// a successful hydration.</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">          hydrating = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">            invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> oldVnode</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// either not server-rendered, or hydration failed.</span></span><br><span class="line">        <span class="comment">// create an empty node and replace it</span></span><br><span class="line">        oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// replacing existing element</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldVnode.elm</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create new node</span></span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue,</span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">      <span class="comment">// update parent placeholder node element, recursively</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">        <span class="keyword">const</span> patchable = isPatchable(vnode)</span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">            cbs.destroy[i](ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">              cbs.create[i](emptyNode, ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// #6513</span></span><br><span class="line">            <span class="comment">// invoke insert hooks that may have been merged by create hooks.</span></span><br><span class="line">            <span class="comment">// e.g. for directives that uses the &quot;inserted&quot; hook.</span></span><br><span class="line">            <span class="keyword">const</span> insert = ancestor.data.hook.insert</span><br><span class="line">            <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">              <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                insert.fns[i]()</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerRef(ancestor)</span><br><span class="line">          &#125;</span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// destroy old node</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>对于上面的代码，我们先看看初始化的执行流程：</p><ul><li>首先我们可以从注释和判断知道：通常情况下并不会走 <code>if (isUndef(oldVnode))</code> 这个分支，因为只有当 empty mount 的情况下，才会走这里</li><li>接着，初始化的时候，<code>oldVnode === vm.$el</code>，所以是真实节点，即 isRealElement 为真，那么就会走到 <code>if (isRealElement)</code> 分支中</li><li>紧接着就会通过 <code>oldVnode = emptyNodeAt(oldVnode)</code> 将生成 oldNode 对一个的虚拟 DOM</li><li>随后通过 <code>createElm</code> 创建新的 DOM 树，并且把它放在老节点的旁边</li><li>最后通过 <code>removeVnodes</code> 删除老节点</li></ul><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3bbc2a13-de78-430a-aa2f-a3db74543958%2FUntitled.png?table=block&id=21adf153-547d-47aa-a6b9-fede0a25eed2&name=Untitled.png&cache=v2"></p><h3 id="更新流程"><a href="#更新流程" class="headerlink" title="更新流程"></a>更新流程</h3><p>在更新流程中，传入的 oldVnode 是 prevVnode，即这个时候它已经是一个虚拟 DOM 了，那么如果新老节点是同样类型的节点，就会走到：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly)</span><br></pre></td></tr></table></figure><p>而这就是大名鼎鼎的 diff 算法发生的地方。</p><p>在看 <code>patchVnode</code> 之前，我们先来看看 <code>sameVnode</code>，了解一下到底怎么样才算是相同节点：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    ((a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b)) ||</span><br><span class="line">      (isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error)))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先 key 一定要相同，然后节点类型相同，如果是 input，则 type 要相同，等等。</p><p>二者都没有 key 的时候，<code>undefined === undefined</code></p><p>那么我们接着来到 <code>patchVnode</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// clone reused vnode</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> elm = (vnode.elm = oldVnode.elm)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reuse element for static trees.</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">  <span class="keyword">const</span> ch = vnode.children</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update))) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch))) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里总的来说，包括了三种操作：</p><ul><li>节点属性更新</li><li>文本更新</li><li>子节点更新</li></ul><p>其中本文节点和子节点是互斥的，因为一个节点一旦是文本节点，那么它必然没有子节点，反之它一定不是文本节点。</p><p>具体的更新规则如下：</p><ul><li><p><strong>新老节点都有</strong>子节点，则调用 <code>updateChildren</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>新⽼节点都没有</strong>⼦节点，进行文本替换</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">  nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>新节点有</strong>⼦节点⽽<strong>⽼节点没有</strong>⼦节点，则先清空老节点的文本内容，然后为其新增子节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    checkDuplicateKeys(ch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isDef(oldVnode.text)) nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>新节点没有</strong>⼦节点⽽<strong>⽼节点有</strong>⼦节点，则移除老节点的所有⼦节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">  removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">  nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那么我们来看看 <code>updateChildren</code> 做了什么：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elements stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transitions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld = isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123;</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的操作非常巧妙，我们一步步来看看：</p><ul><li><p>首先创建了 4 个游标以及 4 个对应的节点，<strong>分别代表老节点和新节点的首尾</strong></p></li><li><p>进行了一个循环操作，结束条件是<strong>老节点和新节点的游标重合</strong>，在循环中进行了如下操作：</p><ul><li><p>调整节点引用，保证其有值</p></li><li><p>如果<strong>新老节点的首部相同</strong>，则对这两个节点进行 patch 操作，并且首部游标分别后移一位</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">  oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">  newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>新老节点尾部相同</strong>，则对这两个节点进行 patch 操作，并且尾部游标分别前移一位</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">    patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">    oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    newEndVnode = newCh[--newEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>老节点首部与新节点尾部相同</strong>，则对这两个节点进行 patch 操作，老节点首部游标加一，新节点尾部游标减一，并且还要做额外的移动操作，将老节点首部移动到尾部。这个操作其实并不难理解：因为满足这个条件的时候，很可能是进行了逆序的操作。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">  canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">  oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">  newEndVnode = newCh[--newEndIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>老节点尾部与新节点首部相同</strong>，则对这两个节点进行 patch 操作，老节点尾部游标减一，新节点首部游标加一，并且还要做额外的移动操作，将老节点尾部移动到首部。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">  canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">  oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">  newStartVnode = newCh[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果上述条件都不满足，则只能进行效率较为低下的遍历操作：在老节点中找是否存在于新节点首部相同的节点，这里又存在两种情况：</p><ul><li>没找到：说明这个节点是新增节点，直接创建一个新节点</li><li>找到了：<ul><li>相同节点：进行 patch 操作，并且移动老节点</li><li>不同节点：创建新节点</li></ul></li></ul></li></ul></li><li><p>当循环结束之后，如果两组节点如果数量不同，则进入下面的流程：</p><ul><li><p>老节点先结束，说明有新增节点，进行批量创建</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">  refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新节点先结束，说明有节点删除，进行批量删除</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">  removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>这里的逻辑不可谓不复杂了，我们将脑图整理出来再看看：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2cf04483-802f-4465-8fc0-8345cd264481%2FUntitled.png?table=block&id=8e5ae920-30fb-4aa9-b236-670298f5e283&name=Untitled.png&cache=v2"></p><p>从上面我们可以总结出一些规律：</p><ul><li>节点比较一定是在同层级之间进行：<strong>同层比较</strong></li><li>如果存在子节点，一定会优先获取子节点：<strong>深度优先</strong></li></ul><h2 id="一些有意思的东西"><a href="#一些有意思的东西" class="headerlink" title="一些有意思的东西"></a>一些有意思的东西</h2><h3 id="关于-vue-的虚拟-DOM"><a href="#关于-vue-的虚拟-DOM" class="headerlink" title="关于 vue 的虚拟 DOM"></a>关于 vue 的虚拟 DOM</h3><p>这个从 patch 文件的头部我们可以看到：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Virtual DOM patching algorithm based on Snabbdom by</span><br></pre></td></tr></table></figure><p>说明 vue 中的虚拟 DOM 是基于 Snabbdom 的。</p><h3 id="视图更新中诡异的画面"><a href="#视图更新中诡异的画面" class="headerlink" title="视图更新中诡异的画面"></a>视图更新中诡异的画面</h3><p>我们将断点断在新树生成，老树删除之间，可以看到这样的画面：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2f65bf94-6882-4a97-adc8-43effc10aa37%2FUntitled.png?table=block&id=5fce80ed-31d4-498b-a1bd-dc69dbd20d41&name=Untitled.png&cache=v2"></p><h3 id="vfor-中-key-的作用"><a href="#vfor-中-key-的作用" class="headerlink" title="vfor 中 key 的作用"></a>vfor 中 key 的作用</h3><p>要说明这个问题，我们先来看看有 key 的情况下，diff 是如何进行的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">  &lt;p v-<span class="keyword">for</span>=<span class="string">&quot;item in arr&quot;</span> :key=<span class="string">&quot;item&quot;</span>&gt;&#123;&#123;a&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">        data: &#123; <span class="attr">arr</span>: [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>] &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>首先，我们很清楚，数组最后会变成 <code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></p><p>那么我们开始模拟 diff 流程：</p><ul><li>Step 1<ul><li>老：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>新：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，直接 patch</li><li>结果：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 2<ul><li>老：<code>[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>新：<code>[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，不同节点 → 比较二者尾部，直接 patch</li><li>结果：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 3<ul><li>老：<code>[&#39;B&#39;, &#39;C&#39;]</code></li><li>新：<code>[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;]</code></li><li>比较二者头部，不同节点 → 比较二者尾部，直接 patch</li><li>结果：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 4<ul><li>老：<code>[&#39;B&#39;]</code></li><li>新：<code>[&#39;E&#39;, &#39;B&#39;]</code></li><li>比较二者头部，不同节点 → 比较二者尾部，直接 patch</li><li>结果：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 5<ul><li>老：<code>[]</code></li><li>新：<code>[&#39;E&#39;]</code></li><li>老节点遍历结束，新节点还有剩余，新增节点，位置在 oldStartIdx 后，更新一次</li><li>结果：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li></ul><p>综上，上面的算法总共<strong>更新了一次</strong>页面。</p><p>那么，如果没有 key，将会是什么样的情况呢？</p><ul><li>Step 1<ul><li>老：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>新：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，直接 patch</li><li>结果：<code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 2<ul><li>老：<code>[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>新：<code>[&#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，直接 patch，更新一次</li><li>结果：<code>[&#39;A&#39;, &#39;E&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 3<ul><li>老：<code>[&#39;C&#39;, &#39;D&#39;]</code></li><li>新：<code>[&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，直接 patch，更新两次</li><li>结果：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;D&#39;]</code></li></ul></li><li>Step 4<ul><li>老：<code>[&#39;D&#39;]</code></li><li>新：<code>[&#39;C&#39;, &#39;D&#39;]</code></li><li>比较二者头部，直接 patch，更新三次</li><li>结果：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;]</code></li></ul></li><li>Step 5<ul><li>老：<code>[]</code></li><li>新：<code>[&#39;D&#39;]</code></li><li>老节点遍历结束，新节点还有剩余，新增节点，位置在 oldStartIdx 后，更新四次</li><li>结果：<code>[&#39;A&#39;, &#39;E&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;]</code></li></ul></li></ul><p>这里仅仅是这么简单的一个数组，没有 key 的情况下，就已经如此繁琐，其效率之低下已经不言而喻。</p><p>这也说明了为什么 vue 非常推荐在使用 v-for 指令的时候为遍历的子项添加上 key，因为这样的效率远远高于没有 key 的情况。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/diff-27215afdd9484e59a35e33c5c8bb7464">Vue 2.6 源码分析之旅 - 四：diff 算法</a></p><p>那么今天的分析就到此为止啦，我们下期再见，咕咕咕<del>~</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.6 源码分析之旅【3】 —— 异步更新策略</title>
      <link href="/2020/08/18/2020-08-18/"/>
      <url>/2020/08/18/2020-08-18/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.notion.so/8c0511b31a0745c4bc866d98dee89c39">上一章</a>我们分析了 vue 2.6.x 的数据响应式原理，弄清楚了以下几个问题：</p><ul><li>vue 数据响应式是在什么阶段实现的</li><li>vue 数据响应式是在什么位置实现的</li><li>实现 vue 数据响应式的核心原理</li><li>vue 是如何进行依赖收集的</li><li>dep 和 watcher 的关系，以及各自的作用</li></ul><p>而今天我们将分析 vue 异步更新策略，相信读完本文，将会对以下问题有初步的认知：</p><ul><li>vue 是在什么阶段进行视图更新的</li><li>vue 是在什么位置进行视图更新的</li><li>实现 vue 异步更新的核心原理</li></ul><p>那么便开始吧(๑•̀ㅂ•́)و✧！</p><a id="more"></a><h2 id="为什么需要异步更新？"><a href="#为什么需要异步更新？" class="headerlink" title="为什么需要异步更新？"></a>为什么需要异步更新？</h2><p>要回答这个问题，通过一个 demo 其实就能很好地说明：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    created() &#123;</span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;2&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;3&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.msg = <span class="string">&#x27;4&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这里，显然 msg 更新是会导致视图重新渲染的，如果每次 msg 的值发生改变，视图都渲染一遍，那效率就太过地下了。所以理想的解决方案是：<strong>当值发生改变的时候，让这个操作入队，当队列里所有修改值得操作都完成之后，再刷新视图</strong>。</p><p>那么 vue 是如何实现这个异步更新的呢？</p><p>这就不得不提及大名鼎鼎的事件循环了。</p><h2 id="Even-Loop"><a href="#Even-Loop" class="headerlink" title="Even Loop"></a>Even Loop</h2><p>总所周知，浏览器的 js 是单线程的，也就是说，在同一时刻，最多也只有一个代码段在执行，但如果仅能执行同步的代码，很多的工作是没法完成的。为了解决这个问题，引入了事件循环这个机制，那么什么是事件循环呢？</p><p>简单来说就是当执行代码的途中，遇到需要异步执行的代码，就将其扔进队列中，等同步的代码完成之后，再去执行队列中的代码。</p><p>这里我们来看一张图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/96f3cfae-d267-4ced-ace6-2f0818b8864d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200818/us-west-2/s3/aws4_request&X-Amz-Date=20200818T071905Z&X-Amz-Expires=86400&X-Amz-Signature=cfbd730670f5d222dfced9c197fb616a534e8fa4444aded10e2b54ed989e80ab&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><ul><li>Task Queue（宏任务队列）：如 <code>setTimeout, setInteval, xhr</code> 等，代表⼀个个离散的、独⽴的⼯作单元。<strong>浏览器完成⼀个宏任务，在下⼀个宏任务执⾏开始前，会对⻚⾯进⾏重新渲染</strong>。</li><li>Microtask Queue（微任务队列）：如 <code>Promise.then, mutation observe, DOM 变化</code> 等，微小的任务，当前宏任务执行完成之后会立即清空微任务队列。<strong>如果存在微任务，浏览器会清空微任务之后再重新渲染</strong>。</li></ul><p>这里再补上脑图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/5fb188d4-07a4-4b5f-84cb-8c55bfa2ab5d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200818/us-west-2/s3/aws4_request&X-Amz-Date=20200818T071918Z&X-Amz-Expires=86400&X-Amz-Signature=b85f87b52ba209549063b8ed096da1109f66db2cced7a8beaebe70f8dd6b1f30&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>关于事件循环，本文只要了解这么多久足够了。但事件循环本身也是一个值得深入研究的点，这里暂不深入，有兴趣的朋友建议看看下面这两篇文章：</p><ul><li><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly">Tasks, microtasks, queues and schedules</a></li><li><a href="https://juejin.im/post/6844903968292749319">面试一定会问到的-js 事件循环</a></li></ul><p>综上，显然微任务用于异步更新是非常不错的选择：在微任务队列清空后，下一个宏任务开启之前，浏览器会渲染视图。</p><h2 id="异步更新流程"><a href="#异步更新流程" class="headerlink" title="异步更新流程"></a>异步更新流程</h2><p>前置基础打得差不多了，那么我们开始来分析 vue 的异步更新流程。</p><p>入口很明显，当值发生改变的时候，那么自然应该找 Observer 的 set：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">  <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">    customSetter()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">  <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">    setter.call(obj, newVal)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    val = newVal</span><br><span class="line">  &#125;</span><br><span class="line">  childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">  dep.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上一章的知识，能够判断出，这里是通过 <code>dep.notify()</code> 通知 watcher 进行视图的更新。进去看看呢：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">notify() &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">    <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">    <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">    <span class="comment">// order</span></span><br><span class="line">    subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>this.subs</code> 显然是 dep 所管理的 watcher 队列，所以 <code>subs[i].update()</code> 自然是 watcher 中的 update，那么让我们再次跳转：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">update() &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做的事很简单：</p><ul><li>如果不做更新，则开启 dirty 标志位。</li><li>如果设置为同步更新，则直接进行更新。（这里说明 <code>run</code> 就是最后执行更新的方法）</li><li>通常情况下是走最后一个条件，也就是 watcher 入队。（这里看函数名字也能看出来）</li></ul><p>那么我们继续深入：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看起来比前面稍微复杂了一些，不过总的来说告诉我们以下几条信息：</p><ul><li>如果 watcher 已经入队了，则不用再入队，防止多次渲染</li><li>如果在等待状态，则执行 <code>nextTick(flushSchedulerQueue)</code></li></ul><p>那么我们先看看 nextTick，顺带一提，这就是平时业务开发中用到的 <code>this.$nextTick</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先将回调函数入队，而这个回调函数是 <code>flushSchedulerQueue</code></li><li>执行一个时间函数：<code>timerFunc()</code></li></ul><p>那么我们先来看看这个时间函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看起来挺长的，不过实际上就做了几件事：</p><ul><li>如果环境支持 <code>Promise</code> 则使用 <code>Promise</code></li><li>否则使用 <code>MutationObserver</code></li><li>再不然使用 <code>setImmediate</code></li><li>实在不行才用 <code>setTimeout</code></li></ul><p>那么优先级如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span> &gt; MutationObserver &gt; setImmediate &gt; <span class="built_in">setTimeout</span></span><br></pre></td></tr></table></figure><p>这里我们仅看 <code>Promise</code>，因为道理都是一样的，通过 <code>p.then(flushCallbacks)</code> 传递了 flushCallbacks，跳过去看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的操作就是将 callbacks 遍历执行一遍，而 <code>copies[i]()</code> 则是前面入队的 cb，即 flushSchedulerQueue，我们去看看这又是什么东西：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow()</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> +</span><br><span class="line">            (watcher.user ? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span> : <span class="string">`in a component render function.`</span>),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">&#x27;flush&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像很复杂，但实际上我们只关心一行代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watcher.run()</span><br></pre></td></tr></table></figure><p>前面也提到了，<code>run</code> 就是实际更新视图的方法，我们进去看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">run() &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="built_in">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="built_in">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="built_in">this</span>.vm, <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照常规思路的话，这里首先通过 get 获取最新值，然后通过 <code>this.cb.call(this.vm, value, oldValue)</code> 来更新视图。</p><p>但 vue 渲染阶段并不是这样的，我们先来看看这个 get 是什么吧！</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">get() &#123;</span><br><span class="line">  pushTarget(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">    <span class="comment">// dependencies for deep watching</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    popTarget()</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，是通过 <code>value = this.getter.call(vm, vm)</code> 获取的最新值，那么继续追踪：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 expOrFn 又是什么呢？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean)</span><br></pre></td></tr></table></figure><p>显然，它是 Watcher 构造函数的第二个参数，那么我们来到 lifecycle，创建 Watcher 实例的位置：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before() &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到 expOrFn 就是 updateComponent，而它的实现如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合第一章的分析，我们知道：</p><ul><li><code>_render</code> 用于渲染</li><li><code>_update</code> 用于刷新视图</li></ul><p>所以到这里，我们知道，实际上，在 run 的 get 执行之后，视图应该就已经更新了。</p><p>这里先梳理一下脑图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F97200b69-cec5-485d-a197-ccd81ba642cc%2FUntitled.png?table=block&id=c4839d5f-8943-4e53-b14a-01c57352c66d&name=Untitled.png&cache=v2"></p><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>其实这里的调试验证非常简单，我们将断点下在 <code>run → this.get()</code> 处：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e40a499f-3905-48ba-a9d0-7ee03e1fd781/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200818/us-west-2/s3/aws4_request&X-Amz-Date=20200818T071947Z&X-Amz-Expires=86400&X-Amz-Signature=8c33152b14ba466186165e9457599e390f8c49019d9fc3e0f6ff2db8e4341792&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>紧接着单步执行：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fca339282-19a5-4361-b92e-caa02ff7d79c%2FUntitled.png?table=block&id=073329de-d2e0-4651-8b6c-ab2caf365734&name=Untitled.png&cache=v2"></p><p>可以看到，果然进行了视图更新，说明和我们的猜想没有问题。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/a4f8ae7852b146aabab526625917aaa0">Vue 2.6 源码分析之旅 - 三：异步更新策略</a></p><p>那么今天的分析就到此为止啦，我们下期再见，咕咕咕<del>~</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.6 源码分析之旅【2】 —— 数据响应式</title>
      <link href="/2020/08/17/2020-08-17/"/>
      <url>/2020/08/17/2020-08-17/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.notion.so/37c7e6218fc449a684ace2de187f18d7">上一章</a>粗浅的分析了 vue 2.6.x 的初始化流程，搞清楚了以下几个问题：</p><ul><li>vue 的入口在哪里</li><li>vue 的初始化做了什么操作</li><li>在 vue 初始化过程中，哪些操作先执行，哪些操作后执行</li></ul><p>而今天，我们将分析 vue 2.6.x 中是如何完成数据响应式操作的。</p><p>那么开始吧！</p><a id="more"></a><h2 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h2><p>相信大家都知道，vue 2.6.x 中实现数据响应式的核心方法是 <code>Object.defineProperty</code>，而这个方法并不能处理数组，所以 vue 对于数组和对象的处理方法是不同的，这里我们就先来分析它是如何处理对象的。</p><p>通过上一章的分析，我们知道，在初始化流程中，处理数据的方法是 <code>initState</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码告诉我们两条信息：</p><ul><li>优先级：props &gt; methods &gt; data &gt; computed &gt; watch</li><li>实现数据响应式的方法是 <code>initData(vm)</code></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">        warn(<span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> + <span class="string">`Use prop default value instead.`</span>, vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里可以看到，最核心的方法是 <code>observe</code>。</p><p>那么跳过去看看：</p><p>文件位置：<code>src/core/observer/index.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value: any, asRootData: ?boolean</span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="keyword">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    <span class="built_in">Object</span>.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而从这里的代码，我们能看到以下信息：</p><ul><li>如果不是对象，则不会进行 <code>new Observer()</code> 操作</li><li>如果一个对象拥有 <code>__ob__</code> 属性，那么它就是一个响应式的数据</li><li>实现响应式的核心操作在 <code>new Observer()</code> 中</li></ul><p>所以现在跳转都 Observer 中看看：</p><p>文件位置：<code>src/core/observer/index.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(value: any) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，每一个 ob 实例一定会有一个 dep 实例，而每一个数据对象会有一个 ob，<strong>所以每个对象将有一个 dep 实例</strong>，暂且我们叫它<strong>对象依赖管理器</strong>，至于它的用处，暂不深入讨论，后面再回过头来看。</p><p>前面已经提到过，数组和对象的响应式有区别，这里我们先看响应式是如何实现的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">walk(obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    defineReactive(obj, keys[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，<code>defineReactive</code> 就是实现数据响应式的核心方法了。</p><p>并且这个方法挂到了 <code>Vue.util.defineReactive</code> 上</p><p>那么我们深入到方法内部看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看挺复杂，实际上上面的代码总共做了三件事：</p><ul><li>给每个 key 创建一个 dep（这个 dep 我们叫它<strong>数据依赖管理器</strong>）</li><li>如果传入的 val 是 <code>object</code>，则进行递归操作</li><li>通过 <code>Object.defineProperty</code> 实现数据响应式</li></ul><p>那么具体是如何实现的呢？</p><p>可以看到，在 get 的时候，进行了如下操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">  dep.depend()</span><br><span class="line">  <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">    childOb.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      dependArray(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用比较专业说的说法，这一步叫做<strong>依赖收集</strong>，这里我们需要搞清楚几个问题：</p><ul><li>什么是依赖收集？</li><li>Dep.target 是什么？</li><li>depend 做了什么？</li><li>dependArray 做了什么？</li></ul><p>这里一一回答：</p><p>我们都知道，vue 是一款 mvvm 的框架，实现了数据的响应式，让开发者不用再过分关注数据，视图的联系，只需要更新数据，视图会自动的更新。</p><p>假设现在有 a, b, c, d 四个变量，而视图中只用到了 a, c, d，那么 b 更改的时候，视图自然不应该刷新，要怎么判断 b 和视图有没有关系呢？这就是依赖收集需要做到的。</p><p>至于下面的问题，我们得先到 dep 中看看：</p><p>文件位置：<code>src/core/observer/dep.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher</span><br><span class="line">  id: number</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub(sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub(sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类型可以看到，target 应该是一个 Wathcer，而 Wathcer，我们前面手写 vue 响应式的时候，已经介绍的很清楚了，如果有不清楚的童鞋可以看看这篇文章：<a href="https://www.notion.so/01-MVVM-24ae2e3c17a9403689c01a73879939de">手写简易 MVVM</a>。</p><p>那么 depend 做了什么呢？</p><p>我们来到 Watcher：</p><p>文件位置：<code>src/core/observer/watcher.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addDep(dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了两个操作：</p><ul><li>建立 watcher 和 dep 的关系</li><li>反向建立 dep 和 watcher 的关系</li></ul><p>那么为什么要建立双向的关系呢？之前实现 mvvm 的时候，不是建立单向关系就可以了吗？</p><p>这个问题我们稍后再说，现在先来看看上面的最后一个问题，dependArray 又做了什么？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span>(<span class="params">value: Array&lt;any&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里是遍历数组，对其每一个元素建立和 dep 的关系。</p><p>这里为了理清思路，补上脑图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff93fea11-2190-4d96-ae32-23d459e17191%2FUntitled.png?table=block&id=8d568f9f-c565-4e37-88c3-547a107ab887&name=Untitled.png&cache=v2"></p><p>从图中我们可以看到，这里的关键点是：</p><ul><li>Wathcer 是什么？</li><li>Dep 是什么？</li><li>为什么要建立它们的关系？</li><li>建立了它们的关系有什么用？</li></ul><p>前面已经多次提到 Dep 了，有 obj 中的 Dep，也有 key 中的 Dep，这里我们就先来看看 Dep：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: ?Watcher</span><br><span class="line">  id: number</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub(sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub(sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend() &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码告诉我们几条信息：</p><ul><li>dep 管理着一个有 Wathcer 组成的数组</li><li>在 notify 中会遍历这个数组，执行其中的 update 方法</li></ul><p>而 update 的具体实现涉及到 vue 的异步更新，所以这里就仅把它当成是视图更新函数即可，暂不讨论其具体实现。</p><p>那么 Dep 和 Watcher 的关系是：<strong>Dep 管理 Watcher，Watcher 管理视图更新</strong>。</p><p>到这里，我们已经大致清楚 vue 的数据响应式流程了，不过还存有一些疑问：</p><ul><li>为什么要建立 Dep 和 Watcher 的双向关系？</li><li>对象依赖管理器（Observer 中的 Dep）是干嘛的？</li><li>数据依赖管理器（defineReactive 中的 Dep）是干嘛的？</li></ul><p>现在我们可以来回答这些问题了：</p><h3 id="为什么要建立-Dep-和-Watcher-的双向关系？"><a href="#为什么要建立-Dep-和-Watcher-的双向关系？" class="headerlink" title="为什么要建立 Dep 和 Watcher 的双向关系？"></a>为什么要建立 Dep 和 Watcher 的双向关系？</h3><p>总所周知，vue 是组件化的前端框架，那么自然就会存在下面这样的情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">      &lt;h1&gt;Vue组件化机制&lt;/h1&gt;</span><br><span class="line">      &lt;comp :msg=<span class="string">&quot;msg&quot;</span>&gt;&lt;/comp&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      Vue.component(<span class="string">&#x27;comp&#x27;</span>, &#123;</span><br><span class="line">        template: <span class="string">&#x27;&lt;div&gt;I am comp&lt;/div&gt;&#x27;</span>,</span><br><span class="line">                props: [<span class="string">&#x27;msg&#x27;</span>],</span><br><span class="line">        data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            compMsg: <span class="built_in">this</span>.msg + <span class="string">&#x27;comp&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            msg: <span class="string">&#x27;hello vue&#x27;</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure><p>在这样的情况下，仅有 Dep 到 Wathcer 的关系显然是不够的了，所以还需要建立 Wathcer 到 Dep 的关系。</p><h3 id="对象依赖管理器（Observer-中的-Dep）是干嘛的？"><a href="#对象依赖管理器（Observer-中的-Dep）是干嘛的？" class="headerlink" title="对象依赖管理器（Observer 中的 Dep）是干嘛的？"></a>对象依赖管理器（Observer 中的 Dep）是干嘛的？</h3><p>这个很好解释，当 data 中存在对象，甚至对象嵌套的时候，修改其中的值，同样需要出发视图的更新，这就是对象依赖管理器的作用。</p><h3 id="数据依赖管理器（defineReactive-中的-Dep）是干嘛的？"><a href="#数据依赖管理器（defineReactive-中的-Dep）是干嘛的？" class="headerlink" title="数据依赖管理器（defineReactive 中的 Dep）是干嘛的？"></a>数据依赖管理器（defineReactive 中的 Dep）是干嘛的？</h3><p>最直接通知 Wathcer 更新视图的地方。</p><p>补上脑图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4373eb26-a250-45da-bc4e-f846ac70bc1d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200817/us-west-2/s3/aws4_request&X-Amz-Date=20200817T080623Z&X-Amz-Expires=86400&X-Amz-Signature=54d3796478432f5f2d3489e18cf3ab75607d87ba3c3292ae4eac6ed96b34d61b&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>到这里，对象的响应式处理已经完成了，我们再来看看对于数组，是怎么操作的。</p><h2 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h2><p>有前面的积累，可以很快定位到处理数组的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">    protoAugment(value, arrayMethods)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看看 <code>observeArray</code>，毕竟名字都这么直白了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observeArray(items: <span class="built_in">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这里就是遍历数组，对其每个元素进行响应式处理。</p><p>那么来到 <code>protoAugment</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从调用可以看到，target 是一个数组实例，那么这里的操作就是覆盖其原型。</p><p>那么 src 是什么呢？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br></pre></td></tr></table></figure><p>光看这个好像并不能看出点什么，结合下面的代码再看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methodsToPatch = [<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>显然，这里通过装饰器方法对 <code>methodsToPatch</code> 中的七个数组方法进行了扩展。</p><p>大致分为以下几步：</p><ul><li>先执行原来的数组方法（原有功能不变）</li><li>对于新插入的数据， 做响应式处理：<code>if (inserted) ob.observeArray(inserted)</code></li><li>通知 watcher 更新视图：<code>ob.dep.notify()</code></li></ul><p>最终脑图如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/bcb22159-5ef1-43d5-8b72-e2b994a608ea/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200817/us-west-2/s3/aws4_request&X-Amz-Date=20200817T080642Z&X-Amz-Expires=86400&X-Amz-Signature=73390add1165cce038d33e18a5332858d39bc32607e3365eace327cba22304c1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/8c0511b31a0745c4bc866d98dee89c39">Vue 2.6 源码分析之旅 - 二：数据响应式</a></p><p>那么本篇的粗浅分析到此为止，剩下的来日再议论吧！<br>咕咕咕~ 🐥 🐥 🐥</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.6 源码分析之旅【1】 —— 初始化流程</title>
      <link href="/2020/08/13/2020-08-12_1/"/>
      <url>/2020/08/13/2020-08-12_1/</url>
      
        <content type="html"><![CDATA[<p>Vue 源码还是比较庞大的，如果分析源码没有条理，直接一头扎进去，很容易陷进代码海中，一通分析下来一头雾水，还打击信心。</p><p>那么应该怎么分析源码呢？</p><p>以下是个人总结的几点经验，如有谬误之处，望指出：</p><ul><li>首要任务是找到入口，如 Vue 则找到其构造函数</li><li>先理清主线，后分析实现，别被细枝末节的代码影响思路</li></ul><p>那么接下来，我们就来尝试找找 Vue 的构造函数吧！</p><a id="more"></a><h2 id="寻找构造函数"><a href="#寻找构造函数" class="headerlink" title="寻找构造函数"></a>寻找构造函数</h2><p>对于这个问题，我们可以利用调试器，用最直接的办法定位到入口文件。</p><p>首先编写测试 demo，将断点定在 <code>new Vue(&#123;&#125;)</code> 处，通过 f11 进入构造函数，然后通过鼠标右键定位到目标文件：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/13c626a5-0b11-42f0-84a7-7d0d30f5a796/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200812/us-west-2/s3/aws4_request&X-Amz-Date=20200812T081104Z&X-Amz-Expires=86400&X-Amz-Signature=5129d2be261da3e658e60c84a935d5b058ddd816be91cd5729511aea3ee8bfe2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这就是 Vue 的构造函数了，其文件路径为：<code>src/core/instance/index.js</code> 。</p><p>当然，上面的方法能够快速有效的定位到目标文件，这能提高我们的分析效率，但这里我们也可以尝试一下另一种类似解密的分析思路，从蛛丝马迹中找到答案：</p><p>首先我们来看看 <code>pakage.json</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;</span><br></pre></td></tr></table></figure><p>从这里我们可以得到两个信息：</p><ul><li>配置文件是 <code>scripts/config.js</code></li><li>环境变量是 <code>TARGET:web-full-dev</code></li></ul><p>那么我们来到 <code>scripts/config.js</code>，定位到 <code>web-full-dev</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;web-full-dev&#x27;</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    dest: resolve(<span class="string">&#x27;dist/vue.js&#x27;</span>),</span><br><span class="line">    format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    env: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    alias: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entity-decoder&#x27;</span> &#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>从这里可以看到入口文件是 <code>web/entry-runtime-with-compiler.js</code>，但这个 web 是哪个目录呢？在 vscode 中利用 <code>ctrl + 鼠标左键</code> 可以来到 resolve 函数的定义处：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// web/...</span></span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>, p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 resolve 方法的返回是 aliases[base] + path，那么我们来看看 aliases 是什么：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  vue: resolve(<span class="string">&#x27;src/platforms/web/entry-runtime-with-compiler&#x27;</span>),</span><br><span class="line">  compiler: resolve(<span class="string">&#x27;src/compiler&#x27;</span>),</span><br><span class="line">  core: resolve(<span class="string">&#x27;src/core&#x27;</span>),</span><br><span class="line">  shared: resolve(<span class="string">&#x27;src/shared&#x27;</span>),</span><br><span class="line">  web: resolve(<span class="string">&#x27;src/platforms/web&#x27;</span>),</span><br><span class="line">  weex: resolve(<span class="string">&#x27;src/platforms/weex&#x27;</span>),</span><br><span class="line">  server: resolve(<span class="string">&#x27;src/server&#x27;</span>),</span><br><span class="line">  sfc: resolve(<span class="string">&#x27;src/sfc&#x27;</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，结果就出来了，入口文件是：<code>src/platforms/web/entry-runtime-with-compiler.js</code>，来到让我们来到这个文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      warn(<span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(<span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>, <span class="built_in">this</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">          warn(<span class="string">&#x27;invalid template option:&#x27;</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(</span><br><span class="line">        template,</span><br><span class="line">        &#123;</span><br><span class="line">          outputSourceRange: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">          shouldDecodeNewlines,</span><br><span class="line">          shouldDecodeNewlinesForHref,</span><br><span class="line">          delimiters: options.delimiters,</span><br><span class="line">          comments: options.comments,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      )</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件最主要的功能是扩展了 web 平台需要的 <code>$mount</code>，这也说明基本的 <code>$mount</code> 是不满足 web 平台的需求的。</p><p>在这个函数中，能看到以下比较重要的逻辑：</p><ul><li>如果存在 render 函数，则不再关注 template 和 el</li><li>当不存在 render 函数，则优先关注 template</li><li>当同时不存在 render 和 template，则最终选择 el，并且通过 <code>getOuterHTML</code> 将其转化为 template</li><li>处理完上面的逻辑之后将 template 通过 <code>compileToFunctions</code> 编译成 render 函数</li><li>最后调用 mount 将内容挂载到 root 节点上</li></ul><p>优先级：render &gt; template &gt; el</p><p>这里我们可以看到 Vue 是外部引入的，位置如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span></span><br></pre></td></tr></table></figure><p>随机来到目标文件 <code>src/platforms/webs/runtime/index.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这个文件主要做了一些对 vue 扩展的事情，最为关键的两点则是上面代码中的部分：</p><ul><li>安装了平台特有的 <strong><code>__patch__</code></strong> 函数，它的功能是将虚拟 dom 转化成真实 dom，而 diff 也将在这里发生</li><li>实现了 <code>$mount</code>，不过这里也只是对 mountComponent 的一层封装，并没有触及真正的功能代码</li></ul><p>接下来我们继续顺着引入 Vue 的线索推进：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;core/index&#x27;</span></span><br></pre></td></tr></table></figure><p>于是来到文件 <code>src/core/index</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initGlobalAPI(Vue)</span><br></pre></td></tr></table></figure><p>文件的核心功能就是初始化全局的 API，于是离开这里，继续深入：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./instance/index&#x27;</span></span><br></pre></td></tr></table></figure><p>终于来到了 Vue 的构造函数，代码在最上面已经贴出，这里就不再贴了。</p><p>脑图如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/aab5df86-ae2f-483f-935c-1fddad551dbd/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200812/us-west-2/s3/aws4_request&X-Amz-Date=20200812T081247Z&X-Amz-Expires=86400&X-Amz-Signature=2c8a6491c650faf82e82aa5bfe3887b94368d91c95a0ac6270ffae6f6a5db94f&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><h2 id="初始化流程分析"><a href="#初始化流程分析" class="headerlink" title="初始化流程分析"></a>初始化流程分析</h2><p>要分析 Vue 初始化流程，我们先来看看构造函数文件吧：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>可以看到，在构造函数中执行了一个 <code>this._init()</code> 方法进行初始化，那么这个方法从何而来呢？</p><p>我们往下，发现 <code>initMixin(Vue)</code> 这个方法，顾名思义，这应该是为 Vue 扩展 init 的方法，于是跳转进去看看：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    vm._uid = uid++</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> startTag, endTag</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">      mark(startTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a flag to avoid this being observed</span></span><br><span class="line">    vm._isVue = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">      <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">      <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">      <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">      initInternalComponent(vm, options)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      initProxy(vm)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vm._renderProxy = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">    initInjections(vm)</span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm)</span><br><span class="line">    callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">      vm._name = formatComponentName(vm, <span class="literal">false</span>)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，<code>_init()</code> 是在这里扩展的，它做了些什么呢？</p><p>仔细阅读后可以知道，它的核心功能有两点：</p><ul><li>进行各种初始化操作</li><li>如果设置了 el，则自动调用 <code>$mount</code> 进行挂载</li></ul><p>继续深入，来看看具体执行了哪些初始化操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">initLifecycle(vm)</span><br><span class="line">initEvents(vm)</span><br><span class="line">initRender(vm)</span><br><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">initInjections(vm)</span><br><span class="line">initState(vm)</span><br><span class="line">initProvide(vm)</span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们逐一分析：</p><h3 id="initLifecycle-vm"><a href="#initLifecycle-vm" class="headerlink" title="initLifecycle(vm)"></a>initLifecycle(vm)</h3><p>文件位置：<code>src/core/instance/lifecycle.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locate first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  vm.$root = parent ? parent.$root : vm</span><br><span class="line"></span><br><span class="line">  vm.$children = []</span><br><span class="line">  vm.$refs = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  vm._watcher = <span class="literal">null</span></span><br><span class="line">  vm._inactive = <span class="literal">null</span></span><br><span class="line">  vm._directInactive = <span class="literal">false</span></span><br><span class="line">  vm._isMounted = <span class="literal">false</span></span><br><span class="line">  vm._isDestroyed = <span class="literal">false</span></span><br><span class="line">  vm._isBeingDestroyed = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要初始化了以下关系：</p><ul><li>$root</li><li>$parent</li><li>$children</li><li>$refs</li></ul><h3 id="initEvents-vm"><a href="#initEvents-vm" class="headerlink" title="initEvents(vm)"></a>initEvents(vm)</h3><p>文件位置：<code>src/core/instance/events.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initEvents</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  vm._hasHookEvent = <span class="literal">false</span></span><br><span class="line">  <span class="comment">// init parent attached events</span></span><br><span class="line">  <span class="keyword">const</span> listeners = vm.$options._parentListeners</span><br><span class="line">  <span class="keyword">if</span> (listeners) &#123;</span><br><span class="line">    updateComponentListeners(vm, listeners)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里初始化了事件的监听者。</p><h3 id="initRender-vm"><a href="#initRender-vm" class="headerlink" title="initRender(vm)"></a>initRender(vm)</h3><p>文件位置：<code>src/core/instance/render.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._vnode = <span class="literal">null</span> <span class="comment">// the root of the child tree</span></span><br><span class="line">  vm._staticTrees = <span class="literal">null</span> <span class="comment">// v-once cached trees</span></span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  <span class="keyword">const</span> parentVnode = (vm.$vnode = options._parentVnode) <span class="comment">// the placeholder node in parent tree</span></span><br><span class="line">  <span class="keyword">const</span> renderContext = parentVnode &amp;&amp; parentVnode.context</span><br><span class="line">  vm.$slots = resolveSlots(options._renderChildren, renderContext)</span><br><span class="line">  vm.$scopedSlots = emptyObject</span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// $attrs &amp; $listeners are exposed for easier HOC creation.</span></span><br><span class="line">  <span class="comment">// they need to be reactive so that HOCs using them are always updated</span></span><br><span class="line">  <span class="keyword">const</span> parentData = parentVnode &amp;&amp; parentVnode.data</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">&#x27;$attrs&#x27;</span>,</span><br><span class="line">      (parentData &amp;&amp; parentData.attrs) || emptyObject,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$attrs is readonly.`</span>, vm)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">    defineReactive(</span><br><span class="line">      vm,</span><br><span class="line">      <span class="string">&#x27;$listeners&#x27;</span>,</span><br><span class="line">      options._parentListeners || emptyObject,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        !isUpdatingChildComponent &amp;&amp; warn(<span class="string">`$listeners is readonly.`</span>, vm)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defineReactive(vm, <span class="string">&#x27;$attrs&#x27;</span>, (parentData &amp;&amp; parentData.attrs) || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">    defineReactive(vm, <span class="string">&#x27;$listeners&#x27;</span>, options._parentListeners || emptyObject, <span class="literal">null</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要初始化了两个方法：</p><ul><li><code>$slots</code></li><li><code>$createElement</code></li></ul><h3 id="callHook-vm-‘beforeCreate’"><a href="#callHook-vm-‘beforeCreate’" class="headerlink" title="callHook(vm, ‘beforeCreate’)"></a>callHook(vm, ‘beforeCreate’)</h3><p>一直到这里，都处于 Vue 生命周期中的 <strong>beforeCreate</strong>，而上面的代码中完全没有对 data 的处理，所以在 <strong>beforeCreate</strong> 中显然是无法获取到 data 的。</p><h3 id="initInjections-vm"><a href="#initInjections-vm" class="headerlink" title="initInjections(vm)"></a>initInjections(vm)</h3><p>文件位置：<code>src/core/instance/inject.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInjections</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = resolveInject(vm.$options.inject, vm)</span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    toggleObserving(<span class="literal">false</span>)</span><br><span class="line">    <span class="built_in">Object</span>.keys(result).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        defineReactive(vm, key, result[key], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating an injected value directly since the changes will be `</span> +</span><br><span class="line">              <span class="string">`overwritten whenever the provided component re-renders. `</span> +</span><br><span class="line">              <span class="string">`injection being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        defineReactive(vm, key, result[key])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    toggleObserving(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注入了祖辈中的数据，以便在后面接收。</p><h3 id="initState-vm"><a href="#initState-vm" class="headerlink" title="initState(vm)"></a>initState(vm)</h3><p>文件位置：<code>src/core/instance/state.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe((vm._data = &#123;&#125;), <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里初始化了我们熟知的对象：</p><ul><li>props</li><li>methods</li><li>data</li><li>computed</li><li>watch</li></ul><p>从流程也可以看到，data 是晚于 props，先于 computed 的，这也能解决平时很多困扰我们的问题。</p><h3 id="initProvide-vm"><a href="#initProvide-vm" class="headerlink" title="initProvide(vm)"></a>initProvide(vm)</h3><p>文件位置：<code>src/core/instance/inject.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initProvide</span>(<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> provide = vm.$options.provide</span><br><span class="line">  <span class="keyword">if</span> (provide) &#123;</span><br><span class="line">    vm._provided = <span class="keyword">typeof</span> provide === <span class="string">&#x27;function&#x27;</span> ? provide.call(vm) : provide</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对前面注入的数据进行了接收。</p><h3 id="callHook-vm-‘created’"><a href="#callHook-vm-‘created’" class="headerlink" title="callHook(vm, ‘created’)"></a>callHook(vm, ‘created’)</h3><p>这里调用生命钩子，说明到 <strong>created</strong> 阶段，组件已经成功创建，所以初始化工作已经完成。</p><p>下面贴上脑图，方便大家参考：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6d7c4cff-625a-469b-9a28-ddd02ab3d449%2FUntitled.png?table=block&id=4f5bdb39-4be2-480b-a824-5743de54ffbd&name=Untitled.png&cache=v2"></p><p>接下来我们回到构造函数，看看剩下的 Mixin 都做了些什么：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure><p><code>initMixin()</code> 上面刚分析完，同样的，我们一步一步来看看下面的 Mixin 都做了些什么吧！</p><h3 id="stateMixin-Vue"><a href="#stateMixin-Vue" class="headerlink" title="stateMixin(Vue)"></a>stateMixin(Vue)</h3><p>文件位置：<code>src/core/instance/state.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">stateMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// flow somehow has problems with directly declared definition object</span></span><br><span class="line">  <span class="comment">// when using Object.defineProperty, so we have to procedurally build up</span></span><br><span class="line">  <span class="comment">// the object here.</span></span><br><span class="line">  <span class="keyword">const</span> dataDef = &#123;&#125;</span><br><span class="line">  dataDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> propsDef = &#123;&#125;</span><br><span class="line">  propsDef.get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._props</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    dataDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">&#x27;Avoid replacing instance root $data. &#x27;</span> + <span class="string">&#x27;Use nested data properties instead.&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    propsDef.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(<span class="string">`$props is readonly.`</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$data&#x27;</span>, dataDef)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$props&#x27;</span>, propsDef)</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$set = set</span><br><span class="line">  Vue.prototype.$delete = del</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params">expOrFn: string | Function, cb: any, options?: Object</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">      <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">    &#125;</span><br><span class="line">    options = options || &#123;&#125;</span><br><span class="line">    options.user = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">    <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(vm, watcher.value)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        handleError(error, vm, <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实顾名思义，已经能大致猜到这里的功能了（ps：这也是一个好的命名规范带来的好处）。不过这里还是结合代码分析，这里扩展了以下功能：</p><ul><li><code>$data</code></li><li><code>$props</code></li><li><code>$set</code></li><li><code>$delete</code></li><li><code>$watch</code></li></ul><h3 id="eventsMixin-Vue"><a href="#eventsMixin-Vue" class="headerlink" title="eventsMixin(Vue)"></a>eventsMixin(Vue)</h3><p>文件位置：<code>src/core/instance/events.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">eventsMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">  Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        vm.$on(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ;(vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">      <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">      <span class="comment">// instead of a hash lookup</span></span><br><span class="line">      <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">        vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      vm.$off(event, on)</span><br><span class="line">      fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    on.fn = fn</span><br><span class="line">    vm.$on(event, on)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// all</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// array of events</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">        vm.$off(event[i], fn)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific event</span></span><br><span class="line">    <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">    <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      vm._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// specific handler</span></span><br><span class="line">    <span class="keyword">let</span> cb</span><br><span class="line">    <span class="keyword">let</span> i = cbs.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">      <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">        tip(</span><br><span class="line">          <span class="string">`Event &quot;<span class="subst">$&#123;lowerCaseEvent&#125;</span>&quot; is emitted in component `</span> +</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for &quot;<span class="subst">$&#123;event&#125;</span>&quot;. `</span> +</span><br><span class="line">            <span class="string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +</span><br><span class="line">            <span class="string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +</span><br><span class="line">            <span class="string">`You should probably use &quot;<span class="subst">$&#123;hyphenate(event)&#125;</span>&quot; instead of &quot;<span class="subst">$&#123;event&#125;</span>&quot;.`</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">      <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">const</span> info = <span class="string">`event handler for &quot;<span class="subst">$&#123;event&#125;</span>&quot;`</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">        invokeWithErrorHandling(cbs[i], vm, args, vm, info)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是扩展事件相关的方法：</p><ul><li><code>$on</code></li><li><code>$once</code> - 这个方法在平时业务开发中非常少用</li><li><code>$off</code></li><li><code>$emit</code></li></ul><h3 id="lifecycleMixin-Vue"><a href="#lifecycleMixin-Vue" class="headerlink" title="lifecycleMixin(Vue)"></a>lifecycleMixin(Vue)</h3><p>文件位置：<code>src/core/instance/lifecycle.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// remove self from parent</span></span><br><span class="line">    <span class="keyword">const</span> parent = vm.$parent</span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">      remove(parent.$children, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// teardown watchers</span></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = vm._watchers.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      vm._watchers[i].teardown()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// remove reference from data ob</span></span><br><span class="line">    <span class="comment">// frozen object may not have observer.</span></span><br><span class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</span><br><span class="line">      vm._data.__ob__.vmCount--</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// call the last hook...</span></span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// fire destroyed hook</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">    <span class="comment">// turn off all instance listeners.</span></span><br><span class="line">    vm.$off()</span><br><span class="line">    <span class="comment">// remove __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release circular reference (#6759)</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode) &#123;</span><br><span class="line">      vm.$vnode.parent = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里扩展了生命周期相关的方法：</p><ul><li><code>_update</code>：这是核心的更新函数</li><li><code>$forceUpdate</code></li><li><code>$destroy</code></li></ul><h3 id="renderMixin-Vue"><a href="#renderMixin-Vue" class="headerlink" title="renderMixin(Vue)"></a>renderMixin(Vue)</h3><p>文件位置：<code>src/core/instance/render.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">renderMixin</span>(<span class="params">Vue: Class&lt;Component&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// install runtime convenience helpers</span></span><br><span class="line">  installRenderHelpers(Vue.prototype)</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$nextTick = <span class="function"><span class="keyword">function</span> (<span class="params">fn: Function</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextTick(fn, <span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">    <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    <span class="comment">// render self</span></span><br><span class="line">    <span class="keyword">let</span> vnode</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">      <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">      <span class="comment">// when parent component is patched.</span></span><br><span class="line">      currentRenderingInstance = vm</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">      <span class="comment">// return error render result,</span></span><br><span class="line">      <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">      <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">      vnode = vnode[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">    <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> + <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set parent</span></span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是扩展了渲染相关的方法：</p><ul><li><code>$nextTick</code>：这个方法非常有意思，后面将深入分析</li><li><code>_render</code></li></ul><p>老规矩，上脑图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F593e548f-0163-4539-80f0-5445f097aae3%2FUntitled.png?table=block&id=9de497b7-2bea-4fda-a9e6-ea0c08126c85&name=Untitled.png&cache=v2"></p><p>如果写一个测试 demo 调试，会发现，当上面的流程都执行完成之后，页面中还没有渲染出对应的内容，这是因为还没有执行 vue 初始化最重要的一步：<strong>挂载</strong>。接下来就来看看 vue 中是如何进行挂载的。</p><p>相信大家对前面提到的流程熟悉的话，对 mount 应该有一定的印象：<strong>打包入口文件中最重要的功能就是扩展 mount</strong>。</p><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>通过基本分析，我们可以找到实现 mount 的位置：<code>src/platforms/web/runtime/index.js</code> ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是 mountComponent 这个方法实现了 mount 的核心功能，让我们追进去看看。</p><p>文件位置：<code>core/instance/lifecycle.js</code> ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm: Component, el: ?Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) || vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    &#123;</span><br><span class="line">      before() &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">          callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  )</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程并不复杂：</p><ul><li>首先调用了 <code>beforeMount</code> 钩子</li><li>随后调用了 <code>updateComponent</code> 进行组件的更新</li><li>然后创建了一个 Wathcer，并在其中调用了 <code>beforeUpdate</code> 钩子</li><li>最后调用 <code>mounted</code> 钩子</li></ul><p>从流程可以看出，挂载的核心功能应该是在 <code>updateComponent</code> 进行的，而它的核心功能就是先执行 <code>_render()</code>，后执行 <code>_update()</code>。</p><p>而这两个方法，我们进入看看：</p><h3 id="render"><a href="#render" class="headerlink" title="_render()"></a><code>_render()</code></h3><p>文件位置：<code>src/core/instance/render.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">    <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">    <span class="comment">// when parent component is patched.</span></span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="comment">// return error render result,</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">    vnode = vnode[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> + <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vnode = createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里经过一系列的处理，主要是为了得到虚拟 dom</p><h3 id="update"><a href="#update" class="headerlink" title="_update()"></a><code>_update()</code></h3><p>文件位置：<code>src/core/instance/lifecycle.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最核心的功能是 <code>__patch__</code>，即将虚拟 dom 转化为真实 dom。</p><p>脑图如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ed5e315e-17b3-46c2-894d-630ec24b0948/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200813/us-west-2/s3/aws4_request&X-Amz-Date=20200813T075542Z&X-Amz-Expires=86400&X-Amz-Signature=52c20bde3d36341ba0d4d2bccaf1daeb209dd244027b135dd938cf92a23f9bc1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><h2 id="调试验证"><a href="#调试验证" class="headerlink" title="调试验证"></a>调试验证</h2><p>前面一通分析，挺有道理，但只是理论如此，不稳，这里我们通过调试器一步步执行，来验证一下我们的想法是否正确：</p><h3 id="Step-1-确定初始化函数"><a href="#Step-1-确定初始化函数" class="headerlink" title="Step 1 - 确定初始化函数"></a>Step 1 - 确定初始化函数</h3><p>测试 demo 就不贴出来了，随便一个 vue 样例都行，我们从 <code>new Vue()</code> 处进入即可：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1f4df573-9625-4a6c-91df-da5831ecfe10/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200813/us-west-2/s3/aws4_request&X-Amz-Date=20200813T075706Z&X-Amz-Expires=86400&X-Amz-Signature=968758b047e8e5677ed25e77dc686b5dd9dd7e675a38d8c91600acab8426d741&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>显然，这里只会执行 <code>_init</code>，也即是说这就是初始化函数，也验证了上面的猜想。</p><h3 id="Step-2-验证执行流程"><a href="#Step-2-验证执行流程" class="headerlink" title="Step 2 - 验证执行流程"></a>Step 2 - 验证执行流程</h3><p>前面猜测执行 <code>initState(Vue)</code> 之前是无法访问到 data 数据的，这个也很好验证，我们先看看执行之前的 vm：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F04c2cd84-fa12-4977-9a4e-9b2c528dc471%2FUntitled.png?table=block&id=c55cff8f-82a3-492b-a55f-0fa26dc574ae&name=Untitled.png&cache=v2"></p><p>可以看到，这个时候 data 和 props 都还无法访问，接下来单步执行 <code>initState(Vue)</code>，再看看结果：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/ce7d0bd5-1f04-49a1-a1d3-e00ec0e8e032/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200813/us-west-2/s3/aws4_request&X-Amz-Date=20200813T075802Z&X-Amz-Expires=86400&X-Amz-Signature=17ede0ddca6635fe9c8e1f138349af87eed9c18d9245a086e3f33323f1151357&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>显然，这个时候 data 已经有值了，而 props 之所以还是 undefined，是因为这里本就没有父组件进行传值。</p><h3 id="Step-3-验证挂载"><a href="#Step-3-验证挂载" class="headerlink" title="Step 3 - 验证挂载"></a>Step 3 - 验证挂载</h3><p>同样，我们现在将断点定在 <code>updateComponent</code> 即可，执行 <code>_update</code> 之前：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2d67f1ea-07d2-4d0a-830f-efbd9048a432/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200813/us-west-2/s3/aws4_request&X-Amz-Date=20200813T075821Z&X-Amz-Expires=86400&X-Amz-Signature=c79a93ec83121556a6b08a4f464d9af9c0a7bd9f99be361463fda597cd34f3a7&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>执行 _update 之后：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F19199f47-7d19-4836-bee1-e8fc46965c06%2FUntitled.png?table=block&id=c640f58d-6b19-440c-816d-1041eda5cbb0&name=Untitled.png&cache=v2"></p><p>上面的结果与我们分析 vue 源码得来的结论无异，这能很好的提升士气和信心，为接下来的源码学习之旅打下不错的基础。</p><p>那么本篇的粗浅分析到此为止，剩下的来日再议论吧！</p><p>咕咕咕~ 🐥 🐥 🐥</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/37c7e6218fc449a684ace2de187f18d7">Vue 2.6 源码分析之旅 - 一：初始化流程</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2.6 源码分析之旅【0】 —— 调试环境搭建</title>
      <link href="/2020/08/12/2020-08-12/"/>
      <url>/2020/08/12/2020-08-12/</url>
      
        <content type="html"><![CDATA[<p>以前很多 vue 原理相关的知识，比如响应式，比如虚拟 dom，比如 diff 算法……但都没有真正深入的看过源码，正因为此，这些知识宛如空中楼阁，空洞且并没有什么说服力。所以今天开始对 vue 进行粗浅的源码分析。</p><p>要分析源码，自然首先要搭建调试环境，这样才可以通过编写测试 demo 快速定位到我们想要分析的位置。</p><p>那么开始吧！</p><a id="more"></a><h2 id="Step-1-克隆源码"><a href="#Step-1-克隆源码" class="headerlink" title="Step 1 - 克隆源码"></a>Step 1 - 克隆源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:vuejs/vue.git</span><br></pre></td></tr></table></figure><h2 id="Step-2-安装环境"><a href="#Step-2-安装环境" class="headerlink" title="Step 2 - 安装环境"></a>Step 2 - 安装环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install // 安装到 phantom 时就可以终止了</span><br><span class="line">npm install rollup -g</span><br></pre></td></tr></table></figure><h2 id="Step-3-修改运行参数"><a href="#Step-3-修改运行参数" class="headerlink" title="Step 3 - 修改运行参数"></a>Step 3 - 修改运行参数</h2><p>文件：<code>root/pakage.json</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --environment TARGET:web-full-dev&quot;</span><br><span class="line">+ &quot;dev&quot;: &quot;rollup -w -c scripts/config.js --sourcemap --environment TARGET:web-full-dev&quot;</span><br></pre></td></tr></table></figure><h2 id="Step-4-编译源码"><a href="#Step-4-编译源码" class="headerlink" title="Step 4 - 编译源码"></a>Step 4 - 编译源码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="Step-5-测试调试流程"><a href="#Step-5-测试调试流程" class="headerlink" title="Step 5 - 测试调试流程"></a>Step 5 - 测试调试流程</h2><p>到这里，如果在 <code>root/dist</code> 目录下新生成了一个 <code>vue.js.map</code> 文件，则说明应该已经成功建立了 map 映射关系，这里在 <code>root/examples/test-demo</code> 下建立一个测试文件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;../../dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;demo&quot;</span>&gt;</span><br><span class="line">        &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">     <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">        data: &#123; <span class="attr">name</span>: <span class="string">&#x27;vue&#x27;</span> &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>打开这个页面，在浏览器中进行调试，将断点定在创建实例的这一行：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F295957b7-bb20-4ed2-b3ca-f5e9f0bc3f85%2FUntitled.png?table=block&id=a2dfd7d8-ead4-4766-aef7-7a601c9492b3&name=Untitled.png&cache=v2"></p><p>成功断下来之后，按 f11 进入函数，然后在点击鼠标右键，选择：Reveal in sidebar，如果左侧侧边栏中出现 vue 的目录结构，则说明调试环境已经搭建成功：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa49dd200-4a44-4ca7-91df-7fab2a57eb68%2FUntitled.png?table=block&id=79748268-631f-460a-901e-2c336f18b7a8&name=Untitled.png&cache=v2"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/7e28290bbbf94a49bac13ecb3869f33e">Vue 2.6 源码分析之旅 - 零：调试环境搭建</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端造轮子【3】 —— mvvm</title>
      <link href="/2020/08/11/2020-08-10/"/>
      <url>/2020/08/11/2020-08-10/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vue2 的响应式实现原理。</p><p>这里是前辈研究 vue 响应式原理缩写的代码和文章，非常具有学习价值，强烈建议阅读完本文之后继续学习：<a href="https://github.com/DMQ/mvvm">《剖析 Vue 实现原理 - 如何实现双向绑定 mvvm》</a></p><a id="more"></a><h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>首先来看看官网给出的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8cdd58cf-e3f9-47cf-94df-dea71154bfbc%2FGIF_2020-8-7_15-41-20.gif?table=block&id=40f4e036-bdb2-4208-a76e-919db64017da&name=GIF_2020-8-7_15-41-20.gif&cache=v2"></p><p>这个例子很好的展示了 mvvm 的核心功能：</p><ul><li>数据驱动视图更新</li></ul><p>再结合代码看看，我们发现这里的定义并不复杂，仅仅是：</p><ul><li>el：指定跟节点</li><li>data：定义响应式数据</li><li>插值表达式：渲染变量</li><li>v-xxx：vue 指令</li></ul><p>从上面我们能得到什么信息呢？</p><p>显然，我们要对节点进行解析，解析其中的插值表达式和 v-xxx 指令，这个功能我们可以叫它 <strong>Compiler</strong>。然后我们还需要对 data 中的数据进行劫持，当其中的数据发生 <code>get/set</code> 的时候，能够进行自定义的操作，这个功能我们叫它 <strong>Observer</strong>。最后我们需要监听这些数据，当他们发生改变的时候，通知视图去进行更新操作，这个功能我们叫它 <strong>Watcher</strong>。</p><p>这里引用一下大佬的图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4219c573-3b0c-42fe-a9d8-56201571c7d0%2FUntitled.png?table=block&id=86609f8d-52e7-40a0-9bfa-5923ebe2472b&name=Untitled.png&cache=v2"></p><p>可以看到，除了上面我们提到的三个模块以外，这里还多了 Updater 和 Dep，Updater 倒还好理解，但这 Dep 是干嘛的呢？</p><p>我们知道，data 和 view 中的显示存在多对多的关系，如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">;<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>1: &#123;&#123; data_1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>2: &#123;&#123; data_1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>3: &#123;&#123; data_2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>4: &#123;&#123; data_3 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>5: &#123;&#123; data_3 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    data_1: <span class="number">1</span>,</span><br><span class="line">    data_2: <span class="number">2</span>,</span><br><span class="line">    data_3: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的代码中：</p><ul><li>当 data_1 发生改变的时候，p1 和 p2 都要重新渲染</li><li>当 data_2 发生改变的时候，p3 要重新渲染</li><li>当 data_3 发生改变的时候，p4 和 p5 都要重新渲染</li></ul><p>显然这需要被控制管理起来，否则视图的更新肯定是一团乱，而 Dep 就是用来做这个的，我们可以看看下面这张图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F33318536-5b7b-4979-841e-610e8d074724%2FUntitled.png?table=block&id=84472cd8-70f1-4138-aab5-9fe74e7b0fe8&name=Untitled.png&cache=v2"></p><p>从上图可以看到：</p><ul><li>view 中每一个需要被渲染的值对应一个 Watcher</li><li>每一个响应式变量对应一个 Dep</li></ul><p>那么更新流程就应该是这样：当是数据更新的时候，Observer 通知对应的 Dep，然后 Dep 通知自己管理的 Watcher 调用 Updater 进行视图的更新。</p><p>当然，最后我们需要一个入口作为桥梁，将上面的各个模块给联系起来，组合成一个完整的 mvvm 框架。</p><p>大致的思路已经有了，那么开始吧，it’s show time！</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>首先再来看看官方示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=<span class="string">&quot;message&quot;</span>&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里 <code>new</code> 了一个 Vue，并且只传了一个 obj 进去，那么我们最终对外暴露的对象也应当如此。</p><blockquote><p>总所周知，vue 是法语视图的意思，那么这里就用它的好朋友来作为命名语言吧</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Aus &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;)&#123;</span><br><span class="line">        <span class="built_in">this</span>.$options = options;</span><br><span class="line">    <span class="built_in">this</span>.$el = options.el;</span><br><span class="line">    <span class="built_in">this</span>.$data = options.data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.$el) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;请指定挂载点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们就来实现模板的解析。</p><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>我们来分析一下 Compiler 需要做什么：</p><ul><li>通过 el 获取需要被编译的 root 节点</li><li>进行模板编译</li><li>将编译后的节点覆盖到 root 节点的位置</li></ul><p>而模板编译应该怎么进行呢？</p><ul><li>首先我们可以将节点碎片化，在内存中处理</li><li>遍历当前的节点树，这里我们只关注两类节点：<ul><li>元素节点：处理 <code>a-xxx</code> 指令</li><li>文本节点：处理插值表达式</li></ul></li><li>将编译好的节点碎片 append 到 root 节点上</li></ul><p>那么我们的问题就来到了如何处理文本和元素节点：</p><ul><li>元素节点：<code>node.attributes</code></li><li>文本节点：正则表达式</li></ul><p>进过上面一通分析，整个结构已经比较清晰了，这里再补上脑图：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa077d9b8-3dff-4a7b-8f00-21a5eaf948ae%2FUntitled.png?table=block&id=244ae090-c483-48b7-9f43-9e0930a566d8&name=Untitled.png&cache=v2"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;单层：&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p a-text=<span class="string">&quot;msg&quot;</span>&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">  <span class="keyword">import</span> Aus <span class="keyword">from</span> <span class="string">&#x27;./aus.js&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> am = <span class="keyword">new</span> Aus(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Hello Aussicht!&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F69ef04bd-e24c-4320-962f-ec21ea636903%2FUntitled.png?table=block&id=c72dfd75-06a9-4871-8046-daf996caca05&name=Untitled.png&cache=v2"></p><p>可以看到，这里已经成功将 <code>a-text</code> 和插值表达式替换成了我们想要渲染的变量了。</p><p>接下来我们想要实现的效果是当数据发生改变的时候，视图也随之更新，那么首先应该实现的是 Observer。</p><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p>同样的，我们来分析一下 Observer 需要做什么。</p><p>事实上，仅仅考虑数据劫持这一层面的话，Observer 需要实现的功能非常简单，就是利用 <code>Object.defineProperty</code> 对 data 进行代理即可。</p><p>流程很简单：</p><ul><li>获取 data 的所有 key，对其进行劫持</li><li>如果 data 的 key 为 obj，则递归</li></ul><p>脑图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8f14c21f-c5c5-4898-b208-0d7aa9085626%2FUntitled.png?table=block&id=43a1c4ac-355e-4668-93eb-caf0af0170c9&name=Untitled.png&cache=v2"></p><blockquote><p>本文主要是简单探讨一下 mvvm 实现原理，这里对于数组就不做处理了。</p></blockquote><p>代码很简单，按照上面的思路进行实现即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">&#x27;./dep.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.observe(<span class="built_in">this</span>.data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observe(data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.defineReactive(data, key, data[key])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defineReactive(obj, key, value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observe(value)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">false</span>,</span><br><span class="line">      get: <span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      set: <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对新设置的值进行监听</span></span><br><span class="line">        <span class="built_in">this</span>.observe(newVal)</span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer</span><br></pre></td></tr></table></figure><p>接下来就是最关键的，当数据发生改变的时候，通知视图进行更新渲染了。</p><h3 id="Watcher-amp-amp-Dep"><a href="#Watcher-amp-amp-Dep" class="headerlink" title="Watcher &amp;&amp; Dep"></a>Watcher &amp;&amp; Dep</h3><p>这里我们一步步分析一下：</p><ul><li>Watcher 一一对应模板中的变量（插值表达式 or <code>a-text</code>）</li><li>Dep 对应具体变量</li><li>Observer 能发出通知</li></ul><p>只有当变量发生改变的时候，模板中对应的地方需要发生重新渲染，所以流程应该是：</p><ul><li>Observer 通知 Dep，变量发生改变</li><li>Dep 管理了一个 Watcher 数组，执行 Watcher 的 update 方法，更新视图</li></ul><p>那么现在的问题是，怎么建立 Dep 和 Watcher 的关系。</p><p>显然，模板中每有一个需要渲染的值，就应该有一个对应的 Watcher，而这个值在初始化的时候会进行 <code>get</code> 操作，那么自然是在 <code>get</code> 中进行操作最合适：</p><p>同样，在修改值得之后会进行 <code>set</code> 操作，那么在 <code>set</code> 的时候利用 dep 通知 Watcher 进行操作也最合适。</p><p>综上：</p><ul><li>Dep 至少需要管理一个 Watcher 数组，一个添加 Watcher 的方法，一个通知 Watcher 更新视图的方法</li><li>Watcher 在初始化的时候创建，管理 Update 方法</li></ul><p>脑图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15307dfb-6688-4efe-9b28-fc372da2d52e%2FUntitled.png?table=block&id=58b7763d-4d68-4d68-9419-b0e1d98583ea&name=Untitled.png&cache=v2"></p><p>那么这里，首先我们需要改造一下 Compiler，在渲染模板的时候创建 Watcher：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">  text(node, exp, am) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(exp, am)</span><br><span class="line">    <span class="keyword">const</span> updaterFn = <span class="function">(<span class="params">node, value</span>) =&gt;</span> &#123;</span><br><span class="line">      node.textContent = value</span><br><span class="line">    &#125;</span><br><span class="line">    updaterFn &amp;&amp; updaterFn(node, value)</span><br><span class="line">    <span class="keyword">new</span> Watcher()</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getValue(exp, am) &#123;</span><br><span class="line">    <span class="keyword">return</span> exp.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">d, c</span>) =&gt;</span> d[c], am.$data)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setValue(exp, am, value) &#123;</span><br><span class="line">    exp.split(<span class="string">&#x27;.&#x27;</span>).forEach(<span class="function">(<span class="params">k, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">        am = am[k]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am[k] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们后期不可能只处理 <code>a-text</code> 指令，所以这里可以对工具方法进行一些封装优化：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">  text(node, exp, am) &#123;</span><br><span class="line">    <span class="built_in">this</span>.bind(node, exp, am, <span class="string">&#x27;text&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bind(node, exp, am, dir) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(exp, am)</span><br><span class="line">    <span class="keyword">const</span> updaterFn = updaterUtil[dir]</span><br><span class="line">    updaterFn &amp;&amp; updaterFn(node, value)</span><br><span class="line">    <span class="keyword">new</span> Watcher()</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getValue(exp, am) &#123;</span><br><span class="line">    <span class="keyword">return</span> exp.split(<span class="string">&#x27;.&#x27;</span>).reduce(<span class="function">(<span class="params">d, c</span>) =&gt;</span> d[c], am.$data)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  setValue(exp, am, value) &#123;</span><br><span class="line">    exp.split(<span class="string">&#x27;.&#x27;</span>).forEach(<span class="function">(<span class="params">k, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt; exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">        am = am[k]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        am[k] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> updaterUtil = &#123;</span><br><span class="line">  text(node, value) &#123;</span><br><span class="line">    node.textContent = value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> compileUtil</span><br></pre></td></tr></table></figure><p>因为这里我们通过 <code>getValue</code> 获取了 data 中的值，所以必然会触发 <code>get</code> 操作，那么就来到了 Observer 中。</p><p>前面我们一直反复提到，一个变量对应一个 Dep，所以这里我们在 <code>defineReactive</code> 中创建 dep 实例，<strong>在 get 中调用 dep 的 addWatcher 方法</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  defineReactive(obj, key, value) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      get: <span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">        dep.addWatcher(Watcher)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，<strong>在 set 中调用 dep 的 notify 方法</strong>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  defineReactive(obj, key, value) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">      set: <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 对新设置的值进行监听</span></span><br><span class="line">        <span class="built_in">this</span>.observe(newVal)</span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          value = newVal</span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中还存在一个问题，在 get 中有一行代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.addWatcher(Watcher)</span><br></pre></td></tr></table></figure><p>这个 Watcher 从哪里来呢？</p><p>那么我们来到 Watcher。</p><p>Watcher 需要什么呢？这个我们知道它的功能就很清楚了：</p><ul><li>它需要获取当前的 data 值，所以需要 am 实例，以及值对应的 key</li><li>它需要更新视图，所以需要 update 回调函数</li></ul><p>那么构造函数如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(am, exp, cb) &#123;</span><br><span class="line">    <span class="built_in">this</span>.am = am</span><br><span class="line">    <span class="built_in">this</span>.exp = exp</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.oldValue = <span class="built_in">this</span>.getOldValue()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在执行 <code>getOldValue</code> 的时候，我们可以做一些灵活的小操作：</p><p>因为 <code>getOldValue</code> 必定触发 <code>get</code>，所以我们可以在 <code>get</code> 之前将 Watcher 挂载到 Dep 上，在 <code>get</code> 之后清空即可，这样就可以在 <code>get</code> 中获取到 Watcher 了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  getOldVal() &#123;</span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> oldVal = compileUtil.getValue(<span class="built_in">this</span>.exp, <span class="built_in">this</span>.am)</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> oldVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watcher 的功能是在 value 变化的时候进行视图更新，自然还需要一个 updater 方法，而这个方法只需要在 oldValue ≠ newValue 的时候调用回调函数更新视图即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  updater() &#123;</span><br><span class="line">    <span class="keyword">const</span> newValue = compileUtil.getValue(<span class="built_in">this</span>.exp, <span class="built_in">this</span>.am)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.oldValue !== newValue) &#123;</span><br><span class="line">      <span class="built_in">this</span>.cb(newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么创建 Watcher 的时候，参数也很好填了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compileUtil = &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  bind(node, exp, am, dir) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.getValue(exp, am)</span><br><span class="line">    <span class="keyword">const</span> updaterFn = updaterUtil[dir]</span><br><span class="line">    updaterFn &amp;&amp; updaterFn(node, value)</span><br><span class="line">    <span class="keyword">new</span> Watcher(am, exp, <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      updaterFn &amp;&amp; updaterFn(node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Watcher 搞定了，那么管理 Watcher 的 Dep 就很简单了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers = []</span><br><span class="line">  &#125;</span><br><span class="line">  addWatcher(w) &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers.push(w)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="built_in">this</span>.watchers.forEach(<span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">      w.updater()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改一下 Observer 中的 get，这样整个流程就都通了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get: <span class="function">(<span class="params">_</span>) =&gt;</span> &#123;</span><br><span class="line">  Dep.target &amp;&amp; dep.addWatcher(Dep.target)</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下所示：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/aa45502c-4811-4177-b733-f64f998664c3/1111.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200810/us-west-2/s3/aws4_request&X-Amz-Date=20200810T080716Z&X-Amz-Expires=86400&X-Amz-Signature=5a24f8999af887fe940e8fb75118215976db8ce0b7262c83950f0a3b4ab790f3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%221111.gif%22"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更加阅读体验：<a href="https://www.notion.so/01-MVVM-24ae2e3c17a9403689c01a73879939de">手写简易 MVVM</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端造轮子【2】 —— vuex</title>
      <link href="/2020/08/10/2020-08-07_3/"/>
      <url>/2020/08/10/2020-08-07_3/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vuex 的内部实现原理。<br>我们知道 vuex 是 vue 官方的状态管理库。至于什么是状态管理库呢？这个大概要从 flux 说起。大家感兴趣的可以看看阮一峰老师的文章：<a href="http://www.ruanyifeng.com/blog/2016/01/flux.html">Flux 架构入门教程</a></p><a id="more"></a><h2 id="Step-1-需求分析"><a href="#Step-1-需求分析" class="headerlink" title="Step 1 - 需求分析"></a>Step 1 - 需求分析</h2><p>首先用 vue-cli 4.x 创建一个空项目，选择使用 vuex，等项目创建好之后，在 src 目录下应该存在一个 store 文件，其内容大致如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;./yvuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num = <span class="number">1</span>) &#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    add(&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用过状态管理库的同学应该很清楚 action 主要用于处理异步操作，那么这里我们暂时先不关心它，把同步操作处理完之后再来看它就会清晰很多了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;./yvuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    counter: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state, num = <span class="number">1</span>) &#123;</span><br><span class="line">      state.counter += num</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>从上述代码，我们可以分析出以下几点：</p><ul><li>首先 vuex 是 vue 的插件，首先会 use，在这个时候调用其 install 方法</li><li>通过 new 新建实例的是 vuex 上的 store 对象而非 vuex 本身</li><li>导出的 store 会在 main 中传给 vue（这一部分在 main 中，而不在上述代码中）</li></ul><p>那么我们的 vuex 应该如何设计呢？</p><p>我认为应该结合 vuex 的使用来进行分析：</p><p>我们知道，在项目中使用 vuex 的时候，通常形如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.xxx</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line"><span class="comment">// this.$store.dispatch(&#x27;xxx&#x27;) 异步，暂不考虑</span></span><br></pre></td></tr></table></figure><p>显然，首先我们需要把 store 挂载到 vue 实例上，其次，store 上还应该有 state 和 commit，它们两分别是一个 object 和一个 function。</p><p>此时的思维导图如下所示：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F37d63332-0523-4378-a750-fefa7ba0b199%2FUntitled.png?table=block&id=67b0c40c-de87-419a-9554-5380607058a4&name=Untitled.png&cache=v2"></p><h2 id="Step-2-功能实现"><a href="#Step-2-功能实现" class="headerlink" title="Step 2 - 功能实现"></a>Step 2 - 功能实现</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><p>那么我们按照这样的方式构建 vuex：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export default Vuex</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install(Vue) &#123;</span><br><span class="line">    Vue.mixin(&#123;</span><br><span class="line">      beforeCreate() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.$options.store) &#123;</span><br><span class="line">          Vue.prototype.$store = <span class="built_in">this</span>.$options.store</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    commit() &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再回到 store 中，可以看到在创建 store 实例的时候，我们传递了两个对象：</p><ul><li>state：用于存储状态</li><li>mutations：用于同步修改状态</li></ul><p>也就是说，在构建实例的过程中，我们将 state 存储到 <code>$store.state</code> 中，将 mutations 存储起来，在 commit 的时取出调用，思维导图如下：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff257c80b-36e4-4465-9736-1711a4042102%2FUntitled.png?table=block&id=9adb43b6-90c0-41b5-8631-f5e88ef244b3&name=Untitled.png&cache=v2"></p><p>那么我们对应实现的代码应该是：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="built_in">this</span>._mutations = options.mutations</span><br><span class="line">      <span class="built_in">this</span>.state = options.state</span><br><span class="line">    &#125;</span><br><span class="line">    commit(type, payload) &#123;</span><br><span class="line">      <span class="keyword">const</span> mutation = <span class="built_in">this</span>._mutations[type]</span><br><span class="line">      <span class="keyword">return</span> mutation(<span class="built_in">this</span>.state, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，已经能从 <code>this.$store.state</code> 中取出 counter 了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F03a44026-f9c7-44f5-a54d-8fa0f1cf9c7b%2FUntitled.png?table=block&id=81afa976-f2da-488e-9953-58ffe5e0c03b&name=Untitled.png&cache=v2"></p><p>并且 commit 也能成功调用了：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/02c95c62-273b-466a-a386-7c1699c128b9/20200804_151559.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064340Z&X-Amz-Expires=86400&X-Amz-Signature=b3e701454c05012c56b755b52245c41cd300f0fc5cbb1cec2ebb91228ee47804&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_151559.gif%22"></p><p>但这里还有问题，最关键的就是 counter 的改变并没有引起页面的重新渲染。显然我们应该将 state 改成响应式数据，在 <strong><a href="https://www.notion.so/vue-router-5e3643ff7f344645bf6fa0b0a4229115">手写简易 vue-router</a></strong> 中我们使用了 vue 官方提供的静态方法：Vue.util.defineReactive</p><p>那么这里我们就尝试使用另一个办法来实现响应式数据：创建 vue 实例，利用其中的 data 方法将 state 转化为响应式数据，实际代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="built_in">this</span>._mutations = options.mutations</span><br><span class="line">      <span class="built_in">this</span>._vm = <span class="keyword">new</span> _Vue(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 由于不希望数据被代理，所以这里加上 $</span></span><br><span class="line">            $$state: options.state,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">state</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._vm._data.$$state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">state</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="comment">// 不允许直接修改 state</span></span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;please use replaceState to reset state&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再看看效果如何：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/225b951d-b4e3-4269-96d8-9098cde9a564/20200804_152810.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064401Z&X-Amz-Expires=86400&X-Amz-Signature=43a805fe1b46aa3cda736db7c3f941429f106732f3b8169e4a622de1e38e5039&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_152810.gif%22"></p><p>至此，一个最最基础的 store 已经基本实现了，接下来自然是异步操作的 action 了。</p><h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>其实明白了 mutations，actions 也已经清楚了大半，唯一的区别就是 action 中我们需要调用 commit 来修改 state，那么这个 commit 从哪里来自然就很清楚了：this</p><p>导图如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/3b4df158-3376-4f94-ad02-735b70506667/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064423Z&X-Amz-Expires=86400&X-Amz-Signature=bb52c64a51045faa72e617d8d4f61ab910fc7d8c92232a15ecdcbff67038a8a3&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>实现代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">      <span class="built_in">this</span>._actions = options.actions</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">    dispatch(type, payload) &#123;</span><br><span class="line">      <span class="keyword">const</span> action = <span class="built_in">this</span>._actions[type]</span><br><span class="line">      <span class="keyword">return</span> action(<span class="built_in">this</span>, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nice，非常完美，我们来看看效果：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/49d08351-1ebc-43a0-9917-c20846ab96ab/20200804_153954.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064443Z&X-Amz-Expires=86400&X-Amz-Signature=ec0951f3c6f659ec8bb0a0326beb307e77e4e2c36198e19b1d46dfceca5d4ee1&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200804_153954.gif%22"></p><p>报错了？</p><p>这是为什么呢？</p><p>于是跟踪调试一番，发现如下情况：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8970833f-9608-43c0-8b82-b92548ce3f49%2FUntitled.png?table=block&id=bb92d403-bc95-460a-97c0-bd665a631e8a&name=Untitled.png&cache=v2"></p><p>this 没了，再看看 action：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c74a5640-5aa5-404b-ada9-9e8c9e3011a4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064521Z&X-Amz-Expires=86400&X-Amz-Signature=e7b93ab43c7d3c33c892427e904d04496b5bd369dcdc0a8a27388e29bc5291ba&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>显然，这里因为是在 setTimeout 中调用 commit，丢失了 this，所以我们在构建实例的时候进行绑定就可以啦。</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F82dd6b79-7b33-493b-a83d-bcbac4b88da5%2F20200804_154412.gif?table=block&id=f5abeab6-61cf-483c-b764-04d1ac511828&name=20200804_154412.gif&cache=v2"></p><p>这下就没有问题了。</p><h3 id="扩展-gettter"><a href="#扩展-gettter" class="headerlink" title="扩展 - gettter"></a>扩展 - gettter</h3><p>我们已经实现了基础的 vuex，而平时使用 vuex 的时候，大家知道 getter 也是经常被使用到的。</p><p>那么这个 getter 应当如何实现呢？</p><p>我们假设在创建 vuex 的时候传入 getter，里面只有一个值，是 doubleCounter，返回值是 <code>counter * 2</code>，那么自然 doubleCounter 是被 counter 所影响，我们这里可以画出如下导图：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/41c819ba-442f-4d86-9117-ea179de3b578/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064551Z&X-Amz-Expires=86400&X-Amz-Signature=39275881153c0f3a9c81bbba027eb751ed7cacdc804dca27c1ec70bc14804ea2&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><p>那么问题来了：<strong>怎么将 getter 和 state 关联起来呢？</strong></p><p>仔细想一想，显然这里是做代理，那么答案就呼之欲出了：<strong>Object.defineProperty</strong>。有了这个核心思想之后，我们继续分析，由于 getter 不止一个，那么我们肯定需要遍历传入的 getter obj，将其注册到 store 上。</p><p>我们可以先来实现这一步操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">            <span class="built_in">this</span>._getters = options.getters</span><br><span class="line">            <span class="built_in">this</span>.= <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">            <span class="built_in">this</span>.forEachGetter(<span class="built_in">this</span>, <span class="built_in">this</span>._getters)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">        forEachGetter(store, getters) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.keys(getters).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> getter = getters[key]</span><br><span class="line">                <span class="built_in">this</span>.registerGetter(store, getter, key)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        registerGetter(store, getter, key)&#123;</span><br><span class="line">            store._wrappedGetters[key] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span>(<span class="params">store</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getter(store.state)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完这一步之后，我们可以调试看看：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fbe8eb18e-99b1-4bf1-8af0-62b24d98b158%2FUntitled.png?table=block&id=62cbf2ad-e793-45f6-9bb7-6f8d872f2388&name=Untitled.png&cache=v2"></p><p>可以看到，store 上的属性 _wrappedGetters 中现在包含两个属性：</p><ul><li>doubleCounter：这是一个函数，即 registerGetter 中返回的 wrappedGetter，当我们调用它的时候，会返回 getter(store.state) 执行的结果，及 state.counter * 2</li><li>state：这里是响应式数据（不过现在还不是响应式的）</li></ul><p>现在已经建立好了 options.getter 和 store._wrappedGetters 的映射关系，我们可以开始通过 Object.defineProperty 来做代理了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line">  Store: <span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">      <span class="comment">/*...*/</span></span><br><span class="line">            <span class="built_in">this</span>.resetStoreVm(<span class="built_in">this</span>, options.state)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">        resetStoreVm(store, state) &#123;</span><br><span class="line">      store.getters = &#123;&#125;</span><br><span class="line">      <span class="keyword">const</span> computed = &#123;&#125;</span><br><span class="line">      <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">      <span class="built_in">Object</span>.keys(wrappedGetters).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">        computed[key] = <span class="built_in">this</span>.partial(wrappedGetters[key], store)</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">          get: <span class="function">() =&gt;</span> store._vm[key],</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>._vm = <span class="keyword">new</span> _Vue(&#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            $$state: state,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// ! 计算属性，用于实现 getter</span></span><br><span class="line">        computed: computed,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    partial = <span class="function">(<span class="params">fn, arg</span>) =&gt;</span> <span class="function">() =&gt;</span> fn(arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，比较有容易搞不清楚的就两个地方：</p><ul><li>wrappedGetters[key] 是什么</li><li>partial 返回值是什么</li></ul><p>这个问题直接在调试器里看看就清楚了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff9c75190-5fb6-4c76-9f57-a374603567d0%2FUntitled.png?table=block&id=fd4c96ec-a1ad-407b-b418-81840bfcd806&name=Untitled.png&cache=v2"></p><p>显然，这两位，一个是 getter 的包裹函数，一个是其本身。</p><p>到这里，getter 也算是基本实现了，具体效果如下：</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6fe02525-46b9-4694-a9d4-2828abe7f7a1/20200805_115001.gif?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200807/us-west-2/s3/aws4_request&X-Amz-Date=20200807T064717Z&X-Amz-Expires=86400&X-Amz-Signature=e6300f43deaa27b07f792b533a81d83cfd193865261d72e8d5b61895f695d16a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%2220200805_115001.gif%22"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/vuex-632700a6aa904f64943b83265571a638">手写简易 vuex</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端造轮子【1】 —— vue-router</title>
      <link href="/2020/08/10/2020-08-07_2/"/>
      <url>/2020/08/10/2020-08-07_2/</url>
      
        <content type="html"><![CDATA[<p>今天我们来研究一下 vue-router 的内部实现原理。</p><p>我们知道，vue app 是 spa，是没有页面之间的跳转的，说的直白一点就是没有刷新。那么在不刷新页面的情况下，怎么实现一个项目中，不同页面，不同组件之间的切换展示呢？</p><p>通过学习 vue-router 的源码，可以得知，浏览器为我们提供了两个方案：</p><ul><li>hash（就是页面上的 #）</li><li>history（h5）</li></ul><p>今天我们就简单来实现一下通过 hash 的方式实现 vue 的路由跳转。</p><a id="more"></a><h2 id="Step-1-需求分析"><a href="#Step-1-需求分析" class="headerlink" title="Step 1 - 需求分析"></a>Step 1 - 需求分析</h2><p>首先通过 vue-cli 4.x 创建项目，选择使用 router，并且模式选择为 hash。</p><p>项目创建完成后，我们可以看到 src 目录下有一个 router 文件，其内容大致如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;./yvue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../views/Home.vue&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;About&#x27;</span>,</span><br><span class="line">    component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/About.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p>我们逐步来分析一下上面的代码：</p><ul><li>首先是用过 Vue.use(VueRouter) 注册了插件，那么显然 <strong>VueRouter 是 Vue 的插件</strong>，需要有自己的<strong>静态 install 方法</strong></li><li>接着是我们熟悉的，配置了路有映射表，用于确定路由和组件的关系</li><li>然后通过 new VueRouter({routers}) 创建了路由实例，并且将其导出</li><li>最后熟悉 vue 的同学肯定知道，导出的这个 vue，我们在 main 中将其引用并且传递给了 Vue 本身</li></ul><p>上述流程非常简单，那么从 VueRouter 的角度出发，我们应该做些什么呢？</p><p>首先这里 Vue.use 的时候会调用 VueRouter.install 方法，而在这个方法里我们应该做些什么呢？</p><p>联合 vue-router 的使用我们知道，注册 router 之后，我们可以全局使用两个组件：</p><ul><li>router-view：用于显示组件</li><li>router-link：用于路由跳转</li></ul><p>显然，这两个组件的注册过程是在 install 中，因为这里拥有对全局 Vue 的引用。</p><p>接下来，就是 router 的核心功能，当 hash 改变的时候，改变展示的组件，显然这里我们应该有一个响应式的 current，当 current 改变的时候，就触发 render 重新渲染组件。</p><p>以上，我们可以大致总结一下，如下图所示：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F60eca3e4-2504-42d5-80dc-5b1a29c6d716%2FUntitled.png?table=block&id=69e2386c-541d-4404-958d-0fc65353f69a&name=Untitled.png&cache=v2"></p><h2 id="Step-2-功能实现"><a href="#Step-2-功能实现" class="headerlink" title="Step 2 - 功能实现"></a>Step 2 - 功能实现</h2><p>那么现在我们可以着手开始实现自己的 vue-router 了。</p><p>首先我们肯定需要一个 VueRouter 的类，应为在后面它需要被实例化：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对应 Vue.use</span></span><br><span class="line">  <span class="keyword">static</span> install(Vue) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>紧接着我们就可以在 install 中实现对两个全局组件的注册：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对应 Vue.use</span></span><br><span class="line">    <span class="keyword">static</span> install(Vue)&#123;</span><br><span class="line">        <span class="comment">// step 1: 注册组件 router-link，用于路由跳转</span></span><br><span class="line">        <span class="comment">// 回忆一下 router-link 的使用：</span></span><br><span class="line">        <span class="comment">// * &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt;</span></span><br><span class="line">        Vue.component(<span class="string">&#x27;router-link&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 必要参数 to</span></span><br><span class="line">      props: &#123;</span><br><span class="line">        to: &#123;</span><br><span class="line">          type: <span class="built_in">String</span>,</span><br><span class="line">          <span class="built_in">require</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 模板，可以使用 template，也可以使用 render。</span></span><br><span class="line">      <span class="comment">// * render 更加灵活，并且在 vue 中会把 template 编译成 render 函数。</span></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="comment">// 这里可以写 jsx，也可以使用 h 函数</span></span><br><span class="line">        <span class="comment">// 这里我们使用 jsx，在 view-router 中使用 h，都尝试一下</span></span><br><span class="line">        <span class="comment">// * h 函数类似于 react 中的 createElement</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>`#$&#123;<span class="attr">this.to</span>&#125;`&#125;&gt;</span>&#123;this.$slots.default&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step 2: 注册组件 router-view，用于显示组件</span></span><br><span class="line">            <span class="comment">// 回忆一下 router-link 的使用：</span></span><br><span class="line">            <span class="comment">// &lt;router-view /&gt;</span></span><br><span class="line">            Vue.component(<span class="string">&#x27;router-view&#x27;</span>, &#123;</span><br><span class="line">      <span class="comment">// 没有参数，直接 template</span></span><br><span class="line">      render(h) &#123;</span><br><span class="line">        <span class="comment">// 这里使用 h</span></span><br><span class="line">        <span class="comment">// view-router 的功能是渲染组件，那么组件从哪里获取呢？</span></span><br><span class="line">        <span class="comment">// 回忆 router.js 的路由表，其中有映射 url 地址和组件，所以组件显然是从这里获取</span></span><br><span class="line">        <span class="comment">// 而当前路由我们可以在构造函数中定义一个 current 来表示</span></span><br><span class="line">        <span class="comment">// 所以可以通过以下代码找到当前 current 对应的组件</span></span><br><span class="line">        <span class="keyword">const</span> &#123; routeMap, current &#125; = <span class="built_in">this</span>.$router</span><br><span class="line">        <span class="keyword">const</span> component = routeMap[current] ? routeMap[current].component : <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> h(component)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，至少我们的 <router-link> 已经是可用的了，而 <router-view> 则需要我们在构造函数中实现对路由表的管理以及对 hashchange 的监听。</p><p>那么接下来自然是实现 constructor</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，整个 vue-router 已经实现得差不多了，但还存在这一个巨大的问题，那就是 current 并不是响应式的，当路由切换，current 改变的时候，并不会触发 render 重新渲染组件：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2d5f78cf-5c37-4aa4-a9cd-701e0fc59193%2F20200804_114704.gif?table=block&id=dcb77b60-e4b2-4e30-8f20-9a6cc6cecbd9&name=20200804_114704.gif&cache=v2"></p><p>那应该怎么办呢？</p><p>接下来的问题是：<strong>怎么将 current 转成 vue 响应式数据？</strong></p><p>对于上述问题，这里有两个思路：</p><ul><li>新建 vue 实例，通过 data 将 current 转成响应式数据</li><li>利用 vue 提供的静态方法 <strong>Vue.util.defineReactive</strong></li></ul><p>这里我们采取第二种方案：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里又出现一个问题，这个 Vue 从哪里来呢？</p><p>其实这里需要让思维跳出 constructor：我们知道执行 install 的时候会传入 Vue，那么在 install 的时候我们保存一个全局变量 _Vue 即可在 constructor 中进行使用了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应 new</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    options.routes.map(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">    _Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onHashChange() &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，基本的路由已经实现了：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fef5b0447-bf3f-4b40-a525-347d5cefb018%2F20200804_134007.gif?table=block&id=0716b1fc-78ea-4d35-b7cb-0c9f4f16818e&name=20200804_134007.gif&cache=v2"></p><p>还有一些可以扩展的地方：</p><p>比如优化一下 constructor，将 options 保存到本地：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">    <span class="built_in">this</span>.$options = options</span><br><span class="line">    <span class="comment">// 初始化路由表</span></span><br><span class="line">    <span class="built_in">this</span>.routerMap = &#123;&#125;</span><br><span class="line">    <span class="built_in">this</span>.$options.routes.map(<span class="function">(<span class="params">route</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.routerMap[route.path] = route</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 current</span></span><br><span class="line">    <span class="keyword">const</span> initial = <span class="built_in">window</span>.location.hash.slice(<span class="number">1</span>) || <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  _Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;current&#x27;</span>, initial)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听 hashchange</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="built_in">this</span>.onHashChange.bind(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以保证数据的单向流动。</p><p>比如为组件实例挂载 $router，这样我们就可以像 this.$router.push() 这样使用 router 上的方法了。</p><p>不过这里有一个点值得注意，那就是时间：</p><p>因为当我们执行 install 的时候，VueRouter 的实例还没创建，那么直接通过：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br></pre></td></tr></table></figure><p>进行挂载显然是不行的。</p><p>这里我们可以借助 mixin 来使用 Vue 的生命周期钩子，当组件创建之前进行挂载操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$options.router) &#123;</span><br><span class="line">      Vue.prototype.$router = <span class="built_in">this</span>.$options.router</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就没什么问题了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>更佳阅读体验：<a href="https://www.notion.so/vue-router-5e3643ff7f344645bf6fa0b0a4229115">手写简易 vue-router</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 爬坑之旅【2】 —— 网站配置</title>
      <link href="/2020/08/07/2020-08-07_1/"/>
      <url>/2020/08/07/2020-08-07_1/</url>
      
        <content type="html"><![CDATA[<p>前面已经将网站的基本架子搭好了，但通用的配置显然并不适用于每一个人，这里就通过配置文件稍微自定义一下。</p><a id="more"></a><h2 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h2><p>目标文件：root/ _config.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">世界的侧面</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">初心Yearth</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">https://s1.ax1x.com/2020/08/06/agXE9K.png</span></span><br></pre></td></tr></table></figure><h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>目标文件：root/themes/volantis/_config.yml</p><h3 id="封面配置"><a href="#封面配置" class="headerlink" title="封面配置"></a>封面配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">    <span class="attr">M title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># subtitle: &#x27;&#x27;</span></span><br><span class="line">    <span class="attr">M search:</span> <span class="string">你想看点什么呢？</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># features: // 这个选项是搜索框下的导航按钮，这里选择注释掉</span></span><br></pre></td></tr></table></figure><h2 id="导航栏配置"><a href="#导航栏配置" class="headerlink" title="导航栏配置"></a>导航栏配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">navbar:</span></span><br><span class="line">    <span class="attr">logo:</span></span><br><span class="line">        <span class="attr">img:</span></span><br><span class="line">        <span class="attr">icon:</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    <span class="attr">menu:</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 博客</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># icon: fas fa-rss</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># url: /</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">分类</span></span><br><span class="line">            <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">标签</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">tags/</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 归档</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># icon: fas fa-archive</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># url: archives/</span></span><br><span class="line">        <span class="string">M</span> <span class="comment"># - name: 友链</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># icon: fas fa-link</span></span><br><span class="line">    <span class="string">M</span> <span class="comment"># url: friends/</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">关于</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-info-circle</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">about/</span></span><br><span class="line">        <span class="attr">search:</span> <span class="string">你想看点什么呢？</span></span><br></pre></td></tr></table></figure><h2 id="布局配置"><a href="#布局配置" class="headerlink" title="布局配置"></a>布局配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">layout:</span></span><br><span class="line"><span class="attr">on_page:</span></span><br><span class="line"><span class="attr">M body:</span> [<span class="string">article</span>]</span><br></pre></td></tr></table></figure><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins:</span></span><br><span class="line"><span class="attr">backstretch:</span></span><br><span class="line"><span class="attr">M position:</span> <span class="string">fixed</span></span><br><span class="line"><span class="attr">aplayer:</span></span><br><span class="line"><span class="attr">M id:</span> <span class="number">170672512</span></span><br><span class="line"><span class="attr">M autoplay:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F030e52f5-b2d0-4a4f-b55c-0a3b58e04239%2FUntitled.png?table=block&id=b9f55037-fcbd-4e24-842a-695381f423db&name=Untitled.png&cache=v2"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 爬坑之旅【1】 —— 基础搭建</title>
      <link href="/2020/08/07/2020-08-06/"/>
      <url>/2020/08/07/2020-08-06/</url>
      
        <content type="html"><![CDATA[<p>没有一个自己的个人博客，显然是不够程序员的，于是今天在一番折腾之下，通过 Github + Hexo 配置了一个在线的博客，特此记录。当然如果喜欢更加偏向文档风格的童鞋，可以选择 Vuepress。</p><a id="more"></a><h2 id="Step-1-Hexo-本地安装及运行测试"><a href="#Step-1-Hexo-本地安装及运行测试" class="headerlink" title="Step 1 - Hexo 本地安装及运行测试"></a>Step 1 - Hexo 本地安装及运行测试</h2><p>首先全局安装 Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装好之后使用 Hexo 创建一个目录，用于构建个人博客网站，这里我们就叫 daily_record：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init daily_record</span><br></pre></td></tr></table></figure><p>接下来进入到博客目录下，安装依赖，运行即可查看初始状态了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> daily_record</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>如果上述步骤没有出错的话，应该可以在本地的 4000 端口看到如下界面：</p><p><img src="https://www.notion.so/signed/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F35c84369-6339-46b8-a300-10693b7e875e%2FUntitled.png?table=block&id=f2429731-a74f-4f44-a6fc-f0ef9abb2c60&name=Untitled.png&cache=v2"></p><h2 id="Step-2-更换-Volantis-主题"><a href="#Step-2-更换-Volantis-主题" class="headerlink" title="Step 2 - 更换 Volantis 主题"></a>Step 2 - 更换 Volantis 主题</h2><p>想必你也觉得默认主题有点 low。(毕竟是多年前的产物了，有点跟不上时代的审美)</p><p>好在 Hexo 生态足够丰富，有很多优秀的主题，比如 Volantis。</p><p>接下来进入到项目的根目录，开始安装主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xaoxuu/hexo-theme-volantis themes/volantis</span><br></pre></td></tr></table></figure><p>下载好之后，修改根目录下的 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">theme:</span> <span class="string">landscape</span></span><br><span class="line"><span class="string">+</span> <span class="attr">theme:</span> <span class="string">volantis</span></span><br></pre></td></tr></table></figure><p>然后安装一些依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search hexo-generator-json-content hexo-renderer-stylus -S</span><br></pre></td></tr></table></figure><p>现在重新启动服务，你的网站应该变成了这样</p><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f9d35ec4-0bdc-4e1e-9280-3cba80f5a71b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200806/us-west-2/s3/aws4_request&X-Amz-Date=20200806T092415Z&X-Amz-Expires=86400&X-Amz-Signature=e700ffe5b7313d847e6e4c4cbe29bc33a20307aa9ce3ddf0e1606bead705d98e&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p><h2 id="Step-3-部署到-Gitub"><a href="#Step-3-部署到-Gitub" class="headerlink" title="Step 3 - 部署到 Gitub"></a>Step 3 - 部署到 Gitub</h2><p>这个主题有很多配置，具体可以参考<a href="https://volantis.js.org/v2/getting-started/">官方文档</a>，这里就还不在赘述。</p><p>要将个人主页部署到 Github，首先我们要去 Github 创建一个 yourname.github.io 的仓库。</p><p>需要注意的是，yourname 一定要和你的 github name 完全一样，并且一定要选择初始化项目</p><p>然后安装 Hexo 的部署插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -S</span><br></pre></td></tr></table></figure><p>安装好之后，修改根目录下的 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">repo:</span> <span class="string">https://github.com/yourname/yourname.github.io</span></span><br><span class="line"><span class="string">+</span>  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>最后通过以下命令即可一键部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><h2 id="Step-4-访问个人主页"><a href="#Step-4-访问个人主页" class="headerlink" title="Step 4 - 访问个人主页"></a>Step 4 - 访问个人主页</h2><p>接下来就可以在下面的地址访问你的个人主页了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://yourname.github.io/</span><br></pre></td></tr></table></figure><p><img src="https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0c0da1b1-57a7-4899-b0ef-f345e46af4a4/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5/20200806/us-west-2/s3/aws4_request&X-Amz-Date=20200806T092430Z&X-Amz-Expires=86400&X-Amz-Signature=ff4f20c6532b8aca669d0b867b9a2ad3945e685fbecde46bf7f2546da0b5f47a&X-Amz-SignedHeaders=host&response-content-disposition=filename%20=%22Untitled.png%22"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
